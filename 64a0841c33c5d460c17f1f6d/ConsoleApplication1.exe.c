/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

errno_t __cdecl j__set_fmode(int Mode);
__int64 __fastcall j___vcrt_LoadLibraryExW(_QWORD, _QWORD, _QWORD); // weak
__int64 sub_14001100F(void); // weak
__int64 __fastcall sub_140011019(_QWORD, _QWORD); // weak
errno_t __cdecl j_strcat_s(char *Destination, rsize_t SizeInBytes, const char *Source);
__int64 sub_140011023(void); // weak
_BOOL8 __fastcall sub_140011032(unsigned __int8);
void *sub_14001103C();
__int64 __fastcall sub_140011041(_QWORD); // weak
__int64 j_terminate(void); // weak
__int64 __fastcall sub_14001104B(__int64);
void sub_140011055();
__int64 __fastcall sub_14001105A(_QWORD); // weak
void *sub_14001105F();
_QWORD *__fastcall sub_140011069(_QWORD *, _QWORD *);
__int64 __fastcall sub_14001107D(__int64, unsigned __int64);
void *sub_14001108C();
void __cdecl __noreturn j_exit(int Code);
int __cdecl j__initialize_narrow_environment();
__int64 __fastcall sub_1400110AA(__int64);
__int64 __fastcall sub_1400110AF(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_1400110B4(__int64);
__int64 __fastcall sub_1400110B9(__int64);
__int64 __fastcall sub_1400110BE(_QWORD, _QWORD); // weak
errno_t __cdecl j__wmakepath_s(wchar_t *Buffer, size_t BufferCount, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
__int64 sub_1400110C8(void); // weak
__int64 __fastcall sub_1400110D7(_QWORD); // weak
__int64 __fastcall sub_1400110DC(__int64, __int64);
__int64 sub_1400110EB(void); // weak
__int64 sub_1400110F5(void); // weak
unsigned __int64 __fastcall sub_1400110FA(__int64, unsigned __int64);
__int64 sub_1400110FF(void); // weak
__int64 sub_140011109(void); // weak
__int64 __fastcall sub_14001110E(__int64, __int64);
_QWORD *__fastcall sub_140011113(_QWORD *, __int64);
__int64 __fastcall j___CxxFrameHandler4(_QWORD, _QWORD, _QWORD, _QWORD); // weak
char **__cdecl j__get_initial_narrow_environment();
__int64 __fastcall sub_140011127(__int64);
__int64 __fastcall sub_140011131(_QWORD); // weak
__int64 __fastcall sub_140011136(_QWORD); // weak
__int64 j___current_exception(void); // weak
__int64 __fastcall sub_140011140(__int64, __int64);
__int64 __fastcall sub_140011154(__int64 *, __int64 *);
void (__cdecl *__fastcall sub_140011159(void (__cdecl *)()))();
int __cdecl UserMathErrorFunction(struct _exception *); // idb
__int64 __fastcall sub_140011168(_QWORD, _QWORD); // weak
__int64 __fastcall j__free_dbg(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140011172(_QWORD); // weak
__int64 __fastcall sub_140011177(__int64 *);
__int64 sub_14001117C(void); // weak
_QWORD *__fastcall sub_140011181(_QWORD *, __int64);
char __fastcall sub_140011186();
__int64 sub_140011190(void); // weak
__int64 __fastcall sub_14001119A(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j___GSHandlerCheckCommon(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_1400111AE(_QWORD, _QWORD); // weak
__int64 sub_1400111B3(void); // weak
__int64 __fastcall sub_1400111B8(_QWORD); // weak
bool std::uncaught_exception(void); // idb
__int64 __fastcall sub_1400111C7(_QWORD); // weak
__int64 __fastcall sub_1400111CC(_QWORD); // weak
__int64 __fastcall sub_1400111DB(_QWORD, _QWORD); // weak
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
__int64 __fastcall sub_1400111EF(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j___vcrt_GetModuleHandleW(_QWORD); // weak
void __noreturn sub_1400111FE(void); // weak
__int64 sub_140011208(void); // weak
__int64 __fastcall sub_140011217(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_140011221(_QWORD *, _QWORD *);
__int64 __fastcall sub_140011226(_QWORD); // weak
__int64 j_nullsub_1(void); // weak
errno_t __cdecl j_strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source);
int __cdecl j__crt_atexit(_PVFV Function);
__int64 __fastcall sub_14001124E(_QWORD); // weak
int __cdecl j__configthreadlocale(int Flag);
__int64 __fastcall j___std_exception_copy(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140011271(_QWORD, _QWORD); // weak
__int64 sub_14001127B(void); // weak
__int64 __fastcall sub_140011285(_QWORD, _QWORD); // weak
__int64 __fastcall sub_14001128F(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_1400112A3(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400112AD(_QWORD); // weak
__int64 sub_1400112B2(void); // weak
__int64 __fastcall sub_1400112B7(_QWORD); // weak
__int64 __fastcall sub_1400112C1(__int64, __int64, unsigned __int8 *);
__int64 __fastcall sub_1400112C6(_QWORD); // weak
__int64 __fastcall sub_1400112D5(__int64 a1);
__int64 __fastcall sub_1400112DF(_QWORD); // weak
__int64 __fastcall sub_1400112E9(_QWORD); // weak
__int64 __fastcall sub_1400112F8(unsigned __int64);
__int64 sub_1400112FD(void); // weak
__int64 __fastcall sub_140011302(_QWORD); // weak
__int64 __fastcall sub_14001130C(__int64);
__int64 __fastcall sub_140011311(_QWORD); // weak
__int64 __fastcall sub_140011316(__int64);
__int64 __fastcall sub_14001131B(_QWORD); // weak
__int64 __fastcall sub_14001132A(_QWORD, _QWORD, _QWORD); // weak
size_t __cdecl j_strlen(const char *Str);
errno_t __cdecl j_wcscpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
__int64 __fastcall sub_140011343(_QWORD); // weak
__int64 __fastcall sub_140011348(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_140011352(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140011357(_QWORD); // weak
__int64 sub_14001135C(void); // weak
__int64 sub_140011366(void); // weak
int __cdecl j__initterm_e(_PIFV *First, _PIFV *Last);
__int64 sub_14001137F(void); // weak
__int64 __fastcall sub_140011384(_QWORD, _QWORD); // weak
void *__cdecl j_memcpy(void *, const void *Src, size_t Size);
__int64 __fastcall sub_140011393(__int64);
int __cdecl j__crt_at_quick_exit(_PVFV Function);
__int64 __fastcall sub_1400113A2(_QWORD); // weak
void __noreturn sub_1400113B1(void); // weak
int __cdecl j__seh_filter_dll(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);
__int64 __fastcall sub_1400113C5(__int64, __int64);
__int64 __fastcall sub_1400113CA(_QWORD, _QWORD); // weak
void __cdecl j__set_app_type(_crt_app_type Type);
__int64 __fastcall sub_1400113D9(_QWORD); // weak
__int64 __fastcall sub_1400113DE(__int64);
__int64 __fastcall j___std_exception_destroy(_QWORD); // weak
__int64 sub_1400113E8(void); // weak
__int64 sub_1400113F2(void); // weak
__int64 sub_1400113FC(void); // weak
__int64 __fastcall sub_140011406(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_14001140B(__int64, __int64);
__int64 __fastcall sub_140011415(_QWORD); // weak
_QWORD *__fastcall sub_14001141A(_QWORD *, __int64);
__int64 __fastcall sub_14001141F(unsigned __int64);
__int64 __fastcall sub_140011424(_QWORD); // weak
__int64 __fastcall sub_140011429(_QWORD); // weak
void *__fastcall sub_14001142E(size_t);
__int64 sub_140011438(void); // weak
_QWORD *__fastcall sub_14001143D(_QWORD *, _QWORD *);
__int64 __fastcall sub_140011442(_QWORD); // weak
__int64 sub_140011451(_QWORD, _QWORD, const char *, ...); // weak
void __fastcall sub_14001145B(void *);
void *__cdecl j_malloc(size_t Size);
__int64 __fastcall sub_140011465(__int64);
__int64 sub_140011479(void); // weak
void __cdecl j___setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
__int64 __fastcall sub_140011483(); // weak
__int64 __fastcall sub_140011488(_QWORD); // weak
__int64 __fastcall sub_14001148D(__int64, __int64);
__int64 sub_14001149C(void); // weak
__int64 sub_1400114A6(void); // weak
__int64 __fastcall sub_1400114AB(__int64);
__int64 j___current_exception_context(void); // weak
int __cdecl j__register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
__int64 sub_1400114BA(void); // weak
int __cdecl j__execute_onexit_table(_onexit_table_t *Table);
__int64 __fastcall sub_1400114C4(__int64 a1);
__int64 __fastcall sub_1400114D3(_QWORD); // weak
__int64 __fastcall sub_1400114DD(__int64, unsigned __int64);
__int64 __fastcall sub_1400114E2(_QWORD, _QWORD); // weak
_BOOL8 __fastcall sub_1400114E7(unsigned __int8 *);
__int64 __fastcall sub_140011505(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_14001150A(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_14001150F(__int64);
__int64 __fastcall start(); // weak
__int64 sub_14001151E(void); // weak
__int64 __fastcall sub_140011528(__int64);
__int64 sub_14001152D(void); // weak
__int64 sub_140011532(void); // weak
__int64 sub_140011550(void); // weak
__int64 __fastcall sub_14001155A(_QWORD); // weak
__int64 j___report_rangecheckfailure(void); // weak
__int64 __fastcall sub_140011573(_DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD); // weak
int __cdecl j__callnewh(size_t Size);
__int64 __fastcall sub_14001157D(_QWORD, _QWORD, _QWORD); // weak
int *__cdecl j___p__commode();
int *__cdecl j___p___argc();
__int64 sub_14001159B(void); // weak
__int64 __fastcall sub_1400115A0(__int64);
__int64 sub_1400115AA(void); // weak
int __cdecl j__set_new_mode(int NewMode);
__int64 sub_1400115B9(void); // weak
void sub_1400115BE();
void __noreturn sub_1400115DC(void); // weak
char ***__cdecl j___p___argv();
__int64 __fastcall sub_1400115E6(_QWORD, _QWORD); // weak
__int64 __fastcall sub_1400115EB(_QWORD, _QWORD); // weak
__int64 __fastcall sub_1400115F0(_QWORD); // weak
__int64 __fastcall j___std_type_info_destroy_list(_QWORD); // weak
__int64 __fastcall sub_1400115FA(_QWORD, _QWORD); // weak
__int64 sub_1400115FF(void); // weak
__int64 __fastcall sub_140011604(_DWORD, _DWORD, _DWORD, _DWORD, char); // weak
__int64 __fastcall sub_14001160E(_QWORD); // weak
__int64 __fastcall sub_140011613(_QWORD); // weak
__int64 __fastcall sub_140011618(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_140011627(_QWORD *);
__int64 __fastcall sub_14001162C(_QWORD); // weak
void __cdecl j__initterm(_PVFV *First, _PVFV *Last);
struct _TEB *sub_140011636();
__int64 sub_14001163B(void); // weak
__int64 __fastcall sub_140011640(__int64);
__int64 __fastcall sub_14001164F(__int64, __int64);
__int64 sub_140011654(void); // weak
__int64 __fastcall sub_140011663(_QWORD); // weak
__int64 sub_140011668(void); // weak
__int64 __fastcall sub_14001166D(__int64, __int64);
_QWORD *__fastcall sub_140011672(_QWORD *, unsigned __int64, char, char);
__int64 __fastcall sub_140011686(_QWORD); // weak
__int64 __fastcall sub_14001168B(_QWORD); // weak
__int64 __fastcall sub_140011690(_QWORD, _QWORD); // weak
void __fastcall std::_Xout_of_range(const char *); // idb
__int64 __fastcall sub_14001169F(_QWORD); // weak
__int64 __fastcall sub_1400116A4(_QWORD); // weak
int __cdecl j__seh_filter_exe(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);
_QWORD *__fastcall sub_1400116B3(__int64, _QWORD *);
__int64 __fastcall sub_1400116BD(__int64);
int __cdecl j___stdio_common_vsprintf_s(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
__int64 __fastcall sub_1400116C7(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_1400116D1(_QWORD); // weak
__int64 __fastcall sub_1400116DB(_QWORD, _QWORD); // weak
__int64 __fastcall sub_1400116E0(_QWORD); // weak
void __fastcall __noreturn std::_Xlength_error(const char *); // idb
__int64 __fastcall sub_1400116EA(_QWORD, _QWORD); // weak
__int64 __fastcall sub_1400116EF(__int64);
__int64 __fastcall sub_1400116F4(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list); // idb
_BOOL8 __fastcall sub_1400116F9(__int64);
void __cdecl j__register_thread_local_exe_atexit_callback(_tls_callback_type Callback);
__int64 __fastcall sub_140011708(_QWORD); // weak
void __cdecl j__cexit();
__int64 __fastcall sub_140011712(_QWORD); // weak
__int64 __fastcall sub_140011717(_QWORD); // weak
__int64 __fastcall sub_14001171C(__int64, __int64, int);
__int64 __fastcall sub_140011721(_QWORD); // weak
__int64 __fastcall sub_140011730(_QWORD); // weak
__int64 __fastcall sub_140011735(_QWORD, _QWORD); // weak
__int64 j_nullsub_2(void); // weak
__int64 sub_14001173F(void); // weak
__int64 __fastcall sub_140011744(_QWORD *, _QWORD *);
errno_t __cdecl j__wsplitpath_s(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
errno_t __cdecl j__configure_narrow_argv(_crt_argv_mode mode);
__int64 __fastcall sub_14001175D(_QWORD); // weak
__int64 __fastcall j___vcrt_GetModuleFileNameW(_QWORD, _QWORD, _QWORD); // weak
__int64 sub_140011767(void); // weak
__int64 __fastcall sub_14001176C(__int64, __int64, char);
__int64 __fastcall sub_140011776(_QWORD); // weak
void __noreturn sub_14001177B(void); // weak
__int64 __fastcall sub_140011780(__int64);
__int64 __fastcall sub_14001178A(_QWORD); // weak
int __cdecl j__initialize_onexit_table(_onexit_table_t *Table);
__int64 __fastcall sub_1400117AD(__int64);
void __stdcall __noreturn j__CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
_QWORD *__fastcall sub_1400117C6(_QWORD *);
__int64 __fastcall sub_140011FC0(__int64 a1);
__int64 __fastcall sub_140012030(__int64 a1);
__int64 __fastcall sub_140012080(__int64 a1, __int64 a2);
__int64 __fastcall sub_140012560(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_1400125C0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140012670(unsigned __int64 a1);
unsigned __int64 __fastcall sub_1400126F0(unsigned __int64 a1);
_QWORD *__fastcall sub_140012850(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400128E0(__int64 a1, _QWORD *a2);
_BOOL8 __fastcall sub_140012970(unsigned __int8 *a1);
__int64 __fastcall sub_1400129F0(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140012A70(__int64 a1, __int64 a2);
__int64 __fastcall sub_140012AD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140012B30(); // weak
__int64 __fastcall sub_140012B70(__int64 a1, __int64 a2, unsigned __int8 *a3);
__int64 __fastcall sub_140012C80(__int64 a1);
__int64 __fastcall sub_140012CD0(unsigned __int64 a1);
__int64 __fastcall sub_140012D50(__int64 a1);
__int64 __fastcall sub_140012D90(__int64 a1);
_QWORD *__fastcall sub_140012DD0(_QWORD *a1, unsigned __int64 a2, char a3, char a4);
_QWORD *__fastcall sub_1400130B0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_140013110(__int64 a1);
__int64 __fastcall sub_140013150(__int64 a1);
__int64 __fastcall sub_140013190(__int64 a1);
__int64 __fastcall sub_1400131D0(unsigned __int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_1400132C0(__int64 a1);
__int64 __fastcall sub_140013300(__int64 a1);
__int64 __fastcall sub_140013340(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_1400133B0(__int64 a1);
__int64 __fastcall sub_1400133F0(__int64 a1);
__int64 __fastcall sub_140013430(__int64 a1);
__int64 __fastcall sub_1400134C0(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_140013530(__int64 a1, __int64 a2, unsigned __int8 *a3);
__int64 __fastcall sub_140013600(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_140013930(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1400139C0(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_140013A60(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_140013B00(__int64 a1);
__int64 __fastcall sub_140013B90(__int64 a1);
_QWORD *__fastcall sub_140013BD0(_QWORD *a1);
void *__fastcall sub_140013C70(void *a1);
_QWORD *__fastcall sub_140013CD0(_QWORD *a1);
_QWORD *__fastcall sub_140013D20(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140013D90(__int64 a1, __int64 a2);
__int64 __fastcall sub_140013E50(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140013F10(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140013F90(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140013FF0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140014050(_QWORD *a1);
_QWORD *__fastcall sub_1400140C0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140014160(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140014200(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140014290(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400143E0(__int64 a1);
__int64 __fastcall sub_140014420(__int64 a1);
__int64 __fastcall sub_140014460(__int64 *a1);
__int64 __fastcall sub_140014570(); // weak
__int64 __fastcall sub_1400145B0(__int64 a1);
__int64 __fastcall sub_140014650(__int64 a1);
__int64 __fastcall sub_1400146F0(__int64 a1);
__int64 __fastcall sub_140014730(__int64 a1);
__int64 __fastcall sub_140014770(_QWORD *a1);
__int64 __fastcall sub_1400147D0(__int64 a1);
__int64 __fastcall sub_140014810(_QWORD *a1);
__int64 __fastcall sub_1400148A0(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_1400148F0(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_140014A00(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140014B10(__int64 a1);
__int64 __fastcall sub_140014B60(__int64 a1);
__int64 sub_140014BB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...);
__int64 __fastcall sub_140014C80(__int64 a1, unsigned __int8 a2);
__int64 __fastcall sub_140014CE0(__int64 a1, char a2);
__int64 __fastcall sub_140014D50(__int64 a1, char a2);
__int64 __fastcall sub_140014DC0(__int64 a1, char a2);
__int64 __fastcall sub_140014E30(); // weak
_QWORD *__fastcall sub_140014E70(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_1400150B0(__int64 a1);
__int64 __fastcall sub_140015100(__int64 a1, __int64 a2);
__int64 __fastcall sub_140015170(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_1400152D0(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_140015330(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400153C0(__int64 a1);
__int64 __fastcall sub_140015400(__int64 a1);
__int64 __fastcall sub_140015440(__int64 a1);
__int64 __fastcall sub_140015490(__int64 a1);
_BOOL8 __fastcall sub_1400154E0(__int64 a1);
__int64 __fastcall sub_140015550(__int64 a1);
__int64 __fastcall sub_1400155D0(__int64 a1);
__int64 __fastcall sub_140015650(__int64 a1);
__int64 __fastcall sub_1400156A0(__int64 a1);
__int64 __fastcall sub_140015760(__int64 a1);
__int64 __fastcall sub_140015810(); // weak
void __fastcall __noreturn sub_140015850(); // weak
__int64 __fastcall sub_1400158B0(_QWORD *a1);
__int64 __fastcall sub_1400159D0(__int64 a1);
__int64 __fastcall sub_140015A70(__int64 a1);
__int64 __fastcall sub_140015AC0(__int64 a1);
void __fastcall __noreturn sub_140015B20(); // weak
void sub_140015B60();
__int64 __fastcall sub_140015BA0(); // weak
__int64 __fastcall sub_140015BE0(); // weak
__int64 __fastcall sub_140015C20(__int64 a1, __int64 a2);
__int64 __fastcall sub_140015C80(__int64 a1, unsigned __int64 a2);
void *__fastcall sub_140015CE0(size_t a1);
_BYTE *__fastcall sub_140015D30(_BYTE *a1, _BYTE *a2);
__int64 __fastcall sub_140015D90(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400162B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140016770(__int64 a1);
void *__fastcall sub_1400167C0(void *a1, const void *a2, size_t a3);
__int64 __fastcall sub_140016830(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140016890(__int64 a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_1400169A0(void *a1);
__int64 __fastcall sub_1400169F0(); // weak
_BOOL8 __fastcall sub_140016A30(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_140016AB0(__int64 a1, unsigned __int64 a2);
_BOOL8 __fastcall sub_140016B30(unsigned __int8 a1);
size_t __fastcall sub_140016BC0(const char *a1);
__int64 __fastcall sub_140016C10(__int64 a1);
__int64 __fastcall sub_140016C60(); // weak
__int64 __fastcall sub_140016CA0(); // weak
__int64 __fastcall sub_140016CE0(__int64 a1);
_QWORD *__fastcall sub_140016E00(_QWORD *a1, char a2);
__int64 __fastcall sub_140016F30(__int64 a1);
__int64 __fastcall sub_140016F80(unsigned __int8 *a1);
__int64 __fastcall sub_140016FC0(unsigned __int8 *a1);
const char *__fastcall sub_140017000(__int64 a1);
errno_t __fastcall sub_140017090(struct tm *a1, const __time64_t *a2);
__int64 __fastcall sub_1400170F0(); // weak
__time64_t __fastcall sub_140017620(__time64_t *a1);
char **__fastcall sub_140017670(char **a1, char *a2, char *a3, char **a4, char a5, char a6);
char **__fastcall sub_140017750(char **a1, char *a2, char *a3, char **a4, unsigned __int8 a5, unsigned __int8 a6);
__int16 **__fastcall sub_140017830(__int16 **a1, __int16 *a2, __int16 *a3, __int16 **a4, __int16 a5, __int16 a6);
__int16 **__fastcall sub_140017910(__int16 **a1, __int16 *a2, __int16 *a3, __int16 **a4, unsigned __int16 a5, unsigned __int16 a6);
int **__fastcall sub_1400179F0(int **a1, int *a2, int *a3, int **a4, int a5, int a6);
unsigned int **__fastcall sub_140017AC0(unsigned int **a1, unsigned int *a2, unsigned int *a3, unsigned int **a4, unsigned int a5, unsigned int a6);
__int64 **__fastcall sub_140017B90(__int64 **a1, __int64 *a2, __int64 *a3, __int64 **a4, __int64 a5, __int64 a6);
__int64 **__fastcall sub_140017C70(__int64 **a1, __int64 *a2, __int64 *a3, __int64 **a4, unsigned __int64 a5, unsigned __int64 a6);
__int64 __fastcall sub_140017D50(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_140017DD0(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3, unsigned __int16 a4);
__int64 __fastcall sub_140017E50(_DWORD *a1, _DWORD *a2, __int64 a3, int a4);
__int64 __fastcall sub_140017ED0(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4);
unsigned __int8 *__fastcall sub_140017F50(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3);
unsigned __int16 *__fastcall sub_140017FB0(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 a3);
_DWORD *__fastcall sub_140018020(_DWORD *a1, _DWORD *a2, int a3);
_QWORD *__fastcall sub_140018080(_QWORD *a1, _QWORD *a2, __int64 a3);
unsigned __int8 *__fastcall sub_1400180E0(unsigned __int8 *a1, unsigned __int8 a2);
unsigned __int16 *__fastcall sub_140018130(unsigned __int16 *a1, unsigned __int16 a2);
_DWORD *__fastcall sub_140018180(_DWORD *a1, int a2);
_QWORD *__fastcall sub_1400181D0(_QWORD *a1, __int64 a2);
__m128i __fastcall sub_140018220(const __m128i *a1, char a2);
__m128i __fastcall sub_140018490(const __m128i *a1, char a2);
__m128i __fastcall sub_140018650(const __m128i *a1, char a2);
__m128i __fastcall sub_140018760(const __m128i *a1, char a2);
__m128i __fastcall sub_140018830(const __m128i *a1, char a2);
__m128i __fastcall sub_140018AA0(const __m128i *a1, char a2);
__m128i __fastcall sub_140018C60(const __m128i *a1, char a2);
__m128i __fastcall sub_140018D70(const __m128i *a1, char a2);
__m128i __fastcall sub_140018E40(const __m128i *a1, char a2);
__m128i __fastcall sub_1400190B0(const __m128i *a1, char a2);
__m128i __fastcall sub_140019270(const __m128i *a1, char a2);
__m128i __fastcall sub_140019380(const __m128i *a1, char a2);
__m128i __fastcall sub_140019450(const __m128i *a1, char a2);
__m128i __fastcall sub_1400196C0(const __m128i *a1, char a2);
__m128i __fastcall sub_140019880(const __m128i *a1, char a2);
__m128i __fastcall sub_140019990(const __m128i *a1, char a2);
_BYTE *__fastcall sub_140019A60(_BYTE *a1, _BYTE *a2, _BYTE *a3, char a4);
unsigned __int8 *__fastcall sub_140019AF0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 a4);
_WORD *__fastcall sub_140019B80(_WORD *a1, _WORD *a2, _WORD *a3, __int16 a4);
unsigned __int16 *__fastcall sub_140019C10(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 a4);
_DWORD *__fastcall sub_140019CA0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4);
unsigned int *__fastcall sub_140019D20(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int a4);
_QWORD *__fastcall sub_140019DA0(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4);
unsigned __int64 *__fastcall sub_140019E30(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
char *__fastcall sub_140019EC0(char *a1, char *a2, char *a3, char a4);
unsigned __int8 *__fastcall sub_140019F50(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 a4);
__int16 *__fastcall sub_140019FE0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 a4);
unsigned __int16 *__fastcall sub_14001A070(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 a4);
_DWORD *__fastcall sub_14001A100(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4);
unsigned int *__fastcall sub_14001A180(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int a4);
_QWORD *__fastcall sub_14001A200(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4);
unsigned __int64 *__fastcall sub_14001A290(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
__int64 __fastcall sub_14001A320(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001AAF0(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001B2E0(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001BAE0(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001C190(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001C970(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001D170(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001D980(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_14001E040(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_14001EC40(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_14001F890(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_1400204D0(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_140020F80(__int64 a1, __int64 a2, _QWORD *a3, char a4, unsigned __int8 a5);
__int16 *__fastcall sub_140021010(__int16 *a1, __int16 *a2, __int16 **a3, char a4, __int16 a5);
unsigned int *__fastcall sub_1400210B0(unsigned int *a1, unsigned int *a2, unsigned int **a3, char a4, int a5);
unsigned __int64 *__fastcall sub_140021140(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 **a3, char a4, __int64 a5);
__int64 __fastcall sub_1400211F0(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, unsigned __int8 a6);
unsigned __int16 *__fastcall sub_140021280(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3, char a4, int a5, __int16 a6);
unsigned int *__fastcall sub_140021320(unsigned int *a1, unsigned int *a2, __int64 a3, char a4, int a5, int a6);
unsigned __int64 *__fastcall sub_1400213B0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, char a4, int a5, __int64 a6);
char **__fastcall sub_140021460(char **a1, char *a2, char *a3, char **a4, char a5, char a6, char a7);
__int16 **__fastcall sub_140021590(__int16 **a1, __int16 *a2, __int16 *a3, __int16 **a4, char a5, __int16 a6, __int16 a7);
int **__fastcall sub_1400216D0(int **a1, int *a2, int *a3, int **a4, char a5, int a6, int a7);
__int64 **__fastcall sub_140021800(__int64 **a1, __int64 *a2, __int64 *a3, __int64 **a4, char a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_140021960(__int64 a1, __int64 a2, _BYTE *a3);
_WORD *__fastcall sub_1400219C0(_WORD *a1, _WORD *a2, _WORD *a3);
_DWORD *__fastcall sub_140021A20(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_QWORD *__fastcall sub_140021A80(_QWORD *a1, _QWORD *a2, _QWORD *a3);
char *__fastcall sub_140021AE0(char *a1, char *a2);
__int16 *__fastcall sub_140021B70(__int16 *a1, __int16 *a2);
int *__fastcall sub_140021C00(int *a1, int *a2);
__int64 *__fastcall sub_140021C90(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_140021D20(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3);
__int64 __fastcall sub_140022010(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3);
__int64 __fastcall sub_140022310(__m128i *a1, _DWORD *a2, unsigned int a3);
__int64 __fastcall sub_140022610(__m128i *a1, _QWORD *a2, __int64 a3);
__m128i *__fastcall sub_140022910(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3);
__m128i *__fastcall sub_140022C30(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3);
__m128i *__fastcall sub_140022F50(__m128i *a1, _DWORD *a2, unsigned int a3);
__m128i *__fastcall sub_140023270(__m128i *a1, _QWORD *a2, __int64 a3);
__m128i *__fastcall sub_140023590(unsigned __int8 *a1, unsigned __int8 a2);
__m128i *__fastcall sub_140023A40(unsigned __int16 *a1, __int16 a2);
__m128i *__fastcall sub_140023EF0(__m128i *a1, unsigned int a2);
__m128i *__fastcall sub_140024390(__m128i *a1, __int64 a2);
__m128i *__fastcall sub_140024840(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_1400248A0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024900(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
_BOOL8 __fastcall sub_140024960(__int64 a1, __int64 a2, __int64 a3);
__m128i *__fastcall sub_1400249B0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024A10(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024A70(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
_BOOL8 __fastcall sub_140024AD0(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__m128i *__fastcall sub_140024B20(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024B80(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024BE0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
_BOOL8 __fastcall sub_140024C40(__int64 a1, __int64 a2, __int64 a3);
__m128i *__fastcall sub_140024C90(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024CF0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
__m128i *__fastcall sub_140024D50(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4);
_BOOL8 __fastcall sub_140024DB0(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140024E00(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140024E30(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140024E60(__int64 a1, __int64 a2);
__int64 __fastcall sub_140024E90(__int64 a1);
__int64 __fastcall sub_140024EE0(__int64 a1);
__int64 __fastcall sub_140024F30(__int64 a1);
__int64 __fastcall sub_140024F80(__int64 a1);
__m128i __fastcall sub_140024FD0(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025010(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025050(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025090(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_1400250D0(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025110(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025150(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025190(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_1400251D0(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025210(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025250(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025290(const __m128i *a1, __m128i *a2);
__int64 __fastcall sub_1400252D0(const __m128i *a1);
__int64 __fastcall sub_1400252F0(const __m128i *a1);
__int64 __fastcall sub_140025310(const __m128i *a1);
unsigned __int64 __fastcall sub_140025330(const __m128i *a1);
__int64 __fastcall sub_140025350(const __m128i *a1, unsigned int a2);
__int64 __fastcall sub_1400253A0(const __m128i *a1, unsigned int a2);
__int64 __fastcall sub_140025400(const __m128i *a1, unsigned int a2);
__int64 __fastcall sub_140025460(const __m128i *a1, unsigned int a2);
__m128i __fastcall sub_1400254A0(const __m128i *a1);
__m128i __fastcall sub_1400254F0(const __m128i *a1);
__m128i __fastcall sub_140025540(const __m128i *a1);
__m128i __fastcall sub_140025590(const __m128i *a1);
__m128i __fastcall sub_1400255E0(const __m128i *a1);
__m128i __fastcall sub_140025630(const __m128i *a1);
__m128i __fastcall sub_140025680(const __m128i *a1);
__m128i __fastcall sub_1400256D0(const __m128i *a1);
__m128i __fastcall sub_140025720(const __m128i *a1);
__m128i __fastcall sub_140025770(const __m128i *a1);
__m128i __fastcall sub_1400257C0(const __m128i *a1);
__m128i __fastcall sub_140025810(const __m128i *a1);
__m128i __fastcall sub_140025860(const __m128i *a1);
__m128i __fastcall sub_1400258B0(const __m128i *a1);
__m128i __fastcall sub_140025900(const __m128i *a1);
__m128i __fastcall sub_140025950(const __m128i *a1);
__m128i __fastcall sub_1400259A0(const __m128i *a1);
__m128i __fastcall sub_1400259F0(const __m128i *a1);
__m128i __fastcall sub_140025A40(const __m128i *a1);
__m128i __fastcall sub_140025A90(const __m128i *a1);
__m128i __fastcall sub_140025AE0(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025B30(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025B80(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025BD0(const __m128i *a1, __m128i *a2, const __m128i *a3);
__m128i __fastcall sub_140025C30(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025C80(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025CD0(const __m128i *a1, __m128i *a2);
__m128i __fastcall sub_140025D20(const __m128i *a1, __m128i *a2, const __m128i *a3);
__int64 __fastcall sub_140025D80(char a1, double _XMM1_8);
__int64 __fastcall sub_140025DD0(__int16 a1);
__int64 __fastcall sub_140025E20(unsigned int a1);
void __fastcall sub_140025E70(__int64 a1);
__m128i __fastcall sub_140025EB0(char a1);
__m128i __fastcall sub_140025EF0(__int16 a1);
__m128i __fastcall sub_140025F30(unsigned int a1);
__m128i __fastcall sub_140025F60(__int64 a1);
__m128i __fastcall sub_140025F90(const __m128i *a1, unsigned __int8 a2);
__m128i __fastcall sub_140025FF0(const __m128i *a1, unsigned __int8 a2);
__m128i __fastcall sub_140026050(const __m128i *a1, unsigned __int8 a2);
__m128i __fastcall sub_1400260B0(const __m128i *a1, unsigned __int8 a2);
char sub_140026110();
char sub_140026130();
char sub_140026150();
_BOOL8 sub_140026170();
_BOOL8 sub_140026190();
char sub_1400261C0();
_BOOL8 sub_1400261D0();
__int64 __fastcall sub_140026200(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3);
__int64 __fastcall sub_140026240(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3);
__int64 __fastcall sub_140026280(__m128i *a1, _DWORD *a2, unsigned int a3);
__int64 __fastcall sub_1400262C0(__m128i *a1, _QWORD *a2, __int64 a3);
__m128i *__fastcall sub_140026300(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3);
__m128i *__fastcall sub_140026340(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3);
__m128i *__fastcall sub_140026380(__m128i *a1, _DWORD *a2, unsigned int a3);
__m128i *__fastcall sub_1400263C0(__m128i *a1, _QWORD *a2, __int64 a3);
__m128i *__fastcall sub_140026400(unsigned __int8 *a1, unsigned __int8 a2);
__m128i *__fastcall sub_140026430(unsigned __int16 *a1, __int16 a2);
__m128i *__fastcall sub_140026460(__m128i *a1, unsigned int a2);
__m128i *__fastcall sub_140026490(__m128i *a1, __int64 a2);
__int64 __fastcall sub_1400264C0(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140026500(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140026540(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140026580(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_1400265C0(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140026600(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140026640(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_140026680(const __m128i *a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_1400266C0(__int64 a1);
__int64 __fastcall sub_140026730(__int64 a1);
__int64 __fastcall sub_1400267A0(__int64 a1);
__int64 __fastcall sub_140026810(__int64 a1);
__int64 __fastcall sub_140026880(__int64 a1, const __m128i *a2, __m128i *a3);
__int64 __fastcall sub_140026B90(__int64 a1, const __m128i *a2, __m128i *a3);
__int64 __fastcall sub_140026EA0(__int64 a1, const __m128i *a2, __m128i *a3);
_QWORD *__fastcall sub_140027160(_QWORD *a1, __m128i *a2, __m128i *a3);
__int64 __fastcall sub_1400273F0(const __m128i *a1, const __m128i *a2);
__int64 __fastcall sub_140027810(const __m128i *a1, const __m128i *a2);
__int64 __fastcall sub_140027C30(const __m128i *a1, const __m128i *a2);
__int64 __fastcall sub_140027FD0(const __m128i *a1, const __m128i *a2);
__int64 __fastcall sub_140028330(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140028390(const __m128i *a1, __int64 a2, const __m128i *a3);
void *__fastcall sub_140028860(size_t a1);
__int64 __fastcall sub_1400288D0(__int64 a1);
// void __cdecl __noreturn _report_gsfailure(uintptr_t StackCookie);
__int64 __fastcall sub_140028E50(__int64 a1, unsigned __int64 a2, __int64 *a3);
__int64 __fastcall sub_140028EA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140028F50(__int64 a1, __int64 a2, __int64 a3);
void *sub_1400290B0();
void sub_1400290C0();
void *sub_140029110();
DWORD __fastcall sub_140029140(_BYTE *a1);
// __int64 __fastcall _GSHandlerCheck_EH(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// void __cdecl _security_check_cookie(uintptr_t StackCookie);
_QWORD *__fastcall sub_140029430(_QWORD *a1);
__int64 __fastcall sub_140029450(__int64 a1, char a2);
__int64 __fastcall sub_1400294A0(); // weak
__int64 __fastcall sub_140029580(); // weak
int sub_1400295A0();
__int64 sub_1400295C0();
__int64 sub_1400295E0();
errno_t sub_1400297F0();
int sub_140029810();
__int64 sub_140029830();
void sub_140029880();
int *sub_1400298A0();
errno_t sub_1400298D0();
__int64 __fastcall start_0(); // weak
__int64 __fastcall sub_140029910(); // weak
_QWORD *__fastcall sub_140029DA0(_QWORD *a1);
void __fastcall __noreturn sub_140029DF0(); // weak
void __fastcall __noreturn sub_140029E20(); // weak
__int64 __fastcall sub_140029E50(__int64 a1);
bool __fastcall sub_140029E80(int a1);
bool __fastcall sub_140029ED0(int a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140029F30(__int64 a1, __int64 a2, int a3);
void __fastcall sub_14002A150(__int64 a1, char *a2);
__int64 __fastcall sub_14002A260(unsigned __int8 *a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_14002A340(_BYTE *a1);
char __fastcall sub_14002A360(__int64 a1, unsigned int a2, int a3, const CHAR *a4);
void __fastcall sub_14002A660(ULONG_PTR *lpArguments);
void __fastcall sub_14002A690(char *Source);
void *sub_14002A790();
int __fastcall sub_14002A7A0(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList);
__int64 sub_14002A820(char *a1, size_t a2, char *a3, ...);
__int64 __fastcall sub_14002A850(); // weak
__int64 __fastcall sub_14002A860(); // weak
__int64 __fastcall sub_14002A910(__int64 a1, unsigned __int64 a2);
bool __fastcall sub_14002AA10(__int64 a1);
struct _TEB *sub_14002AAC0();
char sub_14002AAD0();
char sub_14002AB50();
bool sub_14002AB90();
char sub_14002ABC0();
char sub_14002AC00();
int __fastcall sub_14002AC20(__int64 a1, int a2, __int64 a3, void (__fastcall *a4)(__int64, _QWORD, __int64), unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);
void sub_14002ACA0();
__int64 __fastcall sub_14002ACE0(); // weak
char __fastcall sub_14002AD00(int a1);
char __fastcall sub_14002AD60(unsigned int a1);
bool __fastcall sub_14002AEB0(__int64 a1);
__int64 __fastcall sub_14002AF60(unsigned __int8 a1);
char __fastcall sub_14002AFA0(unsigned __int8 a1, char a2);
void (__cdecl *__fastcall sub_14002AFF0(void (__cdecl *a1)()))();
int __fastcall sub_14002B090(void (__cdecl *a1)());
__int64 __fastcall sub_14002B0F0(void (__cdecl *a1)());
unsigned __int64 sub_14002B130();
uintptr_t sub_14002B220();
__int64 __fastcall sub_14002B2C0(); // weak
__int64 __fastcall sub_14002B2D0(); // weak
__int64 __fastcall sub_14002B2E0(); // weak
__int64 __fastcall sub_14002B2F0(); // weak
__int64 __fastcall sub_14002B300(); // weak
__int64 __fastcall sub_14002B310(); // weak
void sub_14002B320();
__int64 __fastcall sub_14002B340(); // weak
char sub_14002B360();
void *sub_14002B390();
__int64 __fastcall sub_14002B3A0(); // weak
_BOOL8 sub_14002B400();
void *sub_14002B430();
void *sub_14002B440();
void sub_14002B450();
void __fastcall sub_14002B470(unsigned int a1);
__int64 __fastcall sub_14002B670(); // weak
__int64 __fastcall sub_14002B6E0(); // weak
__int64 __fastcall sub_14002B700(); // weak
bool sub_14002B710();
LPTOP_LEVEL_EXCEPTION_FILTER sub_14002B7E0();
__int64 __fastcall sub_14002B800(); // weak
__int64 __fastcall TopLevelExceptionFilter_0(_QWORD *a1);
void sub_14002B8D0();
void sub_14002B930();
void sub_14002B990();
__int64 __fastcall sub_14002B9A0(__int64 a1);
__int64 __fastcall sub_14002B9D0(__int64 a1);
_BOOL8 __fastcall sub_14002B9F0(__int64 a1);
_BOOL8 __fastcall sub_14002BA20(__int64 a1);
__int64 (__fastcall *__fastcall sub_14002BA60(__int64 a1))(_QWORD);
__int64 (__fastcall *__fastcall sub_14002BA90(__int64 a1))(_QWORD);
__int64 __fastcall sub_14002BAD0(__int64 a1);
__int64 __fastcall sub_14002BB00(__int64 a1);
_BOOL8 __fastcall sub_14002BB50(__int64 a1);
__int64 __fastcall sub_14002BBE0(__int64 a1);
_BOOL8 __fastcall sub_14002BC10(__int64 a1, __int64 a2, unsigned __int64 a3);
_BOOL8 __fastcall sub_14002BC60(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 (__fastcall *__fastcall sub_14002BCE0(__int64 a1, __int64 a2, unsigned __int64 a3))(_QWORD);
__int64 __fastcall sub_14002BD40(__int64 a1, __int64 a2, __int64 a3);
_BOOL8 __fastcall sub_14002BDA0(__int64 a1, __int64 a2, unsigned __int64 a3);
_BOOL8 sub_14002BE30();
__int64 __fastcall sub_14002BE90(_QWORD, _QWORD); // weak
__int64 sub_14002C050(void); // weak
_BOOL8 __fastcall sub_14002C3B0(const wchar_t *a1, wchar_t *a2, size_t a3);
__int64 __fastcall sub_14002C500(__int64 a1, _WORD *a2, int a3, int *a4, __int64 a5, unsigned int a6);
_BOOL8 sub_14002C9C0();
char sub_14002CBE0();
char sub_14002CBF0();
char sub_14002CC00();
char sub_14002CC10();
char sub_14002CC20();
__int64 __fastcall sub_14002CC30(); // weak
__int64 __fastcall sub_14002F590(__int64 a1, __int64 a2);
void *__fastcall sub_14002F5C0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14002F630(__int64 a1, __int64 a2);
void *__fastcall sub_14002F660(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14002F6D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002F700(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002F730(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002F780(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002F7D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002F800(__int64 a1, __int64 a2);
__int64 __fastcall sub_14002F830(__int64 a1, __int64 a2);
int __fastcall sub_14002F860(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_14002F8A0(_DWORD **a1);
__int64 __fastcall sub_14002F8D0(__int64 a1, __int64 a2);
// __int64 __fastcall std::istream::ignore(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::istream::_Ipfx(_QWORD, _QWORD); weak
// __int64 __fastcall std::ostream::flush(_QWORD); weak
// __int64 __fastcall std::ostream::put(_QWORD, _QWORD); weak
// __int64 __fastcall std::ostream::operator<<(_QWORD, _QWORD); weak
// __int64 __fastcall std::ostream::_Osfx(_QWORD); weak
// __int64 __fastcall std::ios::widen(_QWORD, _QWORD); weak
// __int64 __fastcall std::ios::fill(_QWORD); weak
// __int64 __fastcall std::ios::rdbuf(_QWORD); weak
// __int64 __fastcall std::ios::tie(_QWORD); weak
// __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD); weak
// __int64 __fastcall std::streambuf::snextc(_QWORD); weak
// __int64 __fastcall std::streambuf::sgetc(_QWORD); weak
// __int64 __fastcall std::streambuf::sbumpc(_QWORD); weak
// __int64 __fastcall std::ios_base::width(std::ios_base *__hidden this, __int64); weak
// __int64 std::ios_base::width(std::ios_base *__hidden this); weak
// _DWORD std::ios_base::flags(std::ios_base *__hidden this); weak
// bool std::ios_base::good(std::ios_base *__hidden this); weak
// void std::_Lockit::~_Lockit(std::_Lockit *__hidden this); weak
// _QWORD __fastcall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD); weak
// __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...); weak
// __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN j__CrtDbgReportW; // weak
_UNKNOWN loc_1400123E8; // weak
_UNKNOWN loc_140013805; // weak
const _PVFV qword_140031000 = NULL; // idb
const _PVFV qword_140031220 = NULL; // idb
const _PIFV First = NULL; // idb
const _PIFV Last = NULL; // idb
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
_UNKNOWN unk_140031C60; // weak
_UNKNOWN unk_140031CE0; // weak
_UNKNOWN unk_140031D60; // weak
_UNKNOWN unk_140031DE0; // weak
_UNKNOWN unk_140031F50; // weak
_UNKNOWN unk_1400320A0; // weak
_UNKNOWN unk_1400322D0; // weak
_UNKNOWN unk_1400323A0; // weak
_UNKNOWN unk_140032420; // weak
_UNKNOWN unk_140032530; // weak
void *std::exception::`vftable' = &sub_140011726; // weak
void *std::bad_alloc::`vftable' = &sub_140011447; // weak
void *std::bad_array_new_length::`vftable' = &sub_1400112A8; // weak
_UNKNOWN unk_14003278C; // weak
const char Str[1] = "E"; // idb
__m128i stru_140032D80[3] =
{
  {
    {
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      128
    }
  },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i stru_140032DB0[2] =
{
  { { 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128, 0, 128 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
unsigned __int16 word_140032DD8[12] = { 256u, 770u, 1284u, 1798u, 2312u, 2826u, 3340u, 3854u, 0u, 0u, 0u, 0u }; // weak
__m128i stru_140032DF0[3] =
{
  { { 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i stru_140032E20[3] =
{
  { { 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 128 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032E50[2] =
{
  { { 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032E70[2] =
{
  { { 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032E90[2] =
{
  { { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032EB0[2] =
{
  { { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032ED0[2] =
{
  { { 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032EF0[2] =
{
  { { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032F10[2] =
{
  { { 2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__m128i xmmword_140032F30[2] =
{
  { { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__int128 xmmword_140032F50 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi64; // weak
void *type_info::`vftable' = &sub_140011163; // weak
_DWORD dword_1400330A0[6] = { 1, 0, 1, 1, 1, 1 }; // weak
_UNKNOWN unk_140033E80; // weak
_UNKNOWN unk_140034080; // weak
_UNKNOWN unk_140034710; // weak
void (*qword_140034928[35])(void) =
{
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
_UNKNOWN unk_140034A40; // weak
void (*qword_140034C58[34])(void) =
{
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, 70827, 0, 224664 }; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, 70622, 0, 224848 }; // idb
int dword_140037000 = 145; // weak
__int64 qword_140037010 = -47936899621427i64; // weak
uintptr_t _security_cookie = 47936899621426ui64;
int dword_140037028 = 1; // weak
int dword_14003702C = 2; // weak
__int64 qword_140037030 = 524288i64; // weak
__int64 qword_140037038 = 33554432i64; // weak
int dword_140037050 = 1; // weak
int dword_140037054 = 1; // weak
int dword_140037058 = 1; // weak
int dword_140037064 = 1; // weak
int dword_140037070 = 1; // weak
char byte_140037AC6; // weak
int dword_140037AC8; // weak
_UNKNOWN unk_140037AD0; // weak
__int64 qword_140037AE0; // weak
__int64 qword_140037AE8; // weak
int dword_140037AF8; // weak
signed __int64 qword_140037B00; // weak
char byte_140037B08; // weak
char byte_140037B09; // weak
_onexit_table_t Table; // idb
_onexit_table_t stru_140037B28; // idb
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_140037B68; // weak
int dword_140037B74; // weak
__int64 qword_140037B78; // weak
__int64 qword_140037B88; // weak
char byte_140037B91; // weak
char byte_140037B92; // weak
_UNKNOWN unk_140037B98; // weak
_UNKNOWN unk_140037BB0; // weak
int dword_140037BC4; // weak
// extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord);
// extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD ProcessorFeature);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern void (__stdcall *RaiseException)(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern void (__stdcall *GetStartupInfoW)(LPSTARTUPINFOW lpStartupInfo);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern DWORD (__stdcall *GetLastError)();
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern _UNKNOWN std::cin; weak
// extern _UNKNOWN std::cout; weak
// extern int (__cdecl *isalnum)(int C);
// extern __time64_t (__cdecl *time64)(__time64_t *Time);
// extern errno_t (__cdecl *localtime64_s)(struct tm *Tm, const __time64_t *Time);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
_UNKNOWN unk_14003E009; // weak
_UNKNOWN unk_14003E033; // weak
_UNKNOWN unk_14003E038; // weak
_UNKNOWN unk_14003E03A; // weak
_UNKNOWN unk_14003E042; // weak
_UNKNOWN unk_14003E043; // weak
_UNKNOWN unk_14003E047; // weak
_UNKNOWN unk_14003E04A; // weak
_UNKNOWN unk_14003E04C; // weak
_UNKNOWN unk_14003E050; // weak
_UNKNOWN unk_14003E065; // weak
_UNKNOWN unk_14003E066; // weak
_UNKNOWN unk_14003E068; // weak
_UNKNOWN unk_14003E06A; // weak
void (*_guard_check_icall_fptr)() = &sub_140011055; // weak
__int64 (__fastcall *_castguard_check_failure_os_handled_fptr)(_QWORD) = NULL; // weak


//----- (0000000140011FC0) ----------------------------------------------------
__int64 __fastcall sub_140011FC0(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  sub_1400111C7(a1);
  sub_140011613(a1);
  return a1;
}
// 1400111C7: using guessed type __int64 __fastcall sub_1400111C7(_QWORD);
// 140011613: using guessed type __int64 __fastcall sub_140011613(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012030) ----------------------------------------------------
__int64 __fastcall sub_140012030(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012080) ----------------------------------------------------
__int64 __fastcall sub_140012080(__int64 a1, __int64 a2)
{
  char *v2; // rdi
  __int64 i; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rdi
  char v11[32]; // [rsp+0h] [rbp-20h] BYREF
  char v12; // [rsp+20h] [rbp+0h] BYREF
  unsigned int v13; // [rsp+24h] [rbp+4h]
  __int64 v14; // [rsp+48h] [rbp+28h]
  __int64 v15; // [rsp+68h] [rbp+48h]
  char v16[236]; // [rsp+88h] [rbp+68h] BYREF
  int v17[8]; // [rsp+174h] [rbp+154h] BYREF
  int v18[8]; // [rsp+194h] [rbp+174h] BYREF
  int v19[8]; // [rsp+1B4h] [rbp+194h] BYREF
  int v20[9]; // [rsp+1D4h] [rbp+1B4h] BYREF
  __int64 v21; // [rsp+1F8h] [rbp+1D8h]
  unsigned __int8 v22; // [rsp+204h] [rbp+1E4h]
  __int64 v23; // [rsp+208h] [rbp+1E8h]

  v2 = &v12;
  for ( i = 82i64; i; --i )
  {
    *(_DWORD *)v2 = -858993460;
    v2 += 4;
  }
  sub_140011721(&unk_14003E065);
  v13 = 0;
  v14 = sub_14001124E(a2);
  if ( std::ios_base::width((std::ios_base *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1)) <= 0
    || (v4 = std::ios_base::width((std::ios_base *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1)), v4 <= v14) )
  {
    v23 = 0i64;
  }
  else
  {
    v5 = std::ios_base::width((std::ios_base *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1));
    v23 = v5 - v14;
  }
  v15 = v23;
  sub_140011168(v16, a1);
  if ( (unsigned __int8)sub_140011424(v16) )
  {
    if ( (std::ios_base::flags((std::ios_base *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1)) & 0x1C0) != 64 )
    {
      while ( v15 > 0 )
      {
        v22 = std::ios::fill(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
        v6 = std::ios::rdbuf(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
        LODWORD(v23) = std::streambuf::sputc(v6, v22);
        v17[0] = v23;
        v18[0] = sub_140011208();
        if ( (unsigned __int8)sub_140011618(v18, v17) )
        {
          v13 |= 4u;
          break;
        }
        --v15;
      }
    }
    if ( !v13 )
    {
      v7 = std::ios::rdbuf(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
      v23 = std::streambuf::sputn(v7, a2, v14);
      if ( v23 != v14 )
        v13 |= 4u;
    }
    if ( !v13 )
    {
      while ( v15 > 0 )
      {
        v22 = std::ios::fill(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
        v8 = std::ios::rdbuf(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
        LODWORD(v23) = std::streambuf::sputc(v8, v22);
        v19[0] = v23;
        v20[0] = sub_140011208();
        if ( (unsigned __int8)sub_140011618(v20, v19) )
        {
          v13 |= 4u;
          break;
        }
        --v15;
      }
    }
    std::ios_base::width((std::ios_base *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1), 0i64);
  }
  else
  {
    v13 |= 4u;
  }
  std::ios::setstate(*(int *)(*(_QWORD *)a1 + 4i64) + a1, v13, 0i64);
  v21 = a1;
  sub_140011429(v16);
  v9 = v21;
  sub_1400115FA(v11, &unk_1400323A0);
  return v9;
}
// 140011168: using guessed type __int64 __fastcall sub_140011168(_QWORD, _QWORD);
// 140011208: using guessed type __int64 sub_140011208(void);
// 14001124E: using guessed type __int64 __fastcall sub_14001124E(_QWORD);
// 140011424: using guessed type __int64 __fastcall sub_140011424(_QWORD);
// 140011429: using guessed type __int64 __fastcall sub_140011429(_QWORD);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011618: using guessed type __int64 __fastcall sub_140011618(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C190: using guessed type __int64 __fastcall std::ios::fill(_QWORD);
// 14003C198: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);
// 14003C1A8: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 14003C1B0: using guessed type __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD);
// 14003C1B8: using guessed type __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD);
// 14003C1D8: using guessed type __int64 __fastcall std::ios_base::width(std::ios_base *__hidden this, __int64);
// 14003C1E0: using guessed type __int64 std::ios_base::width(std::ios_base *__hidden this);
// 14003C1E8: using guessed type _DWORD std::ios_base::flags(std::ios_base *__hidden this);
// 140012080: using guessed type int var_BC[8];
// 140012080: using guessed type int var_9C[8];
// 140012080: using guessed type int var_7C[8];
// 140012080: using guessed type int var_5C[9];
// 140012080: using guessed type char var_230[32];

//----- (0000000140012560) ----------------------------------------------------
__int64 __fastcall sub_140012560(_QWORD *a1, _QWORD *a2)
{
  sub_140011721(&unk_14003E03A);
  return sub_140011384(*a1, *a2);
}
// 140011384: using guessed type __int64 __fastcall sub_140011384(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400125C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400125C0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *result; // rax
  _QWORD *v4; // [rsp+28h] [rbp+8h]
  __int64 v5[5]; // [rsp+108h] [rbp+E8h] BYREF

  sub_140011721(&unk_14003E04A);
  v2 = sub_140011217(a2, 1i64);
  v4 = (_QWORD *)sub_14001168B(v2);
  v5[0] = (__int64)a1;
  sub_1400111DB(v4, v5);
  *a1 = v4;
  result = v4;
  *v4 = a1;
  return result;
}
// 1400111DB: using guessed type __int64 __fastcall sub_1400111DB(_QWORD, _QWORD);
// 140011217: using guessed type __int64 __fastcall sub_140011217(_QWORD, _QWORD);
// 14001168B: using guessed type __int64 __fastcall sub_14001168B(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400125C0: using guessed type __int64 var_28[5];

//----- (0000000140012670) ----------------------------------------------------
__int64 __fastcall sub_140012670(unsigned __int64 a1)
{
  sub_140011721(&unk_14003E04A);
  if ( a1 >= 0x1000 )
    return sub_140011488(a1);
  if ( a1 )
    return sub_140011708(a1);
  return 0i64;
}
// 140011488: using guessed type __int64 __fastcall sub_140011488(_QWORD);
// 140011708: using guessed type __int64 __fastcall sub_140011708(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400126F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400126F0(unsigned __int64 a1)
{
  __int64 v2; // [rsp+58h] [rbp+28h]

  sub_140011721(&unk_14003E04A);
  if ( a1 + 47 <= a1 )
    sub_1400115DC();
  v2 = sub_140011708(a1 + 47);
  if ( !v2 )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
                         135i64,
                         0i64,
                         "%s",
                         "invalid argument") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"invalid argument\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
      135i64,
      0i64);
  }
  *(_QWORD *)(((v2 + 47) & 0xFFFFFFFFFFFFFFE0ui64) - 8) = v2;
  *(_QWORD *)(((v2 + 47) & 0xFFFFFFFFFFFFFFE0ui64) - 16) = 0xFAFAFAFAFAFAFAFAui64;
  return (v2 + 47) & 0xFFFFFFFFFFFFFFE0ui64;
}
// 1400115DC: using guessed type void __noreturn sub_1400115DC(void);
// 140011708: using guessed type __int64 __fastcall sub_140011708(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400326A0: using guessed type wchar_t aCProgramFilesM_0[98];
// 140032790: using guessed type wchar_t aInvalidArgumen_0[19];
// 14003C498: using guessed type __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 14003C4A0: using guessed type __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140012850) ----------------------------------------------------
_QWORD *__fastcall sub_140012850(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  _QWORD *result; // rax

  sub_140011721(&unk_14003E03A);
  v2 = sub_14001162C(a1);
  v3 = sub_140011686(v2);
  result = (_QWORD *)sub_1400115E6(8i64, v3);
  *result = *a2;
  return result;
}
// 1400115E6: using guessed type __int64 __fastcall sub_1400115E6(_QWORD, _QWORD);
// 14001162C: using guessed type __int64 __fastcall sub_14001162C(_QWORD);
// 140011686: using guessed type __int64 __fastcall sub_140011686(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400128E0) ----------------------------------------------------
__int64 __fastcall sub_1400128E0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax

  sub_140011721(&unk_14003E03A);
  v2 = sub_140011136(a1);
  v3 = sub_140011131(v2);
  v4 = sub_1400115E6(16i64, v3);
  return sub_1400110BE(v4, *a2);
}
// 1400110BE: using guessed type __int64 __fastcall sub_1400110BE(_QWORD, _QWORD);
// 140011131: using guessed type __int64 __fastcall sub_140011131(_QWORD);
// 140011136: using guessed type __int64 __fastcall sub_140011136(_QWORD);
// 1400115E6: using guessed type __int64 __fastcall sub_1400115E6(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012970) ----------------------------------------------------
_BOOL8 __fastcall sub_140012970(unsigned __int8 *a1)
{
  sub_140011721(&unk_14003E03A);
  return *a1 <= 0x7Fu;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400129F0) ----------------------------------------------------
__int64 __fastcall sub_1400129F0(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // [rsp+100h] [rbp+E0h] BYREF
  unsigned __int64 v4; // [rsp+108h] [rbp+E8h] BYREF

  v4 = a2;
  v3 = a1;
  sub_140011721(&unk_14003E04A);
  if ( v4 >= 0x1000 )
    sub_1400111AE(&v3, &v4);
  return sub_1400115EB(v3, v4);
}
// 1400111AE: using guessed type __int64 __fastcall sub_1400111AE(_QWORD, _QWORD);
// 1400115EB: using guessed type __int64 __fastcall sub_1400115EB(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012A70) ----------------------------------------------------
__int64 __fastcall sub_140012A70(__int64 a1, __int64 a2)
{
  sub_140011721(&unk_14003E04A);
  return sub_14001132A(a1, a2, 1i64);
}
// 14001132A: using guessed type __int64 __fastcall sub_14001132A(_QWORD, _QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012AD0) ----------------------------------------------------
__int64 __fastcall sub_140012AD0(__int64 a1, __int64 a2)
{
  sub_140011721(&unk_14003E04A);
  return sub_14001164F(a1, a2);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012B30) ----------------------------------------------------
__int64 sub_140012B30()
{
  return sub_140011721(&unk_14003E04A);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140012B30: using guessed type __int64 __fastcall sub_140012B30();

//----- (0000000140012B70) ----------------------------------------------------
__int64 __fastcall sub_140012B70(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 v4; // rax
  __int64 v5; // [rsp+28h] [rbp+8h]
  __int64 v6; // [rsp+140h] [rbp+120h] BYREF
  __int64 v7; // [rsp+148h] [rbp+128h] BYREF
  unsigned __int8 *v8; // [rsp+150h] [rbp+130h]

  v8 = a3;
  v7 = a2;
  v6 = a1;
  sub_140011721(&unk_14003E03A);
  if ( !sub_1400114E7(v8) )
    return v7;
  v5 = sub_14001178A(&v6);
  v4 = sub_14001178A(&v7);
  return sub_14001128F(v5, v4, *v8);
}
// 14001128F: using guessed type __int64 __fastcall sub_14001128F(_QWORD, _QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14001178A: using guessed type __int64 __fastcall sub_14001178A(_QWORD);

//----- (0000000140012C80) ----------------------------------------------------
__int64 __fastcall sub_140012C80(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012CD0) ----------------------------------------------------
__int64 __fastcall sub_140012CD0(unsigned __int64 a1)
{
  sub_140011721(&unk_14003E04A);
  if ( a1 > 0xFFFFFFFFFFFFFFFi64 )
    sub_1400115DC();
  return 16 * a1;
}
// 1400115DC: using guessed type void __noreturn sub_1400115DC(void);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012D50) ----------------------------------------------------
__int64 __fastcall sub_140012D50(__int64 a1)
{
  sub_140011721(&unk_14003E03A);
  return *(_QWORD *)a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012D90) ----------------------------------------------------
__int64 __fastcall sub_140012D90(__int64 a1)
{
  sub_140011721(&unk_14003E03A);
  return *(_QWORD *)a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140012DD0) ----------------------------------------------------
_QWORD *__fastcall sub_140012DD0(_QWORD *a1, unsigned __int64 a2, char a3, char a4)
{
  char *v4; // rdi
  __int64 i; // rcx
  __int64 v6; // rax
  __int64 v7; // rax
  int v8; // eax
  char v10[32]; // [rsp+0h] [rbp-30h] BYREF
  char v11; // [rsp+30h] [rbp+0h] BYREF
  _QWORD *v12; // [rsp+38h] [rbp+8h]
  __int64 v13; // [rsp+58h] [rbp+28h]
  __int64 v14; // [rsp+78h] [rbp+48h]
  unsigned __int64 v15; // [rsp+98h] [rbp+68h]
  __int64 v16; // [rsp+B8h] [rbp+88h]
  __int64 v17; // [rsp+D8h] [rbp+A8h]
  __int64 v18[4]; // [rsp+F8h] [rbp+C8h] BYREF
  __int64 v19; // [rsp+118h] [rbp+E8h]
  __int64 v20; // [rsp+138h] [rbp+108h]
  __int64 v21; // [rsp+208h] [rbp+1D8h]
  char v24; // [rsp+250h] [rbp+220h] BYREF
  char v25; // [rsp+258h] [rbp+228h]

  v25 = a4;
  v24 = a3;
  v4 = &v11;
  for ( i = 78i64; i; --i )
  {
    *(_DWORD *)v4 = -858993460;
    v4 += 4;
  }
  sub_140011721(&unk_14003E04C);
  v12 = a1;
  v13 = a1[3];
  v6 = sub_1400112B7(a1);
  if ( v6 - v13 < a2 )
    sub_1400113B1();
  v14 = a2 + v13;
  v15 = v12[4];
  v16 = sub_140011735(a1, a2 + v13);
  v17 = sub_140011226(a1);
  v18[0] = sub_140011690(v17, v16 + 1);
  v21 = v16 + 1;
  v7 = sub_140011730(v18[0]);
  sub_140011285(v7, v21);
  sub_1400116BD((__int64)v12);
  v12[3] = v14;
  v12[4] = v16;
  v19 = sub_140011730(v18[0]);
  if ( v15 < 0x10 )
  {
    sub_140011604((unsigned int)&v24, v19, (_DWORD)v12 + 8, v13, v25);
    sub_1400116B3((__int64)(v12 + 1), v18);
  }
  else
  {
    v20 = v12[1];
    v8 = sub_140011730(v20);
    sub_140011604((unsigned int)&v24, v19, v8, v13, v25);
    sub_14001157D(v17, v20, v15 + 1);
    v12[1] = v18[0];
  }
  sub_1400115FA(v10, &unk_140032420);
  return a1;
}
// 140011226: using guessed type __int64 __fastcall sub_140011226(_QWORD);
// 140011285: using guessed type __int64 __fastcall sub_140011285(_QWORD, _QWORD);
// 1400112B7: using guessed type __int64 __fastcall sub_1400112B7(_QWORD);
// 1400113B1: using guessed type void __noreturn sub_1400113B1(void);
// 14001157D: using guessed type __int64 __fastcall sub_14001157D(_QWORD, _QWORD, _QWORD);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011604: using guessed type __int64 __fastcall sub_140011604(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 140011690: using guessed type __int64 __fastcall sub_140011690(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140011730: using guessed type __int64 __fastcall sub_140011730(_QWORD);
// 140011735: using guessed type __int64 __fastcall sub_140011735(_QWORD, _QWORD);
// 140012DD0: using guessed type __int64 var_138[4];
// 140012DD0: using guessed type char var_230[32];

//----- (00000001400130B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400130B0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  sub_140011721(&unk_14003E03A);
  result = a1;
  *a1 = *a2;
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013110) ----------------------------------------------------
__int64 __fastcall sub_140013110(__int64 a1)
{
  sub_140011721(&unk_14003E03A);
  return *(_QWORD *)a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013150) ----------------------------------------------------
__int64 __fastcall sub_140013150(__int64 a1)
{
  sub_140011721(&unk_14003E033);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013190) ----------------------------------------------------
__int64 __fastcall sub_140013190(__int64 a1)
{
  sub_140011721(&unk_14003E033);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400131D0) ----------------------------------------------------
__int64 __fastcall sub_1400131D0(unsigned __int64 a1, unsigned __int64 a2)
{
  sub_140011721(&unk_14003E03A);
  if ( a1 > a2 )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility",
                         936i64,
                         0i64,
                         "%s",
                         "transposed pointer range") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"transposed pointer range\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility",
      936i64,
      0i64);
  }
  return 0i64;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140032C50: using guessed type wchar_t aCProgramFilesM_2[99];
// 140032D40: using guessed type wchar_t aTransposedPoin_0[27];
// 14003C498: using guessed type __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 14003C4A0: using guessed type __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400132C0) ----------------------------------------------------
__int64 __fastcall sub_1400132C0(__int64 a1)
{
  sub_140011721(&unk_14003E03A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013300) ----------------------------------------------------
__int64 __fastcall sub_140013300(__int64 a1)
{
  sub_140011721(&unk_14003E03A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013340) ----------------------------------------------------
__int64 __fastcall sub_140013340(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  sub_140011721(&unk_14003E03A);
  return sub_140011406(a1, a2, a3);
}
// 140011406: using guessed type __int64 __fastcall sub_140011406(_QWORD, _QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400133B0) ----------------------------------------------------
__int64 __fastcall sub_1400133B0(__int64 a1)
{
  sub_140011721(&unk_14003E033);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400133F0) ----------------------------------------------------
__int64 __fastcall sub_1400133F0(__int64 a1)
{
  sub_140011721(&unk_14003E033);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013430) ----------------------------------------------------
__int64 __fastcall sub_140013430(__int64 a1)
{
  __int64 v1; // rdx
  unsigned __int8 v2; // al

  sub_140011721(&unk_14003E065);
  LOBYTE(v1) = 10;
  v2 = std::ios::widen(*(int *)(*(_QWORD *)a1 + 4i64) + a1, v1);
  std::ostream::put(a1, v2);
  std::ostream::flush(a1);
  return a1;
}
// 14001346F: variable 'v1' is possibly undefined
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C168: using guessed type __int64 __fastcall std::ostream::flush(_QWORD);
// 14003C170: using guessed type __int64 __fastcall std::ostream::put(_QWORD, _QWORD);
// 14003C188: using guessed type __int64 __fastcall std::ios::widen(_QWORD, _QWORD);

//----- (00000001400134C0) ----------------------------------------------------
__int64 __fastcall sub_1400134C0(__int64 *a1, __int64 *a2)
{
  __int64 v3; // [rsp+28h] [rbp+8h]

  sub_140011721(&unk_14003E038);
  v3 = *a1;
  *a1 = *a2;
  return v3;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013530) ----------------------------------------------------
__int64 __fastcall sub_140013530(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 v3; // rax
  __int64 v5; // [rsp+E8h] [rbp+C8h] BYREF
  __int64 v6; // [rsp+F8h] [rbp+D8h]
  __int64 v7; // [rsp+120h] [rbp+100h] BYREF
  __int64 v8; // [rsp+128h] [rbp+108h] BYREF
  unsigned __int8 *v9; // [rsp+130h] [rbp+110h]

  v9 = a3;
  v8 = a2;
  v7 = a1;
  sub_140011721(&unk_14003E03A);
  sub_140011744(&v7, &v8);
  v6 = sub_1400110AA((__int64)&v8);
  v3 = sub_140011528((__int64)&v7);
  v5 = sub_1400112C1(v3, v6, v9);
  sub_140011221(&v7, &v5);
  return v7;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013600) ----------------------------------------------------
__int64 __fastcall sub_140013600(__int64 a1, __int64 a2, char a3)
{
  char *v3; // rdi
  __int64 i; // rcx
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int8 v10; // al
  __int64 v11; // rdi
  char v13[32]; // [rsp+0h] [rbp-20h] BYREF
  char v14; // [rsp+20h] [rbp+0h] BYREF
  unsigned int v15; // [rsp+24h] [rbp+4h]
  char v16; // [rsp+44h] [rbp+24h]
  char v17[44]; // [rsp+68h] [rbp+48h] BYREF
  int v18[8]; // [rsp+94h] [rbp+74h] BYREF
  int v19[56]; // [rsp+B4h] [rbp+94h] BYREF
  int v20[9]; // [rsp+194h] [rbp+174h] BYREF
  __int64 v21; // [rsp+1B8h] [rbp+198h]
  int v22; // [rsp+1C4h] [rbp+1A4h]
  unsigned __int64 v23; // [rsp+1C8h] [rbp+1A8h]
  char v26; // [rsp+210h] [rbp+1F0h] BYREF

  v26 = a3;
  v3 = &v14;
  for ( i = 66i64; i; --i )
  {
    *(_DWORD *)v3 = -858993460;
    v3 += 4;
  }
  sub_140011721(&unk_14003E068);
  v15 = 0;
  v16 = 0;
  LOBYTE(v5) = 1;
  sub_14001119A(v17, a1, v5);
  if ( (unsigned __int8)sub_14001131B(v17) )
  {
    sub_1400116EA(a2, 0i64);
    v18[0] = sub_1400116D1(&v26);
    v6 = std::ios::rdbuf(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
    v22 = std::streambuf::sgetc(v6);
    for ( v19[0] = v22; ; v19[0] = v22 )
    {
      v20[0] = sub_140011208();
      if ( (unsigned __int8)sub_140011618(v20, v19) )
      {
        v15 |= 1u;
        goto LABEL_13;
      }
      if ( (unsigned __int8)sub_140011618(v19, v18) )
      {
        v16 = 1;
        v8 = std::ios::rdbuf(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
        std::streambuf::sbumpc(v8);
        goto LABEL_13;
      }
      v23 = sub_14001155A(a2);
      v9 = sub_1400112B7(a2);
      if ( v9 <= v23 )
        break;
      v10 = sub_1400112C6(v19);
      sub_1400113CA(a2, v10);
      v16 = 1;
      v7 = std::ios::rdbuf(*(int *)(*(_QWORD *)a1 + 4i64) + a1);
      v22 = std::streambuf::snextc(v7);
    }
    v15 |= 2u;
  }
LABEL_13:
  if ( !v16 )
    v15 |= 2u;
  std::ios::setstate(*(int *)(*(_QWORD *)a1 + 4i64) + a1, v15, 0i64);
  v21 = a1;
  sub_14001169F(v17);
  v11 = v21;
  sub_1400115FA(v13, &unk_140032530);
  return v11;
}
// 14001366C: variable 'v5' is possibly undefined
// 14001119A: using guessed type __int64 __fastcall sub_14001119A(_QWORD, _QWORD, _QWORD);
// 140011208: using guessed type __int64 sub_140011208(void);
// 1400112B7: using guessed type __int64 __fastcall sub_1400112B7(_QWORD);
// 1400112C6: using guessed type __int64 __fastcall sub_1400112C6(_QWORD);
// 14001131B: using guessed type __int64 __fastcall sub_14001131B(_QWORD);
// 1400113CA: using guessed type __int64 __fastcall sub_1400113CA(_QWORD, _QWORD);
// 14001155A: using guessed type __int64 __fastcall sub_14001155A(_QWORD);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011618: using guessed type __int64 __fastcall sub_140011618(_QWORD, _QWORD);
// 14001169F: using guessed type __int64 __fastcall sub_14001169F(_QWORD);
// 1400116D1: using guessed type __int64 __fastcall sub_1400116D1(_QWORD);
// 1400116EA: using guessed type __int64 __fastcall sub_1400116EA(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C198: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);
// 14003C1A8: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 14003C1C0: using guessed type __int64 __fastcall std::streambuf::snextc(_QWORD);
// 14003C1C8: using guessed type __int64 __fastcall std::streambuf::sgetc(_QWORD);
// 14003C1D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);
// 140013600: using guessed type int var_15C[8];
// 140013600: using guessed type int var_5C[9];
// 140013600: using guessed type char var_1F0[32];

//----- (0000000140013930) ----------------------------------------------------
__int64 __fastcall sub_140013930(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  char v3; // al

  sub_140011721(&unk_14003E068);
  LOBYTE(v2) = 10;
  v3 = std::ios::widen(*(int *)(*(_QWORD *)a1 + 4i64) + a1, v2);
  return sub_14001176C(a1, a2, v3);
}
// 140013974: variable 'v2' is possibly undefined
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C188: using guessed type __int64 __fastcall std::ios::widen(_QWORD, _QWORD);

//----- (00000001400139C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400139C0(_QWORD *a1, _QWORD *a2)
{
  sub_140011721(&unk_14003E038);
  if ( *a1 >= *a2 )
    return a1;
  else
    return a2;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013A60) ----------------------------------------------------
_QWORD *__fastcall sub_140013A60(_QWORD *a1, _QWORD *a2)
{
  sub_140011721(&unk_14003E038);
  if ( *a2 >= *a1 )
    return a1;
  else
    return a2;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013B00) ----------------------------------------------------
__int64 __fastcall sub_140013B00(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  sub_1400112AD(a1);
  sub_140011311(a1 + 8);
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  return a1;
}
// 1400112AD: using guessed type __int64 __fastcall sub_1400112AD(_QWORD);
// 140011311: using guessed type __int64 __fastcall sub_140011311(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013B90) ----------------------------------------------------
__int64 __fastcall sub_140013B90(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013BD0) ----------------------------------------------------
_QWORD *__fastcall sub_140013BD0(_QWORD *a1)
{
  __int64 v1; // rax
  char v3[44]; // [rsp+104h] [rbp+E4h] BYREF

  sub_140011721(&unk_14003E04C);
  sub_14001150F((__int64)a1);
  sub_140011226(a1);
  v1 = sub_140011465((__int64)v3);
  sub_14001141A(a1, v1);
  sub_1400110D7(a1);
  return a1;
}
// 1400110D7: using guessed type __int64 __fastcall sub_1400110D7(_QWORD);
// 140011226: using guessed type __int64 __fastcall sub_140011226(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140013BD0: using guessed type char var_2C[44];

//----- (0000000140013C70) ----------------------------------------------------
void *__fastcall sub_140013C70(void *a1)
{
  sub_140011721(&unk_14003E04C);
  memset(a1, 0, 0x10ui64);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013CD0) ----------------------------------------------------
_QWORD *__fastcall sub_140013CD0(_QWORD *a1)
{
  sub_140011721(&unk_14003E04A);
  *a1 = 0i64;
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013D20) ----------------------------------------------------
_QWORD *__fastcall sub_140013D20(_QWORD *a1, __int64 a2)
{
  sub_140011721(&unk_14003E04A);
  *a1 = a2;
  a1[1] = 0i64;
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140013D90) ----------------------------------------------------
__int64 __fastcall sub_140013D90(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+28h] [rbp+8h]

  sub_140011721(&unk_14003E066);
  *(_QWORD *)a1 = a2;
  v3 = std::ios::rdbuf(*(int *)(**(_QWORD **)a1 + 4i64) + *(_QWORD *)a1);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C198: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);

//----- (0000000140013E50) ----------------------------------------------------
__int64 __fastcall sub_140013E50(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+28h] [rbp+8h]

  sub_140011721(&unk_14003E065);
  *(_QWORD *)a1 = a2;
  v3 = std::ios::rdbuf(*(int *)(**(_QWORD **)a1 + 4i64) + *(_QWORD *)a1);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C198: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);

//----- (0000000140013F10) ----------------------------------------------------
_QWORD *__fastcall sub_140013F10(_QWORD *a1, __int64 a2)
{
  sub_140011721(&unk_14003E042);
  sub_14001150A(a1, a2, 1i64);
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 14001150A: using guessed type __int64 __fastcall sub_14001150A(_QWORD, _QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400325B0: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140013F90) ----------------------------------------------------
_QWORD *__fastcall sub_140013F90(_QWORD *a1, __int64 a2)
{
  sub_1400116DB(a1, a2);
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 1400116DB: using guessed type __int64 __fastcall sub_1400116DB(_QWORD, _QWORD);
// 1400325B0: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140013FF0) ----------------------------------------------------
_QWORD *__fastcall sub_140013FF0(_QWORD *a1, __int64 a2)
{
  sub_140011113(a1, a2);
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 1400325D0: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0000000140014050) ----------------------------------------------------
_QWORD *__fastcall sub_140014050(_QWORD *a1)
{
  sub_140011721(&unk_14003E042);
  sub_140011181(a1, (__int64)"bad array new length");
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400325D0: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00000001400140C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400140C0(_QWORD *a1, __int64 a2)
{
  sub_140011721(&unk_14003E042);
  *a1 = &std::exception::`vftable';
  memset(a1 + 1, 0, 0x10ui64);
  j___std_exception_copy(a2 + 8, a1 + 1);
  return a1;
}
// 14001126C: using guessed type __int64 __fastcall j___std_exception_copy(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140032578: using guessed type void *std::exception::`vftable';

//----- (0000000140014160) ----------------------------------------------------
_QWORD *__fastcall sub_140014160(_QWORD *a1, __int64 a2)
{
  sub_140011721(&unk_14003E042);
  *a1 = &std::exception::`vftable';
  memset(a1 + 1, 0, 0x10ui64);
  a1[1] = a2;
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140032578: using guessed type void *std::exception::`vftable';

//----- (0000000140014200) ----------------------------------------------------
__int64 __fastcall sub_140014200(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  sub_140011721(&unk_14003E066);
  sub_14001110E(a1, a2);
  *(_BYTE *)(a1 + 8) = std::istream::_Ipfx(*(_QWORD *)a1, a3);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C160: using guessed type __int64 __fastcall std::istream::_Ipfx(_QWORD, _QWORD);

//----- (0000000140014290) ----------------------------------------------------
__int64 __fastcall sub_140014290(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+28h] [rbp+8h]

  sub_140011721(&unk_14003E065);
  sub_14001166D(a1, a2);
  if ( std::ios_base::good((std::ios_base *)(*(int *)(*(_QWORD *)a2 + 4i64) + a2)) )
  {
    v3 = std::ios::tie(*(int *)(*(_QWORD *)a2 + 4i64) + a2);
    if ( v3 && v3 != a2 )
    {
      std::ostream::flush(v3);
      *(_BYTE *)(a1 + 8) = std::ios_base::good((std::ios_base *)(*(int *)(*(_QWORD *)a2 + 4i64) + a2));
    }
    else
    {
      *(_BYTE *)(a1 + 8) = 1;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 8) = 0;
  }
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C168: using guessed type __int64 __fastcall std::ostream::flush(_QWORD);
// 14003C1A0: using guessed type __int64 __fastcall std::ios::tie(_QWORD);
// 14003C1F0: using guessed type bool std::ios_base::good(std::ios_base *__hidden this);

//----- (00000001400143E0) ----------------------------------------------------
__int64 __fastcall sub_1400143E0(__int64 a1)
{
  return sub_140011302(a1);
}
// 140011302: using guessed type __int64 __fastcall sub_140011302(_QWORD);

//----- (0000000140014420) ----------------------------------------------------
__int64 __fastcall sub_140014420(__int64 a1)
{
  return sub_140011442(a1 + 8);
}
// 140011442: using guessed type __int64 __fastcall sub_140011442(_QWORD);

//----- (0000000140014460) ----------------------------------------------------
__int64 __fastcall sub_140014460(__int64 *a1)
{
  char *v1; // rdi
  __int64 i; // rcx
  char v4[32]; // [rsp+0h] [rbp-20h] BYREF
  char v5; // [rsp+20h] [rbp+0h] BYREF
  char *v6; // [rsp+28h] [rbp+8h]
  char v7[36]; // [rsp+44h] [rbp+24h] BYREF
  __int64 v8; // [rsp+68h] [rbp+48h]

  v1 = &v5;
  for ( i = 26i64; i; --i )
  {
    *(_DWORD *)v1 = -858993460;
    v1 += 4;
  }
  sub_140011721(&unk_14003E04C);
  sub_1400113A2(a1);
  sub_140011226(a1);
  sub_140011465((__int64)v7);
  v6 = v7;
  v8 = *a1;
  *a1 = 0i64;
  sub_14001148D((__int64)v6, v8);
  sub_1400116EF((__int64)a1);
  return sub_1400115FA(v4, &unk_140031CE0);
}
// 140011226: using guessed type __int64 __fastcall sub_140011226(_QWORD);
// 1400113A2: using guessed type __int64 __fastcall sub_1400113A2(_QWORD);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140014460: using guessed type char var_150[32];

//----- (0000000140014570) ----------------------------------------------------
__int64 sub_140014570()
{
  return sub_140011721(&unk_14003E04C);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140014570: using guessed type __int64 __fastcall sub_140014570();

//----- (00000001400145B0) ----------------------------------------------------
__int64 __fastcall sub_1400145B0(__int64 a1)
{
  __int64 result; // rax

  sub_140011721(&unk_14003E066);
  result = std::ios::rdbuf(*(int *)(**(_QWORD **)a1 + 4i64) + *(_QWORD *)a1);
  if ( result )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 16i64))(result);
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C198: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);

//----- (0000000140014650) ----------------------------------------------------
__int64 __fastcall sub_140014650(__int64 a1)
{
  __int64 result; // rax

  sub_140011721(&unk_14003E065);
  result = std::ios::rdbuf(*(int *)(**(_QWORD **)a1 + 4i64) + *(_QWORD *)a1);
  if ( result )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 16i64))(result);
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C198: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);

//----- (00000001400146F0) ----------------------------------------------------
__int64 __fastcall sub_1400146F0(__int64 a1)
{
  return sub_1400111B8(a1);
}
// 1400111B8: using guessed type __int64 __fastcall sub_1400111B8(_QWORD);

//----- (0000000140014730) ----------------------------------------------------
__int64 __fastcall sub_140014730(__int64 a1)
{
  return sub_1400113DE(a1);
}

//----- (0000000140014770) ----------------------------------------------------
__int64 __fastcall sub_140014770(_QWORD *a1)
{
  sub_140011721(&unk_14003E042);
  *a1 = &std::exception::`vftable';
  return j___std_exception_destroy(a1 + 1);
}
// 1400113E3: using guessed type __int64 __fastcall j___std_exception_destroy(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140032578: using guessed type void *std::exception::`vftable';

//----- (00000001400147D0) ----------------------------------------------------
__int64 __fastcall sub_1400147D0(__int64 a1)
{
  return sub_140011127(a1);
}

//----- (0000000140014810) ----------------------------------------------------
__int64 __fastcall sub_140014810(_QWORD *a1)
{
  sub_140011721(&unk_14003E065);
  if ( !std::uncaught_exception() )
    std::ostream::_Osfx(*a1);
  return sub_14001130C((__int64)a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C180: using guessed type __int64 __fastcall std::ostream::_Osfx(_QWORD);

//----- (00000001400148A0) ----------------------------------------------------
__int64 __fastcall sub_1400148A0(__int64 a1, __int64 a2)
{
  sub_140011721(&unk_14003E009);
  return a2;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400148F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400148F0(__int64 a1, unsigned __int64 a2)
{
  sub_140011721(&unk_14003E04C);
  if ( a2 > *(_QWORD *)(a1 + 24) )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring",
                         4063i64,
                         0i64,
                         "%s",
                         "string subscript out of range") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"string subscript out of range\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring",
      4063i64,
      0i64);
  }
  return a2 + sub_140011172(a1);
}
// 140011172: using guessed type __int64 __fastcall sub_140011172(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140032980: using guessed type wchar_t aCProgramFilesM_4[98];
// 140032A70: using guessed type wchar_t aStringSubscrip_0[32];
// 14003C498: using guessed type __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 14003C4A0: using guessed type __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140014A00) ----------------------------------------------------
unsigned __int64 __fastcall sub_140014A00(__int64 a1, unsigned __int64 a2)
{
  sub_140011721(&unk_14003E04C);
  if ( a2 > *(_QWORD *)(a1 + 24) )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring",
                         4071i64,
                         0i64,
                         "%s",
                         "string subscript out of range") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"string subscript out of range\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring",
      4071i64,
      0i64);
  }
  return a2 + sub_140011357(a1);
}
// 140011357: using guessed type __int64 __fastcall sub_140011357(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140032980: using guessed type wchar_t aCProgramFilesM_4[98];
// 140032A70: using guessed type wchar_t aStringSubscrip_0[32];
// 14003C498: using guessed type __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 14003C4A0: using guessed type __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140014B10) ----------------------------------------------------
__int64 __fastcall sub_140014B10(__int64 a1)
{
  sub_140011721(&unk_14003E066);
  return *(unsigned __int8 *)(a1 + 8);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140014B60) ----------------------------------------------------
__int64 __fastcall sub_140014B60(__int64 a1)
{
  sub_140011721(&unk_14003E065);
  return *(unsigned __int8 *)(a1 + 8);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140014BB0) ----------------------------------------------------
__int64 sub_140014BB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  char v5[44]; // [rsp+E4h] [rbp+C4h] BYREF
  va_list va; // [rsp+140h] [rbp+120h] BYREF

  va_start(va, a4);
  sub_140011721(&unk_14003E04C);
  sub_1400116C7(a2, a3, a4);
  sub_140011352(a4 + a2, va);
  v5[0] = 0;
  return sub_140011352(a2 + a4 + 1, v5);
}
// 140011352: using guessed type __int64 __fastcall sub_140011352(_QWORD, _QWORD);
// 1400116C7: using guessed type __int64 __fastcall sub_1400116C7(_QWORD, _QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140014BB0: using guessed type char var_2C[44];

//----- (0000000140014C80) ----------------------------------------------------
__int64 __fastcall sub_140014C80(__int64 a1, unsigned __int8 a2)
{
  sub_140011721(&unk_14003E04C);
  sub_140011271(a1, a2);
  return a1;
}
// 140011271: using guessed type __int64 __fastcall sub_140011271(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140014CE0) ----------------------------------------------------
__int64 __fastcall sub_140014CE0(__int64 a1, char a2)
{
  sub_1400113DE(a1);
  if ( (a2 & 1) != 0 )
    sub_1400115EB(a1, 24i64);
  return a1;
}
// 1400115EB: using guessed type __int64 __fastcall sub_1400115EB(_QWORD, _QWORD);

//----- (0000000140014D50) ----------------------------------------------------
__int64 __fastcall sub_140014D50(__int64 a1, char a2)
{
  sub_1400114AB(a1);
  if ( (a2 & 1) != 0 )
    sub_1400115EB(a1, 24i64);
  return a1;
}
// 1400115EB: using guessed type __int64 __fastcall sub_1400115EB(_QWORD, _QWORD);

//----- (0000000140014DC0) ----------------------------------------------------
__int64 __fastcall sub_140014DC0(__int64 a1, char a2)
{
  sub_1400111B8(a1);
  if ( (a2 & 1) != 0 )
    sub_1400115EB(a1, 24i64);
  return a1;
}
// 1400111B8: using guessed type __int64 __fastcall sub_1400111B8(_QWORD);
// 1400115EB: using guessed type __int64 __fastcall sub_1400115EB(_QWORD, _QWORD);

//----- (0000000140014E30) ----------------------------------------------------
__int64 sub_140014E30()
{
  return sub_140011721(&unk_14003E04C);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140014E30: using guessed type __int64 __fastcall sub_140014E30();

//----- (0000000140014E70) ----------------------------------------------------
_QWORD *__fastcall sub_140014E70(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax
  __int64 v3; // [rsp+58h] [rbp+28h]
  unsigned __int64 v4; // [rsp+98h] [rbp+68h]

  sub_140011721(&unk_14003E04A);
  *a2 += 47i64;
  v3 = *(_QWORD *)(*a1 - 8i64);
  if ( *(_QWORD *)(*a1 - 16i64) != 0xFAFAFAFAFAFAFAFAui64 )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
                         (unsigned int)(dword_140037000 + 9),
                         0i64,
                         "%s",
                         "invalid argument") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"invalid argument\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
      (unsigned int)(dword_140037000 + 9),
      0i64);
  }
  v4 = *a1 - v3;
  if ( v4 < 0x10 || v4 > 0x2F )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
                         (unsigned int)(dword_140037000 + 19),
                         0i64,
                         "%s",
                         "invalid argument") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"invalid argument\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
      (unsigned int)(dword_140037000 + 19),
      0i64);
  }
  result = a1;
  *a1 = v3;
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400326A0: using guessed type wchar_t aCProgramFilesM_0[98];
// 140032790: using guessed type wchar_t aInvalidArgumen_0[19];
// 140037000: using guessed type int dword_140037000;
// 14003C498: using guessed type __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 14003C4A0: using guessed type __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400150B0) ----------------------------------------------------
__int64 __fastcall sub_1400150B0(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return sub_14001105A(a1);
}
// 14001105A: using guessed type __int64 __fastcall sub_14001105A(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015100) ----------------------------------------------------
__int64 __fastcall sub_140015100(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  sub_140011721(&unk_14003E04C);
  v2 = sub_1400112B7(a1);
  return sub_1400111EF(a2, *(_QWORD *)(a1 + 32), v2);
}
// 1400111EF: using guessed type __int64 __fastcall sub_1400111EF(_QWORD, _QWORD, _QWORD);
// 1400112B7: using guessed type __int64 __fastcall sub_1400112B7(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015170) ----------------------------------------------------
__int64 __fastcall sub_140015170(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  char *v3; // rdi
  __int64 i; // rcx
  __int64 v5; // rax
  __int64 v6; // rdi
  char v8[32]; // [rsp+0h] [rbp-20h] BYREF
  char v9; // [rsp+20h] [rbp+0h] BYREF
  __int64 v10[28]; // [rsp+28h] [rbp+8h] BYREF
  unsigned __int64 v11; // [rsp+108h] [rbp+E8h] BYREF

  v3 = &v9;
  for ( i = 18i64; i; --i )
  {
    *(_DWORD *)v3 = -858993460;
    v3 += 4;
  }
  sub_140011721(&unk_14003E04C);
  v10[0] = a1 | 0xF;
  if ( (a1 | 0xFui64) <= a3 )
  {
    if ( a2 <= a3 - a2 / 2 )
    {
      v11 = a2 / 2 + a2;
      v5 = *sub_14001143D(v10, &v11);
    }
    else
    {
      v5 = a3;
    }
  }
  else
  {
    v5 = a3;
  }
  v6 = v5;
  sub_1400115FA(v8, &unk_140031DE0);
  return v6;
}
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015170: using guessed type __int64 var_108[28];
// 140015170: using guessed type char var_130[32];

//----- (00000001400152D0) ----------------------------------------------------
__int64 __fastcall sub_1400152D0(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax

  sub_140011721(&unk_14003E04C);
  result = a1;
  if ( *(_QWORD *)(a1 + 24) < a2 )
    return sub_140011767();
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140011767: using guessed type __int64 sub_140011767(void);

//----- (0000000140015330) ----------------------------------------------------
__int64 __fastcall sub_140015330(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  char v4[44]; // [rsp+E4h] [rbp+C4h] BYREF

  sub_140011721(&unk_14003E04C);
  v4[0] = 0;
  *(_QWORD *)(a1 + 24) = a2;
  v2 = sub_140011172(a1);
  return sub_140011352(a2 + v2, v4);
}
// 140011172: using guessed type __int64 __fastcall sub_140011172(_QWORD);
// 140011352: using guessed type __int64 __fastcall sub_140011352(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015330: using guessed type char var_2C[44];

//----- (00000001400153C0) ----------------------------------------------------
__int64 __fastcall sub_1400153C0(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015400) ----------------------------------------------------
__int64 __fastcall sub_140015400(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015440) ----------------------------------------------------
__int64 __fastcall sub_140015440(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return sub_1400115A0(a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015490) ----------------------------------------------------
__int64 __fastcall sub_140015490(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return sub_140011780(a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400154E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400154E0(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return *(_QWORD *)(a1 + 32) >= 0x10ui64;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015550) ----------------------------------------------------
__int64 __fastcall sub_140015550(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp+8h]

  sub_140011721(&unk_14003E04C);
  v2 = a1 + 8;
  if ( sub_1400116F9(a1) )
    return sub_140011730(*(_QWORD *)(a1 + 8));
  return v2;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140011730: using guessed type __int64 __fastcall sub_140011730(_QWORD);

//----- (00000001400155D0) ----------------------------------------------------
__int64 __fastcall sub_1400155D0(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp+8h]

  sub_140011721(&unk_14003E04C);
  v2 = a1 + 8;
  if ( sub_1400116F9(a1) )
    return sub_140011730(*(_QWORD *)(a1 + 8));
  return v2;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140011730: using guessed type __int64 __fastcall sub_140011730(_QWORD);

//----- (0000000140015650) ----------------------------------------------------
__int64 __fastcall sub_140015650(__int64 a1)
{
  sub_140011721(&unk_14003E04A);
  return sub_140011415(a1);
}
// 140011415: using guessed type __int64 __fastcall sub_140011415(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400156A0) ----------------------------------------------------
__int64 __fastcall sub_1400156A0(__int64 a1)
{
  char *v1; // rdi
  __int64 i; // rcx
  char v4[32]; // [rsp+0h] [rbp-20h] BYREF
  char v5; // [rsp+20h] [rbp+0h] BYREF
  char v6[212]; // [rsp+24h] [rbp+4h] BYREF

  v1 = &v5;
  for ( i = 10i64; i; --i )
  {
    *(_DWORD *)v1 = -858993460;
    v1 += 4;
  }
  sub_140011721(&unk_14003E04A);
  std::_Lockit::_Lockit((std::_Lockit *)v6, 3);
  sub_1400114D3(a1);
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return sub_1400115FA(v4, &unk_140031C60);
}
// 1400114D3: using guessed type __int64 __fastcall sub_1400114D3(_QWORD);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 14003C210: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 14003C220: using guessed type _QWORD __fastcall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 1400156A0: using guessed type char var_110[32];

//----- (0000000140015760) ----------------------------------------------------
__int64 __fastcall sub_140015760(__int64 a1)
{
  __int64 result; // rax
  _QWORD *i; // [rsp+28h] [rbp+8h]
  __int64 v3[5]; // [rsp+104h] [rbp+E4h] BYREF

  sub_140011721(&unk_14003E04A);
  result = a1;
  if ( *(_QWORD *)a1 )
  {
    v3[0] = 0i64;
    result = sub_140011154((__int64 *)(*(_QWORD *)a1 + 8i64), v3);
    for ( i = (_QWORD *)result; i; i = (_QWORD *)result )
    {
      *i = 0i64;
      result = i[1];
    }
  }
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015760: using guessed type __int64 var_2C[5];

//----- (0000000140015810) ----------------------------------------------------
__int64 sub_140015810()
{
  return sub_140011721(&unk_14003E04C);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015810: using guessed type __int64 __fastcall sub_140015810();

//----- (0000000140015850) ----------------------------------------------------
void __noreturn sub_140015850()
{
  _QWORD pExceptionObject[7]; // [rsp+E8h] [rbp+C8h] BYREF

  sub_140011721(&unk_14003E043);
  sub_140011627(pExceptionObject);
  j__CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015850: using guessed type void __fastcall __noreturn sub_140015850();
// 140015850: using guessed type _QWORD pExceptionObject[7];

//----- (00000001400158B0) ----------------------------------------------------
__int64 __fastcall sub_1400158B0(_QWORD *a1)
{
  __int64 v2; // [rsp+48h] [rbp+28h]
  __int64 v3; // [rsp+68h] [rbp+48h]
  char v4[44]; // [rsp+144h] [rbp+124h] BYREF

  sub_140011721(&unk_14003E04C);
  sub_1400116BD((__int64)a1);
  if ( sub_1400116F9((__int64)a1) )
  {
    v2 = a1[1];
    v3 = sub_140011226(a1);
    sub_1400113D9(a1 + 1);
    sub_1400116E0(a1);
    sub_14001157D(v3, v2, a1[4] + 1i64);
  }
  a1[3] = 0i64;
  a1[4] = 15i64;
  v4[0] = 0;
  return sub_140011352(a1 + 1, v4);
}
// 140011226: using guessed type __int64 __fastcall sub_140011226(_QWORD);
// 140011352: using guessed type __int64 __fastcall sub_140011352(_QWORD, _QWORD);
// 1400113D9: using guessed type __int64 __fastcall sub_1400113D9(_QWORD);
// 14001157D: using guessed type __int64 __fastcall sub_14001157D(_QWORD, _QWORD, _QWORD);
// 1400116E0: using guessed type __int64 __fastcall sub_1400116E0(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400158B0: using guessed type char var_2C[44];

//----- (00000001400159D0) ----------------------------------------------------
__int64 __fastcall sub_1400159D0(__int64 a1)
{
  char v2[44]; // [rsp+104h] [rbp+E4h] BYREF

  sub_140011721(&unk_14003E04C);
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 15i64;
  sub_1400116E0(a1);
  v2[0] = 0;
  return sub_140011352(a1 + 8, v2);
}
// 140011352: using guessed type __int64 __fastcall sub_140011352(_QWORD, _QWORD);
// 1400116E0: using guessed type __int64 __fastcall sub_1400116E0(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400159D0: using guessed type char var_2C[44];

//----- (0000000140015A70) ----------------------------------------------------
__int64 __fastcall sub_140015A70(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return sub_140011357(a1);
}
// 140011357: using guessed type __int64 __fastcall sub_140011357(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015AC0) ----------------------------------------------------
__int64 __fastcall sub_140015AC0(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return *(_QWORD *)(a1 + 24) + sub_140011357(a1);
}
// 140011357: using guessed type __int64 __fastcall sub_140011357(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015B20) ----------------------------------------------------
void __noreturn sub_140015B20()
{
  sub_140011721(&unk_14003E04C);
  std::_Xlength_error("string too long");
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015B20: using guessed type void __fastcall __noreturn sub_140015B20();

//----- (0000000140015B60) ----------------------------------------------------
void sub_140015B60()
{
  sub_140011721(&unk_14003E04C);
  std::_Xout_of_range("invalid string position");
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015BA0) ----------------------------------------------------
__int64 sub_140015BA0()
{
  return sub_140011721(&unk_14003E06A);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015BA0: using guessed type __int64 __fastcall sub_140015BA0();

//----- (0000000140015BE0) ----------------------------------------------------
__int64 sub_140015BE0()
{
  return sub_140011721(&unk_14003E06A);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015BE0: using guessed type __int64 __fastcall sub_140015BE0();

//----- (0000000140015C20) ----------------------------------------------------
__int64 __fastcall sub_140015C20(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  sub_140011721(&unk_14003E04A);
  v2 = sub_140011393(a2);
  return sub_1400112F8(v2);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015C80) ----------------------------------------------------
__int64 __fastcall sub_140015C80(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  sub_140011721(&unk_14003E04A);
  v2 = sub_14001141F(a2);
  return sub_1400112F8(v2);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015CE0) ----------------------------------------------------
void *__fastcall sub_140015CE0(size_t a1)
{
  sub_140011721(&unk_14003E06A);
  return malloc(a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015D30) ----------------------------------------------------
_BYTE *__fastcall sub_140015D30(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // rax

  sub_140011721(&unk_14003E04C);
  result = a1;
  *a1 = *a2;
  return result;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140015D90) ----------------------------------------------------
__int64 __fastcall sub_140015D90(__int64 a1, __int64 a2)
{
  char *v2; // rdi
  __int64 i; // rcx
  unsigned __int8 *v4; // rax
  char *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  char v9[32]; // [rsp+0h] [rbp-20h] BYREF
  char v10; // [rsp+20h] [rbp+0h] BYREF
  int v11; // [rsp+24h] [rbp+4h]
  int j; // [rsp+44h] [rbp+24h]
  int k; // [rsp+64h] [rbp+44h]
  int v14; // [rsp+84h] [rbp+64h]
  char v15; // [rsp+A4h] [rbp+84h] BYREF
  char v16; // [rsp+A5h] [rbp+85h]
  char v17; // [rsp+A6h] [rbp+86h]
  char v18; // [rsp+A7h] [rbp+87h]
  char v19; // [rsp+C4h] [rbp+A4h]
  char v20; // [rsp+C5h] [rbp+A5h]
  char v21; // [rsp+C6h] [rbp+A6h]
  __int64 v22; // [rsp+1E8h] [rbp+1C8h]
  int v23; // [rsp+204h] [rbp+1E4h]
  __int64 v25; // [rsp+218h] [rbp+1F8h]

  v2 = &v10;
  for ( i = 86i64; i; --i )
  {
    *(_DWORD *)v2 = -858993460;
    v2 += 4;
  }
  v23 = 0;
  sub_140011721(&unk_14003E06A);
  v11 = sub_14001155A(a2);
  j = 0;
  k = 0;
  v14 = 0;
  v25 = sub_140011712(a1);
  v23 |= 1u;
  while ( v11-- )
  {
    if ( *(_BYTE *)sub_140011019(a2, v14) == 61 )
      break;
    v4 = (unsigned __int8 *)sub_140011019(a2, v14);
    if ( !sub_140011032(*v4) )
      break;
    v5 = (char *)sub_140011019(a2, v14);
    *(&v15 + j++) = *v5;
    ++v14;
    if ( j == 4 )
    {
      for ( j = 0; j < 4; ++j )
      {
        v6 = sub_140011348("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "", &v15 + j);
        *(&v15 + j) = v6 - (_QWORD)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      }
      v19 = ((v16 & 0x30) >> 4) + 4 * v15;
      v20 = ((v17 & 0x3C) >> 2) + 16 * (v16 & 0xF);
      v21 = v18 + ((v17 & 3) << 6);
      for ( j = 0; j < 3; ++j )
        sub_1400113CA(a1, (unsigned __int8)*(&v19 + j));
      j = 0;
    }
  }
  if ( j )
  {
    for ( k = j; k < 4; ++k )
    {
      v22 = k;
      if ( (unsigned __int64)k >= 4 )
        j___report_rangecheckfailure();
      *(&v15 + v22) = 0;
    }
    for ( k = 0; k < 4; ++k )
    {
      v7 = sub_140011348("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "", &v15 + k);
      *(&v15 + k) = v7 - (_QWORD)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    }
    v19 = ((v16 & 0x30) >> 4) + 4 * v15;
    v20 = ((v17 & 0x3C) >> 2) + 16 * (v16 & 0xF);
    for ( k = 0; k < j - 1; ++k )
      sub_1400113CA(a1, (unsigned __int8)*(&v19 + k));
  }
  sub_1400115FA(v9, &unk_1400320A0);
  return a1;
}
// 140011019: using guessed type __int64 __fastcall sub_140011019(_QWORD, _QWORD);
// 140011348: using guessed type __int64 __fastcall sub_140011348(_QWORD, _QWORD, _QWORD);
// 1400113CA: using guessed type __int64 __fastcall sub_1400113CA(_QWORD, _QWORD);
// 14001155A: using guessed type __int64 __fastcall sub_14001155A(_QWORD);
// 14001155F: using guessed type __int64 j___report_rangecheckfailure(void);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011712: using guessed type __int64 __fastcall sub_140011712(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140015D90: using guessed type char var_240[32];

//----- (00000001400162B0) ----------------------------------------------------
__int64 __fastcall sub_1400162B0(__int64 a1, __int64 a2)
{
  char *v2; // rdi
  __int64 i; // rcx
  __int64 v4; // rdx
  char v6[32]; // [rsp+0h] [rbp-20h] BYREF
  char v7; // [rsp+20h] [rbp+0h] BYREF
  int j; // [rsp+64h] [rbp+44h]
  int k; // [rsp+84h] [rbp+64h]
  char v10; // [rsp+A4h] [rbp+84h]
  char v11; // [rsp+A5h] [rbp+85h]
  char v12; // [rsp+A6h] [rbp+86h]
  char v13; // [rsp+C4h] [rbp+A4h]
  char v14; // [rsp+C5h] [rbp+A5h]
  char v15; // [rsp+C6h] [rbp+A6h]
  char v16; // [rsp+C7h] [rbp+A7h]
  __int64 v17; // [rsp+E8h] [rbp+C8h]
  char *v18; // [rsp+108h] [rbp+E8h]
  char *v19; // [rsp+128h] [rbp+108h]
  char *v20; // [rsp+148h] [rbp+128h]
  __int64 v21; // [rsp+248h] [rbp+228h]
  int v22; // [rsp+264h] [rbp+244h]
  int v23; // [rsp+274h] [rbp+254h]
  __int64 v24; // [rsp+278h] [rbp+258h]

  v2 = &v7;
  for ( i = 106i64; i; --i )
  {
    *(_DWORD *)v2 = -858993460;
    v2 += 4;
  }
  v22 = 0;
  sub_140011721(&unk_14003E06A);
  v24 = sub_140011712(a1);
  v22 |= 1u;
  j = 0;
  k = 0;
  v17 = a2;
  v18 = (char *)sub_1400116A4(a2);
  v19 = (char *)sub_140011041(v17);
  while ( v18 != v19 )
  {
    v20 = v18;
    *(&v10 + j++) = *v18;
    if ( j == 3 )
    {
      v13 = (v10 & 0xFC) >> 2;
      v14 = ((v11 & 0xF0) >> 4) + 16 * (v10 & 3);
      v15 = ((v12 & 0xC0) >> 6) + 4 * (v11 & 0xF);
      v16 = v12 & 0x3F;
      for ( j = 0; j < 4; ++j )
        sub_1400113CA(a1, (unsigned __int8)aAbcdefghijklmn[(unsigned __int8)*(&v13 + j)]);
      j = 0;
    }
    ++v18;
  }
  if ( j )
  {
    for ( k = j; k < 3; ++k )
    {
      v21 = k;
      if ( (unsigned __int64)k >= 3 )
        j___report_rangecheckfailure();
      *(&v10 + v21) = 0;
    }
    v13 = (v10 & 0xFC) >> 2;
    v14 = ((v11 & 0xF0) >> 4) + 16 * (v10 & 3);
    v15 = ((v12 & 0xC0) >> 6) + 4 * (v11 & 0xF);
    for ( k = 0; k < j + 1; ++k )
      sub_1400113CA(a1, (unsigned __int8)aAbcdefghijklmn[(unsigned __int8)*(&v13 + k)]);
    while ( 1 )
    {
      v23 = j++;
      LODWORD(v24) = v23 < 3;
      if ( v23 >= 3 )
        break;
      LOBYTE(v4) = 61;
      sub_1400113CA(a1, v4);
    }
  }
  sub_1400115FA(v6, &unk_140031F50);
  return a1;
}
// 14001664C: variable 'v4' is possibly undefined
// 140011041: using guessed type __int64 __fastcall sub_140011041(_QWORD);
// 1400113CA: using guessed type __int64 __fastcall sub_1400113CA(_QWORD, _QWORD);
// 14001155F: using guessed type __int64 j___report_rangecheckfailure(void);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 1400116A4: using guessed type __int64 __fastcall sub_1400116A4(_QWORD);
// 140011712: using guessed type __int64 __fastcall sub_140011712(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400162B0: using guessed type char var_290[32];

//----- (0000000140016770) ----------------------------------------------------
__int64 __fastcall sub_140016770(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return sub_140011357(a1);
}
// 140011357: using guessed type __int64 __fastcall sub_140011357(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400167C0) ----------------------------------------------------
void *__fastcall sub_1400167C0(void *a1, const void *a2, size_t a3)
{
  sub_140011721(&unk_14003E04C);
  j_memcpy(a1, a2, a3);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016830) ----------------------------------------------------
__int64 __fastcall sub_140016830(__int64 a1, __int64 a2, __int64 a3)
{
  sub_140011721(&unk_14003E04A);
  return sub_14001107D(a2, 16 * a3);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016890) ----------------------------------------------------
__int64 __fastcall sub_140016890(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  sub_140011721(&unk_14003E04A);
  if ( !a2 && a3 )
  {
    if ( (unsigned int)CrtDbgReport(
                         2i64,
                         "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
                         944i64,
                         0i64,
                         "%s",
                         "null pointer cannot point to a block of non-zero size") == 1 )
      __debugbreak();
    invalid_parameter(
      L"\"null pointer cannot point to a block of non-zero size\"",
      &unk_14003278C,
      L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory",
      944i64,
      0i64);
  }
  return sub_14001107D(a2, a3);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400326A0: using guessed type wchar_t aCProgramFilesM_0[98];
// 140032B00: using guessed type wchar_t aNullPointerCan_0[56];
// 14003C498: using guessed type __int64 CrtDbgReport(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 14003C4A0: using guessed type __int64 __fastcall invalid_parameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400169A0) ----------------------------------------------------
void __fastcall sub_1400169A0(void *a1)
{
  sub_140011721(&unk_14003E06A);
  free(a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400169F0) ----------------------------------------------------
__int64 sub_1400169F0()
{
  sub_140011721(&unk_14003E04C);
  return 0xFFFFFFFFi64;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400169F0: using guessed type __int64 __fastcall sub_1400169F0();

//----- (0000000140016A30) ----------------------------------------------------
_BOOL8 __fastcall sub_140016A30(_DWORD *a1, _DWORD *a2)
{
  sub_140011721(&unk_14003E04C);
  return *a1 == *a2;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016AB0) ----------------------------------------------------
__int64 __fastcall sub_140016AB0(__int64 a1, unsigned __int64 a2)
{
  sub_140011721(&unk_14003E04C);
  sub_1400114DD(a1, a2);
  sub_1400113C5(a1, a2);
  return a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016B30) ----------------------------------------------------
_BOOL8 __fastcall sub_140016B30(unsigned __int8 a1)
{
  sub_140011721(&unk_14003E06A);
  return isalnum(a1) || a1 == 43 || a1 == 47;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016BC0) ----------------------------------------------------
size_t __fastcall sub_140016BC0(const char *a1)
{
  sub_140011721(&unk_14003E04C);
  return j_strlen(a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016C10) ----------------------------------------------------
__int64 __fastcall sub_140016C10(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return *(_QWORD *)(a1 + 24);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016C60) ----------------------------------------------------
__int64 sub_140016C60()
{
  sub_140011721(&unk_14003E047);
  return 0x7FFFFFFFFFFFFFFFi64;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140016C60: using guessed type __int64 __fastcall sub_140016C60();

//----- (0000000140016CA0) ----------------------------------------------------
__int64 sub_140016CA0()
{
  sub_140011721(&unk_14003E04A);
  return -1i64;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140016CA0: using guessed type __int64 __fastcall sub_140016CA0();

//----- (0000000140016CE0) ----------------------------------------------------
__int64 __fastcall sub_140016CE0(__int64 a1)
{
  char *v1; // rdi
  __int64 i; // rcx
  __int64 v3; // rax
  __int64 v4; // rdi
  char v6[32]; // [rsp+0h] [rbp-20h] BYREF
  char v7; // [rsp+20h] [rbp+0h] BYREF
  __int64 v8[4]; // [rsp+28h] [rbp+8h] BYREF
  __int64 v9; // [rsp+48h] [rbp+28h]
  __int64 v10[4]; // [rsp+128h] [rbp+108h] BYREF
  __int64 v11[4]; // [rsp+148h] [rbp+128h] BYREF
  __int64 v12; // [rsp+168h] [rbp+148h] BYREF

  v1 = &v7;
  for ( i = 42i64; i; --i )
  {
    *(_DWORD *)v1 = -858993460;
    v1 += 4;
  }
  sub_140011721(&unk_14003E04C);
  v3 = sub_1400117AD(a1);
  v8[0] = sub_1400112E9(v3);
  v10[0] = 16i64;
  v9 = *sub_14001143D(v8, v10);
  v11[0] = v9 - 1;
  v12 = sub_14001163B();
  v4 = *sub_140011069(&v12, v11);
  sub_1400115FA(v6, &unk_140031D60);
  return v4;
}
// 1400112E9: using guessed type __int64 __fastcall sub_1400112E9(_QWORD);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 14001163B: using guessed type __int64 sub_14001163B(void);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140016CE0: using guessed type __int64 var_168[4];
// 140016CE0: using guessed type __int64 var_68[4];
// 140016CE0: using guessed type __int64 var_48[4];
// 140016CE0: using guessed type char var_190[32];

//----- (0000000140016E00) ----------------------------------------------------
_QWORD *__fastcall sub_140016E00(_QWORD *a1, char a2)
{
  unsigned __int64 v3; // [rsp+28h] [rbp+8h]
  __int64 v4; // [rsp+48h] [rbp+28h]
  char v5[32]; // [rsp+124h] [rbp+104h] BYREF
  char v6[44]; // [rsp+144h] [rbp+124h] BYREF
  char v8; // [rsp+188h] [rbp+168h] BYREF

  v8 = a2;
  sub_140011721(&unk_14003E04C);
  v3 = a1[3];
  if ( v3 >= a1[4] )
  {
    memset(v6, 0, 1ui64);
    return sub_140011672(a1, 1ui64, v6[0], v8);
  }
  else
  {
    a1[3] = v3 + 1;
    v4 = sub_140011172(a1);
    sub_140011352(v3 + v4, &v8);
    v5[0] = 0;
    return (_QWORD *)sub_140011352(v4 + v3 + 1, v5);
  }
}
// 140011172: using guessed type __int64 __fastcall sub_140011172(_QWORD);
// 140011352: using guessed type __int64 __fastcall sub_140011352(_QWORD, _QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 140016E00: using guessed type char var_4C[32];

//----- (0000000140016F30) ----------------------------------------------------
__int64 __fastcall sub_140016F30(__int64 a1)
{
  sub_140011721(&unk_14003E04C);
  return *(_QWORD *)(a1 + 24);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016F80) ----------------------------------------------------
__int64 __fastcall sub_140016F80(unsigned __int8 *a1)
{
  sub_140011721(&unk_14003E04C);
  return *a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140016FC0) ----------------------------------------------------
__int64 __fastcall sub_140016FC0(unsigned __int8 *a1)
{
  sub_140011721(&unk_14003E04C);
  return *a1;
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140017000) ----------------------------------------------------
const char *__fastcall sub_140017000(__int64 a1)
{
  sub_140011721(&unk_14003E042);
  if ( *(_QWORD *)(a1 + 8) )
    return *(const char **)(a1 + 8);
  else
    return "Unknown exception";
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140017090) ----------------------------------------------------
errno_t __fastcall sub_140017090(struct tm *a1, const __time64_t *a2)
{
  sub_140011721(&unk_14003E050);
  return localtime64_s(a1, a2);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (00000001400170F0) ----------------------------------------------------
__int64 sub_1400170F0()
{
  char *v0; // rdi
  __int64 i; // rcx
  __int64 v2; // rax
  __int64 v3; // rax
  unsigned int v4; // eax
  const void *v5; // rax
  char *v6; // rax
  __int64 v7; // rax
  size_t v8; // rax
  size_t v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rdi
  char v15[32]; // [rsp+0h] [rbp-20h] BYREF
  char v16; // [rsp+20h] [rbp+0h] BYREF
  __int64 v17[8]; // [rsp+28h] [rbp+8h] BYREF
  __int64 v18[13]; // [rsp+68h] [rbp+48h] BYREF
  int v19; // [rsp+D4h] [rbp+B4h]
  __time64_t v20[4]; // [rsp+F8h] [rbp+D8h] BYREF
  struct tm v21; // [rsp+118h] [rbp+F8h] BYREF
  void *v22; // [rsp+158h] [rbp+138h]
  __int64 v23[7]; // [rsp+178h] [rbp+158h] BYREF
  char v24; // [rsp+1B4h] [rbp+194h]
  int j; // [rsp+1D4h] [rbp+1B4h]
  void *v26; // [rsp+1F8h] [rbp+1D8h]
  unsigned int v27; // [rsp+394h] [rbp+374h]
  unsigned int v28; // [rsp+3B4h] [rbp+394h]
  int v29; // [rsp+3C4h] [rbp+3A4h]
  size_t Size; // [rsp+3C8h] [rbp+3A8h]
  unsigned __int64 v31; // [rsp+3D0h] [rbp+3B0h]

  v0 = &v16;
  for ( i = 146i64; i; --i )
  {
    *(_DWORD *)v0 = -858993460;
    v0 += 4;
  }
  sub_140011721(&unk_14003E06A);
  sub_140011712(v17);
  sub_140011712(v18);
  memset(&v18[8], 0, 0x10ui64);
  v19 = 0;
  sub_140017620(v20);
  sub_140017090(&v21, v20);
  v18[8] = *(_QWORD *)&v21.tm_mday + 0x100000000i64;
  LODWORD(v18[9]) = v21.tm_year + 1900;
  if ( v21.tm_year == 123 )
  {
    v19 = 10 * ((LODWORD(v18[9]) + HIDWORD(v18[8]) + LODWORD(v18[8])) / 8);
    v22 = sub_14001142E(v19);
    sub_1400110DC(std::cout, (__int64)"Enter the password (Base64 encoded): ");
    v4 = sub_140011208();
    std::istream::ignore(std::cin, 1i64, v4);
    sub_14001140B(std::cin, (__int64)v17);
    sub_140011140((__int64)v23, (__int64)v17);
    Size = v19;
    v5 = (const void *)sub_1400110B4((__int64)v23);
    j_memcpy(v22, v5, Size);
    v24 = 1;
    for ( j = 0; j < v19; ++j )
    {
      v29 = *((char *)v22 + j);
      Size = j;
      v31 = sub_140011640((__int64)v17);
      v6 = (char *)sub_1400110FA((__int64)v17, Size % v31);
      if ( v29 != ((j + 1) ^ (j + *v6)) )
      {
        v24 = 0;
        break;
      }
    }
    sub_14001145B(v22);
    if ( v24 )
    {
      v7 = sub_1400110DC(std::cout, (__int64)"Correct password! You passed the crackme test.");
      std::ostream::operator<<(v7, sub_14001104B);
      v8 = j_strlen(Str);
      v26 = sub_14001142E(v8 + 1);
      v9 = j_strlen(Str);
      j_memcpy(v26, Str, v9);
      *((_BYTE *)v26 + j_strlen(Str)) = 0;
      v10 = sub_1400110DC(std::cout, (__int64)"Hidden string: ");
      v11 = sub_1400110DC(v10, (__int64)v26);
      std::ostream::operator<<(v11, sub_14001104B);
      sub_14001145B(v26);
    }
    else
    {
      v12 = sub_1400110DC(std::cout, (__int64)"Wrong password! You failed the crackme test.");
      std::ostream::operator<<(v12, sub_14001104B);
    }
    v28 = 0;
    sub_140011177(v23);
    sub_140011177(v18);
    sub_140011177(v17);
    v3 = v28;
  }
  else
  {
    v2 = sub_1400110DC(std::cout, (__int64)"Access denied!");
    std::ostream::operator<<(v2, sub_14001104B);
    v27 = 1;
    sub_140011177(v18);
    sub_140011177(v17);
    v3 = v27;
  }
  v13 = v3;
  sub_1400115FA(v15, &unk_1400322D0);
  return v13;
}
// 140011208: using guessed type __int64 sub_140011208(void);
// 1400115FA: using guessed type __int64 __fastcall sub_1400115FA(_QWORD, _QWORD);
// 140011712: using guessed type __int64 __fastcall sub_140011712(_QWORD);
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);
// 1400170F0: using guessed type __int64 __fastcall sub_1400170F0();
// 14003C158: using guessed type __int64 __fastcall std::istream::ignore(_QWORD, _QWORD, _QWORD);
// 14003C178: using guessed type __int64 __fastcall std::ostream::operator<<(_QWORD, _QWORD);
// 1400170F0: using guessed type __int64 var_3C8[8];
// 1400170F0: using guessed type __time64_t var_2F8[4];
// 1400170F0: using guessed type __int64 var_278[7];
// 1400170F0: using guessed type char var_3F0[32];

//----- (0000000140017620) ----------------------------------------------------
__time64_t __fastcall sub_140017620(__time64_t *a1)
{
  sub_140011721(&unk_14003E050);
  return time64(a1);
}
// 140011721: using guessed type __int64 __fastcall sub_140011721(_QWORD);

//----- (0000000140017670) ----------------------------------------------------
char **__fastcall sub_140017670(char **a1, char *a2, char *a3, char **a4, char a5, char a6)
{
  while ( a2 != a3 )
  {
    if ( *a2 < a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= *a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017750) ----------------------------------------------------
char **__fastcall sub_140017750(char **a1, char *a2, char *a3, char **a4, unsigned __int8 a5, unsigned __int8 a6)
{
  while ( a2 != a3 )
  {
    if ( (unsigned __int8)*a2 < (int)a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= (int)(unsigned __int8)*a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017830) ----------------------------------------------------
__int16 **__fastcall sub_140017830(__int16 **a1, __int16 *a2, __int16 *a3, __int16 **a4, __int16 a5, __int16 a6)
{
  while ( a2 != a3 )
  {
    if ( *a2 < a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= *a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017910) ----------------------------------------------------
__int16 **__fastcall sub_140017910(
        __int16 **a1,
        __int16 *a2,
        __int16 *a3,
        __int16 **a4,
        unsigned __int16 a5,
        unsigned __int16 a6)
{
  while ( a2 != a3 )
  {
    if ( (unsigned __int16)*a2 < (int)a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= (int)(unsigned __int16)*a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (00000001400179F0) ----------------------------------------------------
int **__fastcall sub_1400179F0(int **a1, int *a2, int *a3, int **a4, int a5, int a6)
{
  while ( a2 != a3 )
  {
    if ( *a2 < a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= *a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017AC0) ----------------------------------------------------
unsigned int **__fastcall sub_140017AC0(
        unsigned int **a1,
        unsigned int *a2,
        unsigned int *a3,
        unsigned int **a4,
        unsigned int a5,
        unsigned int a6)
{
  while ( a2 != a3 )
  {
    if ( *a2 < a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= *a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017B90) ----------------------------------------------------
__int64 **__fastcall sub_140017B90(__int64 **a1, __int64 *a2, __int64 *a3, __int64 **a4, __int64 a5, __int64 a6)
{
  while ( a2 != a3 )
  {
    if ( *a2 < a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= *a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017C70) ----------------------------------------------------
__int64 **__fastcall sub_140017C70(
        __int64 **a1,
        __int64 *a2,
        __int64 *a3,
        __int64 **a4,
        unsigned __int64 a5,
        unsigned __int64 a6)
{
  while ( a2 != a3 )
  {
    if ( *a2 < a5 )
    {
      *a4 = a2;
      a5 = *a2;
    }
    if ( a6 <= *a2 )
    {
      a4[1] = a2;
      a6 = *a2;
    }
    ++a2;
  }
  qmemcpy(a1, a4, 0x10ui64);
  return a1;
}

//----- (0000000140017D50) ----------------------------------------------------
__int64 __fastcall sub_140017D50(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3, unsigned __int8 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 == a4 )
      ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000140017DD0) ----------------------------------------------------
__int64 __fastcall sub_140017DD0(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3, unsigned __int16 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 == a4 )
      ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000140017E50) ----------------------------------------------------
__int64 __fastcall sub_140017E50(_DWORD *a1, _DWORD *a2, __int64 a3, int a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 == a4 )
      ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000140017ED0) ----------------------------------------------------
__int64 __fastcall sub_140017ED0(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 == a4 )
      ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000140017F50) ----------------------------------------------------
unsigned __int8 *__fastcall sub_140017F50(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  while ( a1 != a2 && *a1 != a3 )
    ++a1;
  return a1;
}

//----- (0000000140017FB0) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140017FB0(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 a3)
{
  while ( a1 != a2 && *a1 != a3 )
    ++a1;
  return a1;
}

//----- (0000000140018020) ----------------------------------------------------
_DWORD *__fastcall sub_140018020(_DWORD *a1, _DWORD *a2, int a3)
{
  while ( a1 != a2 && *a1 != a3 )
    ++a1;
  return a1;
}

//----- (0000000140018080) ----------------------------------------------------
_QWORD *__fastcall sub_140018080(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  while ( a1 != a2 && *a1 != a3 )
    ++a1;
  return a1;
}

//----- (00000001400180E0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_1400180E0(unsigned __int8 *a1, unsigned __int8 a2)
{
  while ( *a1 != a2 )
    ++a1;
  return a1;
}

//----- (0000000140018130) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140018130(unsigned __int16 *a1, unsigned __int16 a2)
{
  while ( *a1 != a2 )
    ++a1;
  return a1;
}

//----- (0000000140018180) ----------------------------------------------------
_DWORD *__fastcall sub_140018180(_DWORD *a1, int a2)
{
  while ( *a1 != a2 )
    ++a1;
  return a1;
}

//----- (00000001400181D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400181D0(_QWORD *a1, __int64 a2)
{
  while ( *a1 != a2 )
    ++a1;
  return a1;
}

//----- (0000000140018220) ----------------------------------------------------
__m128i __fastcall sub_140018220(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-158h] BYREF
  __m128i si128; // [rsp+30h] [rbp-148h] BYREF
  __m128i v5; // [rsp+40h] [rbp-138h] BYREF
  __m128i v6; // [rsp+50h] [rbp-128h] BYREF
  __m128i v7; // [rsp+60h] [rbp-118h] BYREF
  __m128i v8; // [rsp+70h] [rbp-108h] BYREF
  __m128i v9; // [rsp+80h] [rbp-F8h] BYREF
  __m128i v10; // [rsp+90h] [rbp-E8h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-D8h] BYREF
  __m128i v12; // [rsp+B0h] [rbp-C8h]
  __m128i v13; // [rsp+C0h] [rbp-B8h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-A8h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-98h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-88h]
  __m128i v17; // [rsp+100h] [rbp-78h] BYREF
  __m128i v18; // [rsp+110h] [rbp-68h] BYREF
  __m128i v19; // [rsp+120h] [rbp-58h] BYREF
  __m128i v20; // [rsp+130h] [rbp-48h] BYREF
  __m128i v21; // [rsp+140h] [rbp-38h] BYREF
  __m128i v22; // [rsp+150h] [rbp-28h] BYREF
  __m128i v23; // [rsp+160h] [rbp-18h] BYREF
  char v24; // [rsp+188h] [rbp+10h] BYREF

  v24 = a2;
  si128 = _mm_load_si128(xmmword_140032F30);
  v16 = _mm_load_si128(&si128);
  v5 = _mm_load_si128(xmmword_140032F10);
  v12 = _mm_load_si128(&v5);
  v3 = _mm_loadu_si128(a1);
  v6 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v7 = _mm_load_si128(&v6);
  v8 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024840((__int64)&v24, &v20, &v8, &v7));
  v9 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v10 = _mm_load_si128(&v9);
  v11 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024840((__int64)&v24, &v21, &v11, &v10));
  v13 = _mm_shuffle_epi8(_mm_load_si128(&v3), v12);
  v14 = _mm_load_si128(&v13);
  v15 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024840((__int64)&v24, &v22, &v15, &v14));
  v17 = _mm_shuffle_epi8(_mm_load_si128(&v3), v16);
  v18 = _mm_load_si128(&v17);
  v19 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024840((__int64)&v24, &v23, &v19, &v18));
  return _mm_load_si128(&v3);
}
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 140032F30: using guessed type __m128i xmmword_140032F30[2];
// 140018220: using guessed type __m128i var_18;

//----- (0000000140018490) ----------------------------------------------------
__m128i __fastcall sub_140018490(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-F8h] BYREF
  __m128i si128; // [rsp+30h] [rbp-E8h] BYREF
  __m128i v5; // [rsp+40h] [rbp-D8h] BYREF
  __m128i v6; // [rsp+50h] [rbp-C8h] BYREF
  __m128i v7; // [rsp+60h] [rbp-B8h] BYREF
  __m128i v8; // [rsp+70h] [rbp-A8h] BYREF
  __m128i v9; // [rsp+80h] [rbp-98h] BYREF
  __m128i v10; // [rsp+90h] [rbp-88h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-78h]
  __m128i v12; // [rsp+B0h] [rbp-68h] BYREF
  __m128i v13; // [rsp+C0h] [rbp-58h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-48h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-38h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-28h] BYREF
  __m128i v17; // [rsp+100h] [rbp-18h] BYREF
  char v18; // [rsp+128h] [rbp+10h] BYREF

  v18 = a2;
  si128 = _mm_load_si128(xmmword_140032F10);
  v11 = _mm_load_si128(&si128);
  v3 = _mm_loadu_si128(a1);
  v5 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v6 = _mm_load_si128(&v5);
  v7 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_1400248A0((__int64)&v18, &v15, &v7, &v6));
  v8 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v9 = _mm_load_si128(&v8);
  v10 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_1400248A0((__int64)&v18, &v16, &v10, &v9));
  v12 = _mm_shuffle_epi8(_mm_load_si128(&v3), v11);
  v13 = _mm_load_si128(&v12);
  v14 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_1400248A0((__int64)&v18, &v17, &v14, &v13));
  return _mm_load_si128(&v3);
}
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 140018490: using guessed type __m128i var_18;

//----- (0000000140018650) ----------------------------------------------------
__m128i __fastcall sub_140018650(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-98h] BYREF
  __m128i v4; // [rsp+30h] [rbp-88h] BYREF
  __m128i v5; // [rsp+40h] [rbp-78h] BYREF
  __m128i v6; // [rsp+50h] [rbp-68h] BYREF
  __m128i v7; // [rsp+60h] [rbp-58h] BYREF
  __m128i v8; // [rsp+70h] [rbp-48h] BYREF
  __m128i v9; // [rsp+80h] [rbp-38h] BYREF
  __m128i v10; // [rsp+90h] [rbp-28h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-18h] BYREF
  char v12; // [rsp+C8h] [rbp+10h] BYREF

  v12 = a2;
  v3 = _mm_loadu_si128(a1);
  v4 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v5 = _mm_load_si128(&v4);
  v6 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024900((__int64)&v12, &v10, &v6, &v5));
  v7 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v8 = _mm_load_si128(&v7);
  v9 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024900((__int64)&v12, &v11, &v9, &v8));
  return _mm_load_si128(&v3);
}
// 140018650: using guessed type __m128i var_18;

//----- (0000000140018760) ----------------------------------------------------
__m128i __fastcall sub_140018760(const __m128i *a1, char a2)
{
  __m128i v2; // xmm0
  __m128i v4; // [rsp+20h] [rbp-58h] BYREF
  __m128i v5; // [rsp+30h] [rbp-48h] BYREF
  __m128i v6; // [rsp+40h] [rbp-38h] BYREF
  __m128i v7; // [rsp+50h] [rbp-28h] BYREF
  __m128i v8; // [rsp+60h] [rbp-18h] BYREF
  char v10; // [rsp+88h] [rbp+10h] BYREF

  v10 = a2;
  v5 = _mm_loadu_si128(a1);
  v4.m128i_i64[0] = sub_140025330(&v5);
  v6 = _mm_srli_si128(_mm_loadu_si128(a1), 8);
  v7 = _mm_load_si128(&v6);
  v4.m128i_i64[1] = sub_140025330(&v7);
  if ( sub_140024960((__int64)&v10, v4.m128i_i64[1], v4.m128i_i64[0]) )
    v4.m128i_i64[0] = v4.m128i_i64[1];
  v2 = _mm_loadl_epi64(&v4);
  v8 = _mm_unpacklo_epi64(v2, v2);
  return _mm_load_si128(&v8);
}
// 140018760: using guessed type __m128i var_18;

//----- (0000000140018830) ----------------------------------------------------
__m128i __fastcall sub_140018830(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-158h] BYREF
  __m128i si128; // [rsp+30h] [rbp-148h] BYREF
  __m128i v5; // [rsp+40h] [rbp-138h] BYREF
  __m128i v6; // [rsp+50h] [rbp-128h] BYREF
  __m128i v7; // [rsp+60h] [rbp-118h] BYREF
  __m128i v8; // [rsp+70h] [rbp-108h] BYREF
  __m128i v9; // [rsp+80h] [rbp-F8h] BYREF
  __m128i v10; // [rsp+90h] [rbp-E8h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-D8h] BYREF
  __m128i v12; // [rsp+B0h] [rbp-C8h]
  __m128i v13; // [rsp+C0h] [rbp-B8h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-A8h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-98h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-88h]
  __m128i v17; // [rsp+100h] [rbp-78h] BYREF
  __m128i v18; // [rsp+110h] [rbp-68h] BYREF
  __m128i v19; // [rsp+120h] [rbp-58h] BYREF
  char v20[16]; // [rsp+130h] [rbp-48h] BYREF
  char v21[16]; // [rsp+140h] [rbp-38h] BYREF
  char v22[16]; // [rsp+150h] [rbp-28h] BYREF
  char v23[24]; // [rsp+160h] [rbp-18h] BYREF
  char v24; // [rsp+188h] [rbp+10h] BYREF

  v24 = a2;
  si128 = _mm_load_si128(xmmword_140032F30);
  v16 = _mm_load_si128(&si128);
  v5 = _mm_load_si128(xmmword_140032F10);
  v12 = _mm_load_si128(&v5);
  v3 = _mm_loadu_si128(a1);
  v6 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v7 = _mm_load_si128(&v6);
  v8 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)((__int64 (__fastcall *)(char *, char *, __m128i *, __m128i *, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))sub_1400249B0)(
                                          &v24,
                                          v20,
                                          &v8,
                                          &v7,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1]));
  v9 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v10 = _mm_load_si128(&v9);
  v11 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_1400249B0(
                                          &v24,
                                          v21,
                                          &v11,
                                          &v10,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  v13 = _mm_shuffle_epi8(_mm_load_si128(&v3), v12);
  v14 = _mm_load_si128(&v13);
  v15 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_1400249B0(
                                          &v24,
                                          v22,
                                          &v15,
                                          &v14,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  v17 = _mm_shuffle_epi8(_mm_load_si128(&v3), v16);
  v18 = _mm_load_si128(&v17);
  v19 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_1400249B0(
                                          &v24,
                                          v23,
                                          &v19,
                                          &v18,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  return _mm_load_si128(&v3);
}
// 1400249B0: using guessed type __int64 __fastcall sub_1400249B0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 140032F30: using guessed type __m128i xmmword_140032F30[2];
// 140018830: using guessed type char var_48[16];
// 140018830: using guessed type char var_38[16];
// 140018830: using guessed type char var_28[16];
// 140018830: using guessed type char var_18[24];

//----- (0000000140018AA0) ----------------------------------------------------
__m128i __fastcall sub_140018AA0(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-F8h] BYREF
  __m128i si128; // [rsp+30h] [rbp-E8h] BYREF
  __m128i v5; // [rsp+40h] [rbp-D8h] BYREF
  __m128i v6; // [rsp+50h] [rbp-C8h] BYREF
  __m128i v7; // [rsp+60h] [rbp-B8h] BYREF
  __m128i v8; // [rsp+70h] [rbp-A8h] BYREF
  __m128i v9; // [rsp+80h] [rbp-98h] BYREF
  __m128i v10; // [rsp+90h] [rbp-88h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-78h]
  __m128i v12; // [rsp+B0h] [rbp-68h] BYREF
  __m128i v13; // [rsp+C0h] [rbp-58h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-48h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-38h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-28h] BYREF
  __m128i v17; // [rsp+100h] [rbp-18h] BYREF
  char v18; // [rsp+128h] [rbp+10h] BYREF

  v18 = a2;
  si128 = _mm_load_si128(xmmword_140032F10);
  v11 = _mm_load_si128(&si128);
  v3 = _mm_loadu_si128(a1);
  v5 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v6 = _mm_load_si128(&v5);
  v7 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024A10((__int64)&v18, &v15, &v7, &v6));
  v8 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v9 = _mm_load_si128(&v8);
  v10 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024A10((__int64)&v18, &v16, &v10, &v9));
  v12 = _mm_shuffle_epi8(_mm_load_si128(&v3), v11);
  v13 = _mm_load_si128(&v12);
  v14 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024A10((__int64)&v18, &v17, &v14, &v13));
  return _mm_load_si128(&v3);
}
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 140018AA0: using guessed type __m128i var_18;

//----- (0000000140018C60) ----------------------------------------------------
__m128i __fastcall sub_140018C60(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-98h] BYREF
  __m128i v4; // [rsp+30h] [rbp-88h] BYREF
  __m128i v5; // [rsp+40h] [rbp-78h] BYREF
  __m128i v6; // [rsp+50h] [rbp-68h] BYREF
  __m128i v7; // [rsp+60h] [rbp-58h] BYREF
  __m128i v8; // [rsp+70h] [rbp-48h] BYREF
  __m128i v9; // [rsp+80h] [rbp-38h] BYREF
  __m128i v10; // [rsp+90h] [rbp-28h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-18h] BYREF
  char v12; // [rsp+C8h] [rbp+10h] BYREF

  v12 = a2;
  v3 = _mm_loadu_si128(a1);
  v4 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v5 = _mm_load_si128(&v4);
  v6 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024A70((__int64)&v12, &v10, &v6, &v5));
  v7 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v8 = _mm_load_si128(&v7);
  v9 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024A70((__int64)&v12, &v11, &v9, &v8));
  return _mm_load_si128(&v3);
}
// 140018C60: using guessed type __m128i var_18;

//----- (0000000140018D70) ----------------------------------------------------
__m128i __fastcall sub_140018D70(const __m128i *a1, char a2)
{
  __m128i v2; // xmm0
  __m128i v4; // [rsp+20h] [rbp-58h] BYREF
  __m128i v5; // [rsp+30h] [rbp-48h] BYREF
  __m128i v6; // [rsp+40h] [rbp-38h] BYREF
  __m128i v7; // [rsp+50h] [rbp-28h] BYREF
  __m128i v8; // [rsp+60h] [rbp-18h] BYREF
  char v10; // [rsp+88h] [rbp+10h] BYREF

  v10 = a2;
  v5 = _mm_loadu_si128(a1);
  v4.m128i_i64[0] = sub_140025330(&v5);
  v6 = _mm_srli_si128(_mm_loadu_si128(a1), 8);
  v7 = _mm_load_si128(&v6);
  v4.m128i_i64[1] = sub_140025330(&v7);
  if ( sub_140024AD0((__int64)&v10, v4.m128i_u64[1], v4.m128i_u64[0]) )
    v4.m128i_i64[0] = v4.m128i_i64[1];
  v2 = _mm_loadl_epi64(&v4);
  v8 = _mm_unpacklo_epi64(v2, v2);
  return _mm_load_si128(&v8);
}
// 140018D70: using guessed type __m128i var_18;

//----- (0000000140018E40) ----------------------------------------------------
__m128i __fastcall sub_140018E40(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-158h] BYREF
  __m128i si128; // [rsp+30h] [rbp-148h] BYREF
  __m128i v5; // [rsp+40h] [rbp-138h] BYREF
  __m128i v6; // [rsp+50h] [rbp-128h] BYREF
  __m128i v7; // [rsp+60h] [rbp-118h] BYREF
  __m128i v8; // [rsp+70h] [rbp-108h] BYREF
  __m128i v9; // [rsp+80h] [rbp-F8h] BYREF
  __m128i v10; // [rsp+90h] [rbp-E8h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-D8h] BYREF
  __m128i v12; // [rsp+B0h] [rbp-C8h]
  __m128i v13; // [rsp+C0h] [rbp-B8h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-A8h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-98h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-88h]
  __m128i v17; // [rsp+100h] [rbp-78h] BYREF
  __m128i v18; // [rsp+110h] [rbp-68h] BYREF
  __m128i v19; // [rsp+120h] [rbp-58h] BYREF
  char v20[16]; // [rsp+130h] [rbp-48h] BYREF
  char v21[16]; // [rsp+140h] [rbp-38h] BYREF
  char v22[16]; // [rsp+150h] [rbp-28h] BYREF
  char v23[24]; // [rsp+160h] [rbp-18h] BYREF
  char v24; // [rsp+188h] [rbp+10h] BYREF

  v24 = a2;
  si128 = _mm_load_si128(xmmword_140032F30);
  v16 = _mm_load_si128(&si128);
  v5 = _mm_load_si128(xmmword_140032F10);
  v12 = _mm_load_si128(&v5);
  v3 = _mm_loadu_si128(a1);
  v6 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v7 = _mm_load_si128(&v6);
  v8 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)((__int64 (__fastcall *)(char *, char *, __m128i *, __m128i *, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))sub_140024B20)(
                                          &v24,
                                          v20,
                                          &v8,
                                          &v7,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1]));
  v9 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v10 = _mm_load_si128(&v9);
  v11 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_140024B20(
                                          &v24,
                                          v21,
                                          &v11,
                                          &v10,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  v13 = _mm_shuffle_epi8(_mm_load_si128(&v3), v12);
  v14 = _mm_load_si128(&v13);
  v15 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_140024B20(
                                          &v24,
                                          v22,
                                          &v15,
                                          &v14,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  v17 = _mm_shuffle_epi8(_mm_load_si128(&v3), v16);
  v18 = _mm_load_si128(&v17);
  v19 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_140024B20(
                                          &v24,
                                          v23,
                                          &v19,
                                          &v18,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  return _mm_load_si128(&v3);
}
// 140024B20: using guessed type __int64 __fastcall sub_140024B20(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 140032F30: using guessed type __m128i xmmword_140032F30[2];
// 140018E40: using guessed type char var_48[16];
// 140018E40: using guessed type char var_38[16];
// 140018E40: using guessed type char var_28[16];
// 140018E40: using guessed type char var_18[24];

//----- (00000001400190B0) ----------------------------------------------------
__m128i __fastcall sub_1400190B0(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-F8h] BYREF
  __m128i si128; // [rsp+30h] [rbp-E8h] BYREF
  __m128i v5; // [rsp+40h] [rbp-D8h] BYREF
  __m128i v6; // [rsp+50h] [rbp-C8h] BYREF
  __m128i v7; // [rsp+60h] [rbp-B8h] BYREF
  __m128i v8; // [rsp+70h] [rbp-A8h] BYREF
  __m128i v9; // [rsp+80h] [rbp-98h] BYREF
  __m128i v10; // [rsp+90h] [rbp-88h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-78h]
  __m128i v12; // [rsp+B0h] [rbp-68h] BYREF
  __m128i v13; // [rsp+C0h] [rbp-58h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-48h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-38h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-28h] BYREF
  __m128i v17; // [rsp+100h] [rbp-18h] BYREF
  char v18; // [rsp+128h] [rbp+10h] BYREF

  v18 = a2;
  si128 = _mm_load_si128(xmmword_140032F10);
  v11 = _mm_load_si128(&si128);
  v3 = _mm_loadu_si128(a1);
  v5 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v6 = _mm_load_si128(&v5);
  v7 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024B80((__int64)&v18, &v15, &v7, &v6));
  v8 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v9 = _mm_load_si128(&v8);
  v10 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024B80((__int64)&v18, &v16, &v10, &v9));
  v12 = _mm_shuffle_epi8(_mm_load_si128(&v3), v11);
  v13 = _mm_load_si128(&v12);
  v14 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024B80((__int64)&v18, &v17, &v14, &v13));
  return _mm_load_si128(&v3);
}
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 1400190B0: using guessed type __m128i var_18;

//----- (0000000140019270) ----------------------------------------------------
__m128i __fastcall sub_140019270(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-98h] BYREF
  __m128i v4; // [rsp+30h] [rbp-88h] BYREF
  __m128i v5; // [rsp+40h] [rbp-78h] BYREF
  __m128i v6; // [rsp+50h] [rbp-68h] BYREF
  __m128i v7; // [rsp+60h] [rbp-58h] BYREF
  __m128i v8; // [rsp+70h] [rbp-48h] BYREF
  __m128i v9; // [rsp+80h] [rbp-38h] BYREF
  __m128i v10; // [rsp+90h] [rbp-28h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-18h] BYREF
  char v12; // [rsp+C8h] [rbp+10h] BYREF

  v12 = a2;
  v3 = _mm_loadu_si128(a1);
  v4 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v5 = _mm_load_si128(&v4);
  v6 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024BE0((__int64)&v12, &v10, &v6, &v5));
  v7 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v8 = _mm_load_si128(&v7);
  v9 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024BE0((__int64)&v12, &v11, &v9, &v8));
  return _mm_load_si128(&v3);
}
// 140019270: using guessed type __m128i var_18;

//----- (0000000140019380) ----------------------------------------------------
__m128i __fastcall sub_140019380(const __m128i *a1, char a2)
{
  __m128i v2; // xmm0
  __m128i v4; // [rsp+20h] [rbp-58h] BYREF
  __m128i v5; // [rsp+30h] [rbp-48h] BYREF
  __m128i v6; // [rsp+40h] [rbp-38h] BYREF
  __m128i v7; // [rsp+50h] [rbp-28h] BYREF
  __m128i v8; // [rsp+60h] [rbp-18h] BYREF
  char v10; // [rsp+88h] [rbp+10h] BYREF

  v10 = a2;
  v5 = _mm_loadu_si128(a1);
  v4.m128i_i64[0] = sub_140025330(&v5);
  v6 = _mm_srli_si128(_mm_loadu_si128(a1), 8);
  v7 = _mm_load_si128(&v6);
  v4.m128i_i64[1] = sub_140025330(&v7);
  if ( sub_140024C40((__int64)&v10, v4.m128i_i64[1], v4.m128i_i64[0]) )
    v4.m128i_i64[0] = v4.m128i_i64[1];
  v2 = _mm_loadl_epi64(&v4);
  v8 = _mm_unpacklo_epi64(v2, v2);
  return _mm_load_si128(&v8);
}
// 140019380: using guessed type __m128i var_18;

//----- (0000000140019450) ----------------------------------------------------
__m128i __fastcall sub_140019450(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-158h] BYREF
  __m128i si128; // [rsp+30h] [rbp-148h] BYREF
  __m128i v5; // [rsp+40h] [rbp-138h] BYREF
  __m128i v6; // [rsp+50h] [rbp-128h] BYREF
  __m128i v7; // [rsp+60h] [rbp-118h] BYREF
  __m128i v8; // [rsp+70h] [rbp-108h] BYREF
  __m128i v9; // [rsp+80h] [rbp-F8h] BYREF
  __m128i v10; // [rsp+90h] [rbp-E8h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-D8h] BYREF
  __m128i v12; // [rsp+B0h] [rbp-C8h]
  __m128i v13; // [rsp+C0h] [rbp-B8h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-A8h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-98h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-88h]
  __m128i v17; // [rsp+100h] [rbp-78h] BYREF
  __m128i v18; // [rsp+110h] [rbp-68h] BYREF
  __m128i v19; // [rsp+120h] [rbp-58h] BYREF
  char v20[16]; // [rsp+130h] [rbp-48h] BYREF
  char v21[16]; // [rsp+140h] [rbp-38h] BYREF
  char v22[16]; // [rsp+150h] [rbp-28h] BYREF
  char v23[24]; // [rsp+160h] [rbp-18h] BYREF
  char v24; // [rsp+188h] [rbp+10h] BYREF

  v24 = a2;
  si128 = _mm_load_si128(xmmword_140032F30);
  v16 = _mm_load_si128(&si128);
  v5 = _mm_load_si128(xmmword_140032F10);
  v12 = _mm_load_si128(&v5);
  v3 = _mm_loadu_si128(a1);
  v6 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v7 = _mm_load_si128(&v6);
  v8 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)((__int64 (__fastcall *)(char *, char *, __m128i *, __m128i *, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))sub_140024C90)(
                                          &v24,
                                          v20,
                                          &v8,
                                          &v7,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1]));
  v9 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v10 = _mm_load_si128(&v9);
  v11 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_140024C90(
                                          &v24,
                                          v21,
                                          &v11,
                                          &v10,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  v13 = _mm_shuffle_epi8(_mm_load_si128(&v3), v12);
  v14 = _mm_load_si128(&v13);
  v15 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_140024C90(
                                          &v24,
                                          v22,
                                          &v15,
                                          &v14,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  v17 = _mm_shuffle_epi8(_mm_load_si128(&v3), v16);
  v18 = _mm_load_si128(&v17);
  v19 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128((const __m128i *)sub_140024C90(
                                          &v24,
                                          v23,
                                          &v19,
                                          &v18,
                                          v3.m128i_i64[0],
                                          v3.m128i_i64[1],
                                          si128.m128i_i64[0],
                                          si128.m128i_i64[1],
                                          v5.m128i_i64[0],
                                          v5.m128i_i64[1],
                                          v6.m128i_i64[0],
                                          v6.m128i_i64[1],
                                          v7.m128i_i64[0],
                                          v7.m128i_i64[1],
                                          v8.m128i_i64[0],
                                          v8.m128i_i64[1]));
  return _mm_load_si128(&v3);
}
// 140024C90: using guessed type __int64 __fastcall sub_140024C90(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 140032F30: using guessed type __m128i xmmword_140032F30[2];
// 140019450: using guessed type char var_48[16];
// 140019450: using guessed type char var_38[16];
// 140019450: using guessed type char var_28[16];
// 140019450: using guessed type char var_18[24];

//----- (00000001400196C0) ----------------------------------------------------
__m128i __fastcall sub_1400196C0(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-F8h] BYREF
  __m128i si128; // [rsp+30h] [rbp-E8h] BYREF
  __m128i v5; // [rsp+40h] [rbp-D8h] BYREF
  __m128i v6; // [rsp+50h] [rbp-C8h] BYREF
  __m128i v7; // [rsp+60h] [rbp-B8h] BYREF
  __m128i v8; // [rsp+70h] [rbp-A8h] BYREF
  __m128i v9; // [rsp+80h] [rbp-98h] BYREF
  __m128i v10; // [rsp+90h] [rbp-88h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-78h]
  __m128i v12; // [rsp+B0h] [rbp-68h] BYREF
  __m128i v13; // [rsp+C0h] [rbp-58h] BYREF
  __m128i v14; // [rsp+D0h] [rbp-48h] BYREF
  __m128i v15; // [rsp+E0h] [rbp-38h] BYREF
  __m128i v16; // [rsp+F0h] [rbp-28h] BYREF
  __m128i v17; // [rsp+100h] [rbp-18h] BYREF
  char v18; // [rsp+128h] [rbp+10h] BYREF

  v18 = a2;
  si128 = _mm_load_si128(xmmword_140032F10);
  v11 = _mm_load_si128(&si128);
  v3 = _mm_loadu_si128(a1);
  v5 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v6 = _mm_load_si128(&v5);
  v7 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024CF0((__int64)&v18, &v15, &v7, &v6));
  v8 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v9 = _mm_load_si128(&v8);
  v10 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024CF0((__int64)&v18, &v16, &v10, &v9));
  v12 = _mm_shuffle_epi8(_mm_load_si128(&v3), v11);
  v13 = _mm_load_si128(&v12);
  v14 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024CF0((__int64)&v18, &v17, &v14, &v13));
  return _mm_load_si128(&v3);
}
// 140032F10: using guessed type __m128i xmmword_140032F10[2];
// 1400196C0: using guessed type __m128i var_18;

//----- (0000000140019880) ----------------------------------------------------
__m128i __fastcall sub_140019880(const __m128i *a1, char a2)
{
  __m128i v3; // [rsp+20h] [rbp-98h] BYREF
  __m128i v4; // [rsp+30h] [rbp-88h] BYREF
  __m128i v5; // [rsp+40h] [rbp-78h] BYREF
  __m128i v6; // [rsp+50h] [rbp-68h] BYREF
  __m128i v7; // [rsp+60h] [rbp-58h] BYREF
  __m128i v8; // [rsp+70h] [rbp-48h] BYREF
  __m128i v9; // [rsp+80h] [rbp-38h] BYREF
  __m128i v10; // [rsp+90h] [rbp-28h] BYREF
  __m128i v11; // [rsp+A0h] [rbp-18h] BYREF
  char v12; // [rsp+C8h] [rbp+10h] BYREF

  v12 = a2;
  v3 = _mm_loadu_si128(a1);
  v4 = _mm_shuffle_epi32(_mm_load_si128(&v3), 78);
  v5 = _mm_load_si128(&v4);
  v6 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024D50((__int64)&v12, &v10, &v6, &v5));
  v7 = _mm_shuffle_epi32(_mm_load_si128(&v3), 177);
  v8 = _mm_load_si128(&v7);
  v9 = _mm_load_si128(&v3);
  v3 = _mm_loadu_si128(sub_140024D50((__int64)&v12, &v11, &v9, &v8));
  return _mm_load_si128(&v3);
}
// 140019880: using guessed type __m128i var_18;

//----- (0000000140019990) ----------------------------------------------------
__m128i __fastcall sub_140019990(const __m128i *a1, char a2)
{
  __m128i v2; // xmm0
  __m128i v4; // [rsp+20h] [rbp-58h] BYREF
  __m128i v5; // [rsp+30h] [rbp-48h] BYREF
  __m128i v6; // [rsp+40h] [rbp-38h] BYREF
  __m128i v7; // [rsp+50h] [rbp-28h] BYREF
  __m128i v8; // [rsp+60h] [rbp-18h] BYREF
  char v10; // [rsp+88h] [rbp+10h] BYREF

  v10 = a2;
  v5 = _mm_loadu_si128(a1);
  v4.m128i_i64[0] = sub_140025330(&v5);
  v6 = _mm_srli_si128(_mm_loadu_si128(a1), 8);
  v7 = _mm_load_si128(&v6);
  v4.m128i_i64[1] = sub_140025330(&v7);
  if ( sub_140024DB0((__int64)&v10, v4.m128i_u64[1], v4.m128i_u64[0]) )
    v4.m128i_i64[0] = v4.m128i_i64[1];
  v2 = _mm_loadl_epi64(&v4);
  v8 = _mm_unpacklo_epi64(v2, v2);
  return _mm_load_si128(&v8);
}
// 140019990: using guessed type __m128i var_18;

//----- (0000000140019A60) ----------------------------------------------------
_BYTE *__fastcall sub_140019A60(_BYTE *a1, _BYTE *a2, _BYTE *a3, char a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < (char)*a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019AF0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_140019AF0(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int8 a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < (int)*a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019B80) ----------------------------------------------------
_WORD *__fastcall sub_140019B80(_WORD *a1, _WORD *a2, _WORD *a3, __int16 a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < (__int16)*a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019C10) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140019C10(
        unsigned __int16 *a1,
        unsigned __int16 *a2,
        unsigned __int16 *a3,
        unsigned __int16 a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < (int)*a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019CA0) ----------------------------------------------------
_DWORD *__fastcall sub_140019CA0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < *a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019D20) ----------------------------------------------------
unsigned int *__fastcall sub_140019D20(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < *a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019DA0) ----------------------------------------------------
_QWORD *__fastcall sub_140019DA0(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < *a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019E30) ----------------------------------------------------
unsigned __int64 *__fastcall sub_140019E30(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 a4)
{
  while ( a1 != a2 )
  {
    if ( a4 < *a1 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019EC0) ----------------------------------------------------
char *__fastcall sub_140019EC0(char *a1, char *a2, char *a3, char a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019F50) ----------------------------------------------------
unsigned __int8 *__fastcall sub_140019F50(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int8 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < (int)a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (0000000140019FE0) ----------------------------------------------------
__int16 *__fastcall sub_140019FE0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (000000014001A070) ----------------------------------------------------
unsigned __int16 *__fastcall sub_14001A070(
        unsigned __int16 *a1,
        unsigned __int16 *a2,
        unsigned __int16 *a3,
        unsigned __int16 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < (int)a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (000000014001A100) ----------------------------------------------------
_DWORD *__fastcall sub_14001A100(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (000000014001A180) ----------------------------------------------------
unsigned int *__fastcall sub_14001A180(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (000000014001A200) ----------------------------------------------------
_QWORD *__fastcall sub_14001A200(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (000000014001A290) ----------------------------------------------------
unsigned __int64 *__fastcall sub_14001A290(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 a4)
{
  while ( a1 != a2 )
  {
    if ( *a1 < a4 )
    {
      a3 = a1;
      a4 = *a1;
    }
    ++a1;
  }
  return a3;
}

//----- (000000014001A320) ----------------------------------------------------
__int64 __fastcall sub_14001A320(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  signed __int8 v15; // [rsp+30h] [rbp-318h]
  signed __int8 v16; // [rsp+31h] [rbp-317h]
  unsigned __int8 v17; // [rsp+32h] [rbp-316h]
  unsigned __int64 v18; // [rsp+38h] [rbp-310h]
  unsigned __int64 v19; // [rsp+38h] [rbp-310h]
  int v20; // [rsp+40h] [rbp-308h]
  unsigned int v21; // [rsp+44h] [rbp-304h]
  const __m128i *v22; // [rsp+48h] [rbp-300h] BYREF
  __m128i v23; // [rsp+50h] [rbp-2F8h] BYREF
  __m128i si128; // [rsp+60h] [rbp-2E8h] BYREF
  const __m128i *v25; // [rsp+70h] [rbp-2D8h]
  __m128i v26; // [rsp+80h] [rbp-2C8h] BYREF
  __m128i v27; // [rsp+90h] [rbp-2B8h] BYREF
  __int64 v28[2]; // [rsp+A0h] [rbp-2A8h] BYREF
  __m128i v29; // [rsp+B0h] [rbp-298h] BYREF
  __m128i v30; // [rsp+C0h] [rbp-288h] BYREF
  __m128i v31; // [rsp+D0h] [rbp-278h] BYREF
  __m128i v32; // [rsp+E0h] [rbp-268h] BYREF
  __int64 v33; // [rsp+F0h] [rbp-258h]
  __int64 v34; // [rsp+F8h] [rbp-250h]
  __m128i v35; // [rsp+100h] [rbp-248h] BYREF
  __m128i v36; // [rsp+110h] [rbp-238h] BYREF
  __m128i v37; // [rsp+120h] [rbp-228h] BYREF
  __m128i v38; // [rsp+130h] [rbp-218h] BYREF
  __m128i v39; // [rsp+140h] [rbp-208h] BYREF
  __m128i v40; // [rsp+150h] [rbp-1F8h] BYREF
  __m128i v41; // [rsp+160h] [rbp-1E8h] BYREF
  __m128i v42; // [rsp+170h] [rbp-1D8h] BYREF
  __m128i v43; // [rsp+180h] [rbp-1C8h] BYREF
  __m128i v44; // [rsp+190h] [rbp-1B8h] BYREF
  __m128i v45; // [rsp+1A0h] [rbp-1A8h] BYREF
  __m128i v46; // [rsp+1B0h] [rbp-198h] BYREF
  __m128i v47; // [rsp+1C0h] [rbp-188h] BYREF
  __m128i v48; // [rsp+1D0h] [rbp-178h] BYREF
  __m128i v49; // [rsp+1E0h] [rbp-168h] BYREF
  __m128i v50; // [rsp+1F0h] [rbp-158h] BYREF
  __m128i v51; // [rsp+200h] [rbp-148h] BYREF
  __m128i v52; // [rsp+210h] [rbp-138h] BYREF
  __m128i v53; // [rsp+220h] [rbp-128h] BYREF
  __m128i v54; // [rsp+230h] [rbp-118h] BYREF
  __m128i v55; // [rsp+240h] [rbp-108h] BYREF
  __m128i v56; // [rsp+250h] [rbp-F8h] BYREF
  __m128i v57; // [rsp+260h] [rbp-E8h] BYREF
  __m128i v58; // [rsp+270h] [rbp-D8h] BYREF
  __m128i v59; // [rsp+280h] [rbp-C8h] BYREF
  __m128i v60; // [rsp+290h] [rbp-B8h] BYREF
  __m128i v61; // [rsp+2A0h] [rbp-A8h] BYREF
  __m128i v62; // [rsp+2B0h] [rbp-98h] BYREF
  __m128i v63; // [rsp+2C0h] [rbp-88h] BYREF
  __m128i v64; // [rsp+2D0h] [rbp-78h] BYREF
  __m128i v65; // [rsp+2E0h] [rbp-68h] BYREF
  __m128i v66; // [rsp+2F0h] [rbp-58h] BYREF
  __m128i v67; // [rsp+300h] [rbp-48h] BYREF
  __m128i v68[3]; // [rsp+310h] [rbp-38h] BYREF
  const __m128i *v69; // [rsp+350h] [rbp+8h] BYREF
  __int64 v70; // [rsp+358h] [rbp+10h]
  unsigned __int8 v71; // [rsp+360h] [rbp+18h]

  v71 = a3;
  v70 = a2;
  v69 = a1;
  v28[0] = (__int64)a1;
  v28[1] = (__int64)a1;
  v25 = a1;
  v15 = 127;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v18 = sub_140024E60(v69, v70) & 0xFFFFFFFFFFFFFFF0ui64;
    v33 = 4096i64;
    if ( v18 > 0x1000 )
      v18 = 4096i64;
    v22 = v69;
    sub_140024E30(&v22, v18);
    v35 = _mm_loadu_si128(v69);
    v3 = _mm_load_si128(&v35);
    v36 = v3;
    *(double *)v3.m128i_i64 = sub_140025F90(&v36, v71);
    v23 = v3;
    si128 = _mm_load_si128(&v23);
    v37 = 0i64;
    v26 = _mm_load_si128(&v37);
    v68[1] = _mm_load_si128(&v23);
    v38 = 0i64;
    v68[2] = _mm_load_si128(&v38);
    v39 = 0i64;
    v27 = _mm_load_si128(&v39);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v69, 16i64);
        v4 = _mm_load_si128(&v27);
        v40 = v4;
        *(double *)v4.m128i_i64 = sub_1400259A0(&v40);
        v41 = v4;
        v27 = _mm_load_si128(&v41);
        if ( v69 == v22 )
          break;
        v59 = _mm_loadu_si128(v69);
        v11 = _mm_load_si128(&v59);
        v60 = v11;
        *(double *)v11.m128i_i64 = sub_140025F90(&v60, v71);
        v61 = v11;
        v23 = _mm_load_si128(&v61);
        v62 = _mm_load_si128(&v23);
        v12 = _mm_load_si128(&si128);
        v63 = v12;
        *(double *)v12.m128i_i64 = sub_1400250D0(&v63, &v62);
        v30 = v12;
        v64 = _mm_blendv_epi8(_mm_load_si128(&v26), v27, _mm_load_si128(&v30));
        v26 = _mm_load_si128(&v64);
        v65 = _mm_load_si128(&v30);
        v66 = _mm_load_si128(&v23);
        v13 = _mm_load_si128(&si128);
        v67 = v13;
        *(double *)v13.m128i_i64 = sub_140025C30(&v67, &v66, &v65);
        v68[0] = v13;
        si128 = _mm_load_si128(v68);
      }
      v5 = _mm_load_si128(&si128);
      v42 = v5;
      *(double *)v5.m128i_i64 = sub_140025720(&v42);
      v31 = v5;
      v43 = _mm_load_si128(&v31);
      v16 = sub_1400252D0(&v43);
      if ( v16 < v15 )
      {
        v15 = v16;
        v44 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v31);
        v45 = v6;
        *(double *)v6.m128i_i64 = sub_140024FD0(&v45, &v44);
        v32 = v6;
        v20 = _mm_movemask_epi8(_mm_load_si128(&v32));
        v46 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v47 = _mm_load_si128(&v46);
        v48 = _mm_blendv_epi8(_mm_load_si128(&v47), v26, _mm_load_si128(&v32));
        v29 = _mm_load_si128(&v48);
        v7 = _mm_load_si128(&v29);
        v49 = v7;
        *(double *)v7.m128i_i64 = sub_140025860(&v49);
        v50 = v7;
        v51 = _mm_load_si128(&v29);
        v8 = _mm_load_si128(&v50);
        v52 = v8;
        *(double *)v8.m128i_i64 = sub_140024FD0(&v52, &v51);
        v53 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v53)) & v20);
        v21 = v9;
        v54 = _mm_load_si128(&v26);
        v17 = sub_140025350(&v54, v9);
        v28[0] = (__int64)v25[v17].m128i_i64 + v21;
      }
      v19 = sub_140024E60(v69, v70) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v19 )
        break;
      v34 = 4096i64;
      if ( v19 > 0x1000 )
        v19 = 4096i64;
      sub_140024E30(&v22, v19);
      v25 = v69;
      v55 = _mm_loadu_si128(v69);
      v10 = _mm_load_si128(&v55);
      v56 = v10;
      *(double *)v10.m128i_i64 = sub_140025F90(&v56, v71);
      v57 = v10;
      v23 = _mm_load_si128(&v57);
      si128 = _mm_load_si128(&v23);
      v58 = 0i64;
      v26 = _mm_load_si128(&v58);
    }
  }
  return sub_140020F80((__int64)v69, v70, v28, v71, v15);
}
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140024FD0: using guessed type double __fastcall sub_140024FD0(_QWORD, _QWORD);
// 1400250D0: using guessed type double __fastcall sub_1400250D0(_QWORD, _QWORD);
// 1400252D0: using guessed type __int64 __fastcall sub_1400252D0(_QWORD);
// 140025350: using guessed type __int64 __fastcall sub_140025350(_QWORD, _QWORD);
// 140025720: using guessed type double __fastcall sub_140025720(_QWORD);
// 140025860: using guessed type double __fastcall sub_140025860(_QWORD);
// 1400259A0: using guessed type double __fastcall sub_1400259A0(_QWORD);
// 140025C30: using guessed type double __fastcall sub_140025C30(_QWORD, _QWORD, _QWORD);
// 140025F90: using guessed type double __fastcall sub_140025F90(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001AAF0) ----------------------------------------------------
__int64 __fastcall sub_14001AAF0(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __int16 v15; // [rsp+30h] [rbp-328h]
  __int16 v16; // [rsp+34h] [rbp-324h]
  unsigned __int64 v17; // [rsp+38h] [rbp-320h]
  unsigned __int64 v18; // [rsp+38h] [rbp-320h]
  unsigned __int16 v19; // [rsp+40h] [rbp-318h]
  int v20; // [rsp+48h] [rbp-310h]
  unsigned int v21; // [rsp+4Ch] [rbp-30Ch]
  __int64 v22[2]; // [rsp+50h] [rbp-308h] BYREF
  __m128i v23; // [rsp+60h] [rbp-2F8h] BYREF
  __m128i si128; // [rsp+70h] [rbp-2E8h] BYREF
  const __m128i *v25; // [rsp+80h] [rbp-2D8h]
  __m128i v26; // [rsp+90h] [rbp-2C8h] BYREF
  __m128i v27; // [rsp+A0h] [rbp-2B8h] BYREF
  __int64 v28[2]; // [rsp+B0h] [rbp-2A8h] BYREF
  __m128i v29; // [rsp+C0h] [rbp-298h] BYREF
  __m128i v30; // [rsp+D0h] [rbp-288h] BYREF
  __m128i v31; // [rsp+E0h] [rbp-278h] BYREF
  __m128i v32; // [rsp+F0h] [rbp-268h] BYREF
  __int64 v33; // [rsp+100h] [rbp-258h]
  __int64 v34; // [rsp+108h] [rbp-250h]
  __m128i v35; // [rsp+110h] [rbp-248h] BYREF
  __m128i v36; // [rsp+120h] [rbp-238h] BYREF
  __m128i v37; // [rsp+130h] [rbp-228h] BYREF
  __m128i v38; // [rsp+140h] [rbp-218h] BYREF
  __m128i v39; // [rsp+150h] [rbp-208h] BYREF
  __m128i v40; // [rsp+160h] [rbp-1F8h] BYREF
  __m128i v41; // [rsp+170h] [rbp-1E8h] BYREF
  __m128i v42; // [rsp+180h] [rbp-1D8h] BYREF
  __m128i v43; // [rsp+190h] [rbp-1C8h] BYREF
  __m128i v44; // [rsp+1A0h] [rbp-1B8h] BYREF
  __m128i v45; // [rsp+1B0h] [rbp-1A8h] BYREF
  __m128i v46; // [rsp+1C0h] [rbp-198h] BYREF
  __m128i v47; // [rsp+1D0h] [rbp-188h] BYREF
  __m128i v48; // [rsp+1E0h] [rbp-178h] BYREF
  __m128i v49; // [rsp+1F0h] [rbp-168h] BYREF
  __m128i v50; // [rsp+200h] [rbp-158h] BYREF
  __m128i v51; // [rsp+210h] [rbp-148h] BYREF
  __m128i v52; // [rsp+220h] [rbp-138h] BYREF
  __m128i v53; // [rsp+230h] [rbp-128h] BYREF
  __m128i v54; // [rsp+240h] [rbp-118h] BYREF
  __m128i v55; // [rsp+250h] [rbp-108h] BYREF
  __m128i v56; // [rsp+260h] [rbp-F8h] BYREF
  __m128i v57; // [rsp+270h] [rbp-E8h] BYREF
  __m128i v58; // [rsp+280h] [rbp-D8h] BYREF
  __m128i v59; // [rsp+290h] [rbp-C8h] BYREF
  __m128i v60; // [rsp+2A0h] [rbp-B8h] BYREF
  __m128i v61; // [rsp+2B0h] [rbp-A8h] BYREF
  __m128i v62; // [rsp+2C0h] [rbp-98h] BYREF
  __m128i v63; // [rsp+2D0h] [rbp-88h] BYREF
  __m128i v64; // [rsp+2E0h] [rbp-78h] BYREF
  __m128i v65; // [rsp+2F0h] [rbp-68h] BYREF
  __m128i v66; // [rsp+300h] [rbp-58h] BYREF
  __m128i v67; // [rsp+310h] [rbp-48h] BYREF
  __m128i v68[3]; // [rsp+320h] [rbp-38h] BYREF
  const __m128i *v69; // [rsp+360h] [rbp+8h] BYREF
  __int64 v70; // [rsp+368h] [rbp+10h]
  unsigned __int8 v71; // [rsp+370h] [rbp+18h]

  v71 = a3;
  v70 = a2;
  v69 = a1;
  v28[0] = (__int64)a1;
  v28[1] = (__int64)a1;
  v25 = a1;
  v15 = 0x7FFF;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v17 = sub_140024E60(v69, v70) & 0xFFFFFFFFFFFFFFF0ui64;
    v33 = 0x100000i64;
    if ( v17 > 0x100000 )
      v17 = 0x100000i64;
    v22[0] = (__int64)v69;
    sub_140024E30(v22, v17);
    v35 = _mm_loadu_si128(v69);
    v3 = _mm_load_si128(&v35);
    v36 = v3;
    *(double *)v3.m128i_i64 = sub_140025FF0(&v36, v71);
    v23 = v3;
    si128 = _mm_load_si128(&v23);
    v37 = 0i64;
    v26 = _mm_load_si128(&v37);
    v68[1] = _mm_load_si128(&v23);
    v38 = 0i64;
    v68[2] = _mm_load_si128(&v38);
    v39 = 0i64;
    v27 = _mm_load_si128(&v39);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v69, 16i64);
        v4 = _mm_load_si128(&v27);
        v40 = v4;
        *(double *)v4.m128i_i64 = sub_1400259F0(&v40);
        v41 = v4;
        v27 = _mm_load_si128(&v41);
        if ( v69 == (const __m128i *)v22[0] )
          break;
        v59 = _mm_loadu_si128(v69);
        v11 = _mm_load_si128(&v59);
        v60 = v11;
        *(double *)v11.m128i_i64 = sub_140025FF0(&v60, v71);
        v61 = v11;
        v23 = _mm_load_si128(&v61);
        v62 = _mm_load_si128(&v23);
        v12 = _mm_load_si128(&si128);
        v63 = v12;
        *(double *)v12.m128i_i64 = sub_140025110(&v63, &v62);
        v30 = v12;
        v64 = _mm_blendv_epi8(_mm_load_si128(&v26), v27, _mm_load_si128(&v30));
        v26 = _mm_load_si128(&v64);
        v65 = _mm_load_si128(&v30);
        v66 = _mm_load_si128(&v23);
        v13 = _mm_load_si128(&si128);
        v67 = v13;
        *(double *)v13.m128i_i64 = sub_140025C80(&v67, &v66, &v65);
        v68[0] = v13;
        si128 = _mm_load_si128(v68);
      }
      v5 = _mm_load_si128(&si128);
      v42 = v5;
      *(double *)v5.m128i_i64 = sub_140025770(&v42);
      v31 = v5;
      v43 = _mm_load_si128(&v31);
      v16 = sub_1400252F0(&v43);
      if ( v16 < v15 )
      {
        v15 = v16;
        v44 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v31);
        v45 = v6;
        *(double *)v6.m128i_i64 = sub_140025010(&v45, &v44);
        v32 = v6;
        v20 = _mm_movemask_epi8(_mm_load_si128(&v32));
        v46 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v47 = _mm_load_si128(&v46);
        v48 = _mm_blendv_epi8(_mm_load_si128(&v47), v26, _mm_load_si128(&v32));
        v29 = _mm_load_si128(&v48);
        v7 = _mm_load_si128(&v29);
        v49 = v7;
        *(double *)v7.m128i_i64 = sub_1400258B0(&v49);
        v50 = v7;
        v51 = _mm_load_si128(&v29);
        v8 = _mm_load_si128(&v50);
        v52 = v8;
        *(double *)v8.m128i_i64 = sub_140025010(&v52, &v51);
        v53 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v53)) & v20);
        v21 = v9;
        v54 = _mm_load_si128(&v26);
        v19 = sub_1400253A0(&v54, v9);
        v28[0] = (__int64)v25[v19].m128i_i64 + v21;
      }
      v18 = sub_140024E60(v69, v70) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v18 )
        break;
      v34 = 0x100000i64;
      if ( v18 > 0x100000 )
        v18 = 0x100000i64;
      sub_140024E30(v22, v18);
      v25 = v69;
      v55 = _mm_loadu_si128(v69);
      v10 = _mm_load_si128(&v55);
      v56 = v10;
      *(double *)v10.m128i_i64 = sub_140025FF0(&v56, v71);
      v57 = v10;
      v23 = _mm_load_si128(&v57);
      si128 = _mm_load_si128(&v23);
      v58 = 0i64;
      v26 = _mm_load_si128(&v58);
    }
  }
  return sub_140021010((_DWORD)v69, v70, (unsigned int)v28, v71, v15);
}
// 140021010: using guessed type __int64 __fastcall sub_140021010(_DWORD, _DWORD, _DWORD, _DWORD, __int16);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025010: using guessed type double __fastcall sub_140025010(_QWORD, _QWORD);
// 140025110: using guessed type double __fastcall sub_140025110(_QWORD, _QWORD);
// 1400252F0: using guessed type __int64 __fastcall sub_1400252F0(_QWORD);
// 1400253A0: using guessed type __int64 __fastcall sub_1400253A0(_QWORD, _QWORD);
// 140025770: using guessed type double __fastcall sub_140025770(_QWORD);
// 1400258B0: using guessed type double __fastcall sub_1400258B0(_QWORD);
// 1400259F0: using guessed type double __fastcall sub_1400259F0(_QWORD);
// 140025C80: using guessed type double __fastcall sub_140025C80(_QWORD, _QWORD, _QWORD);
// 140025FF0: using guessed type double __fastcall sub_140025FF0(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001B2E0) ----------------------------------------------------
__int64 __fastcall sub_14001B2E0(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  unsigned __int64 v15; // [rsp+30h] [rbp-328h]
  unsigned __int64 v16; // [rsp+30h] [rbp-328h]
  int v17; // [rsp+38h] [rbp-320h]
  int v18; // [rsp+3Ch] [rbp-31Ch]
  int v19; // [rsp+40h] [rbp-318h]
  unsigned int v20; // [rsp+44h] [rbp-314h]
  int v21; // [rsp+48h] [rbp-310h]
  __int64 v22[2]; // [rsp+50h] [rbp-308h] BYREF
  __m128i v23; // [rsp+60h] [rbp-2F8h] BYREF
  __m128i si128; // [rsp+70h] [rbp-2E8h] BYREF
  const __m128i *v25; // [rsp+80h] [rbp-2D8h]
  __m128i v26; // [rsp+90h] [rbp-2C8h] BYREF
  __m128i v27; // [rsp+A0h] [rbp-2B8h] BYREF
  __int64 v28[2]; // [rsp+B0h] [rbp-2A8h] BYREF
  __m128i v29; // [rsp+C0h] [rbp-298h] BYREF
  __m128i v30; // [rsp+D0h] [rbp-288h] BYREF
  __m128i v31; // [rsp+E0h] [rbp-278h] BYREF
  __m128i v32; // [rsp+F0h] [rbp-268h] BYREF
  __int64 v33; // [rsp+100h] [rbp-258h]
  __int64 v34; // [rsp+108h] [rbp-250h]
  __m128i v35; // [rsp+110h] [rbp-248h] BYREF
  __m128i v36; // [rsp+120h] [rbp-238h] BYREF
  __m128i v37; // [rsp+130h] [rbp-228h] BYREF
  __m128i v38; // [rsp+140h] [rbp-218h] BYREF
  __m128i v39; // [rsp+150h] [rbp-208h] BYREF
  __m128i v40; // [rsp+160h] [rbp-1F8h] BYREF
  __m128i v41; // [rsp+170h] [rbp-1E8h] BYREF
  __m128i v42; // [rsp+180h] [rbp-1D8h] BYREF
  __m128i v43; // [rsp+190h] [rbp-1C8h] BYREF
  __m128i v44; // [rsp+1A0h] [rbp-1B8h] BYREF
  __m128i v45; // [rsp+1B0h] [rbp-1A8h] BYREF
  __m128i v46; // [rsp+1C0h] [rbp-198h] BYREF
  __m128i v47; // [rsp+1D0h] [rbp-188h] BYREF
  __m128i v48; // [rsp+1E0h] [rbp-178h] BYREF
  __m128i v49; // [rsp+1F0h] [rbp-168h] BYREF
  __m128i v50; // [rsp+200h] [rbp-158h] BYREF
  __m128i v51; // [rsp+210h] [rbp-148h] BYREF
  __m128i v52; // [rsp+220h] [rbp-138h] BYREF
  __m128i v53; // [rsp+230h] [rbp-128h] BYREF
  __m128i v54; // [rsp+240h] [rbp-118h] BYREF
  __m128i v55; // [rsp+250h] [rbp-108h] BYREF
  __m128i v56; // [rsp+260h] [rbp-F8h] BYREF
  __m128i v57; // [rsp+270h] [rbp-E8h] BYREF
  __m128i v58; // [rsp+280h] [rbp-D8h] BYREF
  __m128i v59; // [rsp+290h] [rbp-C8h] BYREF
  __m128i v60; // [rsp+2A0h] [rbp-B8h] BYREF
  __m128i v61; // [rsp+2B0h] [rbp-A8h] BYREF
  __m128i v62; // [rsp+2C0h] [rbp-98h] BYREF
  __m128i v63; // [rsp+2D0h] [rbp-88h] BYREF
  __m128i v64; // [rsp+2E0h] [rbp-78h] BYREF
  __m128i v65; // [rsp+2F0h] [rbp-68h] BYREF
  __m128i v66; // [rsp+300h] [rbp-58h] BYREF
  __m128i v67; // [rsp+310h] [rbp-48h] BYREF
  __m128i v68[3]; // [rsp+320h] [rbp-38h] BYREF
  const __m128i *v69; // [rsp+360h] [rbp+8h] BYREF
  __int64 v70; // [rsp+368h] [rbp+10h]
  unsigned __int8 v71; // [rsp+370h] [rbp+18h]

  v71 = a3;
  v70 = a2;
  v69 = a1;
  v28[0] = (__int64)a1;
  v28[1] = (__int64)a1;
  v25 = a1;
  v18 = 0x7FFFFFFF;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v15 = sub_140024E60(v69, v70) & 0xFFFFFFFFFFFFFFF0ui64;
    v33 = 0x1000000000i64;
    if ( v15 > 0x1000000000i64 )
      v15 = 0x1000000000i64;
    v22[0] = (__int64)v69;
    sub_140024E30(v22, v15);
    v35 = _mm_loadu_si128(v69);
    v3 = _mm_load_si128(&v35);
    v36 = v3;
    *(double *)v3.m128i_i64 = sub_140026050(&v36, v71);
    v23 = v3;
    si128 = _mm_load_si128(&v23);
    v37 = 0i64;
    v26 = _mm_load_si128(&v37);
    v68[1] = _mm_load_si128(&v23);
    v38 = 0i64;
    v68[2] = _mm_load_si128(&v38);
    v39 = 0i64;
    v27 = _mm_load_si128(&v39);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v69, 16i64);
        v4 = _mm_load_si128(&v27);
        v40 = v4;
        *(double *)v4.m128i_i64 = sub_140025A40(&v40);
        v41 = v4;
        v27 = _mm_load_si128(&v41);
        if ( v69 == (const __m128i *)v22[0] )
          break;
        v59 = _mm_loadu_si128(v69);
        v11 = _mm_load_si128(&v59);
        v60 = v11;
        *(double *)v11.m128i_i64 = sub_140026050(&v60, v71);
        v61 = v11;
        v23 = _mm_load_si128(&v61);
        v62 = _mm_load_si128(&v23);
        v12 = _mm_load_si128(&si128);
        v63 = v12;
        *(double *)v12.m128i_i64 = sub_140025150(&v63, &v62);
        v30 = v12;
        v64 = _mm_blendv_epi8(_mm_load_si128(&v26), v27, _mm_load_si128(&v30));
        v26 = _mm_load_si128(&v64);
        v65 = _mm_load_si128(&v30);
        v66 = _mm_load_si128(&v23);
        v13 = _mm_load_si128(&si128);
        v67 = v13;
        *(double *)v13.m128i_i64 = sub_140025CD0(&v67, &v66, &v65);
        v68[0] = v13;
        si128 = _mm_load_si128(v68);
      }
      v5 = _mm_load_si128(&si128);
      v42 = v5;
      *(double *)v5.m128i_i64 = sub_1400257C0(&v42);
      v31 = v5;
      v43 = _mm_load_si128(&v31);
      v19 = sub_140025310(&v43);
      if ( v19 < v18 )
      {
        v18 = v19;
        v44 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v31);
        v45 = v6;
        *(double *)v6.m128i_i64 = sub_140025050(&v45, &v44);
        v32 = v6;
        v17 = _mm_movemask_epi8(_mm_load_si128(&v32));
        v46 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v47 = _mm_load_si128(&v46);
        v48 = _mm_blendv_epi8(_mm_load_si128(&v47), v26, _mm_load_si128(&v32));
        v29 = _mm_load_si128(&v48);
        v7 = _mm_load_si128(&v29);
        v49 = v7;
        *(double *)v7.m128i_i64 = sub_140025900(&v49);
        v50 = v7;
        v51 = _mm_load_si128(&v29);
        v8 = _mm_load_si128(&v50);
        v52 = v8;
        *(double *)v8.m128i_i64 = sub_140025050(&v52, &v51);
        v53 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v53)) & v17);
        v20 = v9;
        v54 = _mm_load_si128(&v26);
        v21 = sub_140025400(&v54, v9);
        v28[0] = (__int64)v25->m128i_i64 + 16 * v21 + v20;
      }
      v16 = sub_140024E60(v69, v70) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v16 )
        break;
      v34 = 0x1000000000i64;
      if ( v16 > 0x1000000000i64 )
        v16 = 0x1000000000i64;
      sub_140024E30(v22, v16);
      v25 = v69;
      v55 = _mm_loadu_si128(v69);
      v10 = _mm_load_si128(&v55);
      v56 = v10;
      *(double *)v10.m128i_i64 = sub_140026050(&v56, v71);
      v57 = v10;
      v23 = _mm_load_si128(&v57);
      si128 = _mm_load_si128(&v23);
      v58 = 0i64;
      v26 = _mm_load_si128(&v58);
    }
  }
  return sub_1400210B0((_DWORD)v69, v70, (unsigned int)v28, v71, v18);
}
// 1400210B0: using guessed type __int64 __fastcall sub_1400210B0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025050: using guessed type double __fastcall sub_140025050(_QWORD, _QWORD);
// 140025150: using guessed type double __fastcall sub_140025150(_QWORD, _QWORD);
// 140025310: using guessed type __int64 __fastcall sub_140025310(_QWORD);
// 140025400: using guessed type __int64 __fastcall sub_140025400(_QWORD, _QWORD);
// 1400257C0: using guessed type double __fastcall sub_1400257C0(_QWORD);
// 140025900: using guessed type double __fastcall sub_140025900(_QWORD);
// 140025A40: using guessed type double __fastcall sub_140025A40(_QWORD);
// 140025CD0: using guessed type double __fastcall sub_140025CD0(_QWORD, _QWORD, _QWORD);
// 140026050: using guessed type double __fastcall sub_140026050(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001BAE0) ----------------------------------------------------
__int64 __fastcall sub_14001BAE0(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  int v14; // [rsp+30h] [rbp-2D8h]
  unsigned int v15; // [rsp+34h] [rbp-2D4h]
  __int64 v16; // [rsp+38h] [rbp-2D0h]
  const __m128i *v17; // [rsp+40h] [rbp-2C8h] BYREF
  __int64 v18; // [rsp+48h] [rbp-2C0h]
  __m128i v19; // [rsp+50h] [rbp-2B8h] BYREF
  __m128i si128; // [rsp+60h] [rbp-2A8h] BYREF
  __m128i v21; // [rsp+70h] [rbp-298h] BYREF
  unsigned __int64 v22; // [rsp+80h] [rbp-288h]
  __int64 v23; // [rsp+88h] [rbp-280h]
  const __m128i *v24; // [rsp+90h] [rbp-278h]
  __int64 v25; // [rsp+98h] [rbp-270h]
  __m128i v26; // [rsp+A0h] [rbp-268h] BYREF
  __int64 v27[2]; // [rsp+B0h] [rbp-258h] BYREF
  __m128i v28; // [rsp+C0h] [rbp-248h] BYREF
  __m128i v29; // [rsp+D0h] [rbp-238h] BYREF
  __m128i v30; // [rsp+E0h] [rbp-228h] BYREF
  __m128i v31; // [rsp+F0h] [rbp-218h] BYREF
  __m128i v32; // [rsp+100h] [rbp-208h] BYREF
  __m128i v33; // [rsp+110h] [rbp-1F8h] BYREF
  __m128i v34; // [rsp+120h] [rbp-1E8h] BYREF
  __m128i v35; // [rsp+130h] [rbp-1D8h] BYREF
  __m128i v36; // [rsp+140h] [rbp-1C8h] BYREF
  __m128i v37; // [rsp+150h] [rbp-1B8h] BYREF
  __m128i v38; // [rsp+160h] [rbp-1A8h] BYREF
  __m128i v39; // [rsp+170h] [rbp-198h] BYREF
  __m128i v40; // [rsp+180h] [rbp-188h] BYREF
  __m128i v41; // [rsp+190h] [rbp-178h] BYREF
  __m128i v42; // [rsp+1A0h] [rbp-168h] BYREF
  __m128i v43; // [rsp+1B0h] [rbp-158h] BYREF
  __m128i v44; // [rsp+1C0h] [rbp-148h] BYREF
  __m128i v45; // [rsp+1D0h] [rbp-138h] BYREF
  __m128i v46; // [rsp+1E0h] [rbp-128h] BYREF
  __m128i v47; // [rsp+1F0h] [rbp-118h] BYREF
  __m128i v48; // [rsp+200h] [rbp-108h] BYREF
  __m128i v49; // [rsp+210h] [rbp-F8h] BYREF
  __m128i v50; // [rsp+220h] [rbp-E8h] BYREF
  __m128i v51; // [rsp+230h] [rbp-D8h] BYREF
  __m128i v52; // [rsp+240h] [rbp-C8h] BYREF
  __m128i v53; // [rsp+250h] [rbp-B8h] BYREF
  __m128i v54; // [rsp+260h] [rbp-A8h] BYREF
  __m128i v55; // [rsp+270h] [rbp-98h] BYREF
  __m128i v56; // [rsp+280h] [rbp-88h] BYREF
  __m128i v57; // [rsp+290h] [rbp-78h] BYREF
  __m128i v58; // [rsp+2A0h] [rbp-68h] BYREF
  __m128i v59; // [rsp+2B0h] [rbp-58h] BYREF
  __m128i v60; // [rsp+2C0h] [rbp-48h] BYREF
  __m128i v61[3]; // [rsp+2D0h] [rbp-38h] BYREF
  const __m128i *v62; // [rsp+310h] [rbp+8h] BYREF
  __int64 v63; // [rsp+318h] [rbp+10h]
  unsigned __int8 v64; // [rsp+320h] [rbp+18h]

  v64 = a3;
  v63 = a2;
  v62 = a1;
  v27[0] = (__int64)a1;
  v27[1] = (__int64)a1;
  v24 = a1;
  v16 = 0x7FFFFFFFFFFFFFFFi64;
  v25 = 0x8000000000000000ui64;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 )
  {
    if ( (unsigned __int8)sub_1400261D0() )
    {
      v22 = sub_140024E60(v62, v63) & 0xFFFFFFFFFFFFFFF0ui64;
      v17 = v62;
      sub_140024E30(&v17, v22);
      v32 = _mm_loadu_si128(v62);
      v3 = _mm_load_si128(&v32);
      v33 = v3;
      *(double *)v3.m128i_i64 = sub_1400260B0(&v33, v64);
      v19 = v3;
      si128 = _mm_load_si128(&v19);
      v34 = 0i64;
      v21 = _mm_load_si128(&v34);
      v61[1] = _mm_load_si128(&v19);
      v35 = 0i64;
      v61[2] = _mm_load_si128(&v35);
      v36 = 0i64;
      v26 = _mm_load_si128(&v36);
      while ( 1 )
      {
        sub_140024E30(&v62, 16i64);
        v4 = _mm_load_si128(&v26);
        v37 = v4;
        *(double *)v4.m128i_i64 = sub_140025A90(&v37);
        v38 = v4;
        v26 = _mm_load_si128(&v38);
        if ( v62 == v17 )
          break;
        v52 = _mm_loadu_si128(v62);
        v10 = _mm_load_si128(&v52);
        v53 = v10;
        *(double *)v10.m128i_i64 = sub_1400260B0(&v53, v64);
        v54 = v10;
        v19 = _mm_load_si128(&v54);
        v55 = _mm_load_si128(&v19);
        v11 = _mm_load_si128(&si128);
        v56 = v11;
        *(double *)v11.m128i_i64 = sub_140025190(&v56, &v55);
        v31 = v11;
        v57 = _mm_blendv_epi8(_mm_load_si128(&v21), v26, _mm_load_si128(&v31));
        v21 = _mm_load_si128(&v57);
        v58 = _mm_load_si128(&v31);
        v59 = _mm_load_si128(&v19);
        v12 = _mm_load_si128(&si128);
        v60 = v12;
        *(double *)v12.m128i_i64 = sub_140025D20(&v60, &v59, &v58);
        v61[0] = v12;
        si128 = _mm_load_si128(v61);
      }
      v5 = _mm_load_si128(&si128);
      v39 = v5;
      *(double *)v5.m128i_i64 = sub_140025810(&v39);
      v28 = v5;
      v40 = _mm_load_si128(&v28);
      v18 = sub_140025330(&v40);
      if ( v18 != 0x7FFFFFFFFFFFFFFFi64 )
      {
        v16 = v18;
        v41 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v28);
        v42 = v6;
        *(double *)v6.m128i_i64 = sub_140025090(&v42, &v41);
        v29 = v6;
        v14 = _mm_movemask_epi8(_mm_load_si128(&v29));
        v43 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v44 = _mm_load_si128(&v43);
        v45 = _mm_blendv_epi8(_mm_load_si128(&v44), v21, _mm_load_si128(&v29));
        v30 = _mm_load_si128(&v45);
        v7 = _mm_load_si128(&v30);
        v46 = v7;
        *(double *)v7.m128i_i64 = sub_140025950(&v46);
        v47 = v7;
        v48 = _mm_load_si128(&v30);
        v8 = _mm_load_si128(&v47);
        v49 = v8;
        *(double *)v8.m128i_i64 = sub_140025090(&v49, &v48);
        v50 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v50)) & v14);
        v15 = v9;
        v51 = _mm_load_si128(&v21);
        v23 = sub_140025460(&v51, v9);
        v27[0] = (__int64)v24[v23].m128i_i64 + v15;
      }
    }
  }
  return sub_140021140((_DWORD)v62, v63, (unsigned int)v27, v64, v16);
}
// 140021140: using guessed type __int64 __fastcall sub_140021140(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025090: using guessed type double __fastcall sub_140025090(_QWORD, _QWORD);
// 140025190: using guessed type double __fastcall sub_140025190(_QWORD, _QWORD);
// 140025330: using guessed type __int64 __fastcall sub_140025330(_QWORD);
// 140025460: using guessed type __int64 __fastcall sub_140025460(_QWORD, _QWORD);
// 140025810: using guessed type double __fastcall sub_140025810(_QWORD);
// 140025950: using guessed type double __fastcall sub_140025950(_QWORD);
// 140025A90: using guessed type double __fastcall sub_140025A90(_QWORD);
// 140025D20: using guessed type double __fastcall sub_140025D20(_QWORD, _QWORD, _QWORD);
// 1400260B0: using guessed type double __fastcall sub_1400260B0(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001C190) ----------------------------------------------------
__int64 __fastcall sub_14001C190(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  char v15; // [rsp+20h] [rbp-328h]
  char v16; // [rsp+30h] [rbp-318h]
  char v17; // [rsp+31h] [rbp-317h]
  unsigned __int8 v18; // [rsp+32h] [rbp-316h]
  unsigned __int64 v19; // [rsp+38h] [rbp-310h]
  unsigned __int64 v20; // [rsp+38h] [rbp-310h]
  int v21; // [rsp+40h] [rbp-308h]
  unsigned int v22; // [rsp+44h] [rbp-304h]
  const __m128i *v23; // [rsp+48h] [rbp-300h] BYREF
  __m128i v24; // [rsp+50h] [rbp-2F8h] BYREF
  __m128i si128; // [rsp+60h] [rbp-2E8h] BYREF
  const __m128i *v26; // [rsp+70h] [rbp-2D8h]
  __m128i v27; // [rsp+80h] [rbp-2C8h] BYREF
  __m128i v28; // [rsp+90h] [rbp-2B8h] BYREF
  const __m128i *v29; // [rsp+A0h] [rbp-2A8h] BYREF
  const __m128i *v30; // [rsp+A8h] [rbp-2A0h]
  __m128i v31; // [rsp+B0h] [rbp-298h] BYREF
  __m128i v32; // [rsp+C0h] [rbp-288h] BYREF
  __m128i v33; // [rsp+D0h] [rbp-278h] BYREF
  __m128i v34; // [rsp+E0h] [rbp-268h] BYREF
  __int64 v35; // [rsp+F0h] [rbp-258h]
  __int64 v36; // [rsp+F8h] [rbp-250h]
  __m128i v37; // [rsp+100h] [rbp-248h] BYREF
  __m128i v38; // [rsp+110h] [rbp-238h] BYREF
  __m128i v39; // [rsp+120h] [rbp-228h] BYREF
  __m128i v40; // [rsp+130h] [rbp-218h] BYREF
  __m128i v41; // [rsp+140h] [rbp-208h] BYREF
  __m128i v42; // [rsp+150h] [rbp-1F8h] BYREF
  __m128i v43; // [rsp+160h] [rbp-1E8h] BYREF
  __m128i v44; // [rsp+170h] [rbp-1D8h] BYREF
  __m128i v45; // [rsp+180h] [rbp-1C8h] BYREF
  __m128i v46; // [rsp+190h] [rbp-1B8h] BYREF
  __m128i v47; // [rsp+1A0h] [rbp-1A8h] BYREF
  __m128i v48; // [rsp+1B0h] [rbp-198h] BYREF
  __m128i v49; // [rsp+1C0h] [rbp-188h] BYREF
  __m128i v50; // [rsp+1D0h] [rbp-178h] BYREF
  __m128i v51; // [rsp+1E0h] [rbp-168h] BYREF
  __m128i v52; // [rsp+1F0h] [rbp-158h] BYREF
  __m128i v53; // [rsp+200h] [rbp-148h] BYREF
  __m128i v54; // [rsp+210h] [rbp-138h] BYREF
  __m128i v55; // [rsp+220h] [rbp-128h] BYREF
  __m128i v56; // [rsp+230h] [rbp-118h] BYREF
  __m128i v57; // [rsp+240h] [rbp-108h] BYREF
  __m128i v58; // [rsp+250h] [rbp-F8h] BYREF
  __m128i v59; // [rsp+260h] [rbp-E8h] BYREF
  __m128i v60; // [rsp+270h] [rbp-D8h] BYREF
  __m128i v61; // [rsp+280h] [rbp-C8h] BYREF
  __m128i v62; // [rsp+290h] [rbp-B8h] BYREF
  __m128i v63; // [rsp+2A0h] [rbp-A8h] BYREF
  __m128i v64; // [rsp+2B0h] [rbp-98h] BYREF
  __m128i v65; // [rsp+2C0h] [rbp-88h] BYREF
  __m128i v66; // [rsp+2D0h] [rbp-78h] BYREF
  __m128i v67; // [rsp+2E0h] [rbp-68h] BYREF
  __m128i v68; // [rsp+2F0h] [rbp-58h] BYREF
  __m128i v69; // [rsp+300h] [rbp-48h] BYREF
  __m128i v70[3]; // [rsp+310h] [rbp-38h] BYREF
  const __m128i *v71; // [rsp+350h] [rbp+8h] BYREF
  __int64 v72; // [rsp+358h] [rbp+10h]
  unsigned __int8 v73; // [rsp+360h] [rbp+18h]

  v73 = a3;
  v72 = a2;
  v71 = a1;
  v29 = a1;
  v30 = a1;
  v26 = a1;
  v16 = 0x80;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v19 = sub_140024E60(v71, v72) & 0xFFFFFFFFFFFFFFF0ui64;
    v35 = 4096i64;
    if ( v19 > 0x1000 )
      v19 = 4096i64;
    v23 = v71;
    sub_140024E30(&v23, v19);
    v37 = _mm_loadu_si128(v71);
    v3 = _mm_load_si128(&v37);
    v38 = v3;
    *(double *)v3.m128i_i64 = sub_140025F90(&v38, v73);
    v24 = v3;
    v70[1] = _mm_load_si128(&v24);
    v39 = 0i64;
    v70[2] = _mm_load_si128(&v39);
    si128 = _mm_load_si128(&v24);
    v40 = 0i64;
    v27 = _mm_load_si128(&v40);
    v41 = 0i64;
    v28 = _mm_load_si128(&v41);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v71, 16i64);
        v4 = _mm_load_si128(&v28);
        v42 = v4;
        *(double *)v4.m128i_i64 = sub_1400259A0(&v42);
        v43 = v4;
        v28 = _mm_load_si128(&v43);
        if ( v71 == v23 )
          break;
        v61 = _mm_loadu_si128(v71);
        v11 = _mm_load_si128(&v61);
        v62 = v11;
        *(double *)v11.m128i_i64 = sub_140025F90(&v62, v73);
        v63 = v11;
        v24 = _mm_load_si128(&v63);
        v64 = _mm_load_si128(&si128);
        v12 = _mm_load_si128(&v24);
        v65 = v12;
        *(double *)v12.m128i_i64 = sub_1400250D0(&v65, &v64);
        v32 = v12;
        v66 = _mm_blendv_epi8(_mm_load_si128(&v27), v28, _mm_load_si128(&v32));
        v27 = _mm_load_si128(&v66);
        v67 = _mm_load_si128(&v32);
        v68 = _mm_load_si128(&v24);
        v13 = _mm_load_si128(&si128);
        v69 = v13;
        *(double *)v13.m128i_i64 = sub_140025AE0(&v69, &v68, &v67);
        v70[0] = v13;
        si128 = _mm_load_si128(v70);
      }
      v5 = _mm_load_si128(&si128);
      v44 = v5;
      *(double *)v5.m128i_i64 = sub_1400254A0(&v44);
      v33 = v5;
      v45 = _mm_load_si128(&v33);
      v17 = sub_1400252D0(&v45);
      if ( v16 < v17 )
      {
        v16 = v17;
        v46 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v33);
        v47 = v6;
        *(double *)v6.m128i_i64 = sub_140024FD0(&v47, &v46);
        v34 = v6;
        v21 = _mm_movemask_epi8(_mm_load_si128(&v34));
        v48 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v49 = _mm_load_si128(&v48);
        v50 = _mm_blendv_epi8(_mm_load_si128(&v49), v27, _mm_load_si128(&v34));
        v31 = _mm_load_si128(&v50);
        v7 = _mm_load_si128(&v31);
        v51 = v7;
        *(double *)v7.m128i_i64 = sub_140025860(&v51);
        v52 = v7;
        v53 = _mm_load_si128(&v31);
        v8 = _mm_load_si128(&v52);
        v54 = v8;
        *(double *)v8.m128i_i64 = sub_140024FD0(&v54, &v53);
        v55 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v55)) & v21);
        v22 = v9;
        v56 = _mm_load_si128(&v27);
        v18 = sub_140025350(&v56, v9);
        v30 = (const __m128i *)((char *)&v26[v18] + v22);
      }
      v20 = sub_140024E60(v71, v72) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v20 )
        break;
      v36 = 4096i64;
      if ( v20 > 0x1000 )
        v20 = 4096i64;
      sub_140024E30(&v23, v20);
      v26 = v71;
      v57 = _mm_loadu_si128(v71);
      v10 = _mm_load_si128(&v57);
      v58 = v10;
      *(double *)v10.m128i_i64 = sub_140025F90(&v58, v73);
      v59 = v10;
      v24 = _mm_load_si128(&v59);
      si128 = _mm_load_si128(&v24);
      v60 = 0i64;
      v27 = _mm_load_si128(&v60);
    }
  }
  v15 = 127;
  return sub_1400211F0((_DWORD)v71, v72, (unsigned int)&v29, v73, v15, v16);
}
// 1400211F0: using guessed type __int64 __fastcall sub_1400211F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140024FD0: using guessed type double __fastcall sub_140024FD0(_QWORD, _QWORD);
// 1400250D0: using guessed type double __fastcall sub_1400250D0(_QWORD, _QWORD);
// 1400252D0: using guessed type __int64 __fastcall sub_1400252D0(_QWORD);
// 140025350: using guessed type __int64 __fastcall sub_140025350(_QWORD, _QWORD);
// 1400254A0: using guessed type double __fastcall sub_1400254A0(_QWORD);
// 140025860: using guessed type double __fastcall sub_140025860(_QWORD);
// 1400259A0: using guessed type double __fastcall sub_1400259A0(_QWORD);
// 140025AE0: using guessed type double __fastcall sub_140025AE0(_QWORD, _QWORD, _QWORD);
// 140025F90: using guessed type double __fastcall sub_140025F90(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001C970) ----------------------------------------------------
__int64 __fastcall sub_14001C970(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __int16 v15; // [rsp+20h] [rbp-338h]
  __int16 v16; // [rsp+30h] [rbp-328h]
  __int16 v17; // [rsp+34h] [rbp-324h]
  unsigned __int64 v18; // [rsp+38h] [rbp-320h]
  unsigned __int64 v19; // [rsp+38h] [rbp-320h]
  unsigned __int16 v20; // [rsp+40h] [rbp-318h]
  int v21; // [rsp+48h] [rbp-310h]
  unsigned int v22; // [rsp+4Ch] [rbp-30Ch]
  __int64 v23[2]; // [rsp+50h] [rbp-308h] BYREF
  __m128i v24; // [rsp+60h] [rbp-2F8h] BYREF
  __m128i si128; // [rsp+70h] [rbp-2E8h] BYREF
  const __m128i *v26; // [rsp+80h] [rbp-2D8h]
  __m128i v27; // [rsp+90h] [rbp-2C8h] BYREF
  __m128i v28; // [rsp+A0h] [rbp-2B8h] BYREF
  const __m128i *v29; // [rsp+B0h] [rbp-2A8h] BYREF
  const __m128i *v30; // [rsp+B8h] [rbp-2A0h]
  __m128i v31; // [rsp+C0h] [rbp-298h] BYREF
  __m128i v32; // [rsp+D0h] [rbp-288h] BYREF
  __m128i v33; // [rsp+E0h] [rbp-278h] BYREF
  __m128i v34; // [rsp+F0h] [rbp-268h] BYREF
  __int64 v35; // [rsp+100h] [rbp-258h]
  __int64 v36; // [rsp+108h] [rbp-250h]
  __m128i v37; // [rsp+110h] [rbp-248h] BYREF
  __m128i v38; // [rsp+120h] [rbp-238h] BYREF
  __m128i v39; // [rsp+130h] [rbp-228h] BYREF
  __m128i v40; // [rsp+140h] [rbp-218h] BYREF
  __m128i v41; // [rsp+150h] [rbp-208h] BYREF
  __m128i v42; // [rsp+160h] [rbp-1F8h] BYREF
  __m128i v43; // [rsp+170h] [rbp-1E8h] BYREF
  __m128i v44; // [rsp+180h] [rbp-1D8h] BYREF
  __m128i v45; // [rsp+190h] [rbp-1C8h] BYREF
  __m128i v46; // [rsp+1A0h] [rbp-1B8h] BYREF
  __m128i v47; // [rsp+1B0h] [rbp-1A8h] BYREF
  __m128i v48; // [rsp+1C0h] [rbp-198h] BYREF
  __m128i v49; // [rsp+1D0h] [rbp-188h] BYREF
  __m128i v50; // [rsp+1E0h] [rbp-178h] BYREF
  __m128i v51; // [rsp+1F0h] [rbp-168h] BYREF
  __m128i v52; // [rsp+200h] [rbp-158h] BYREF
  __m128i v53; // [rsp+210h] [rbp-148h] BYREF
  __m128i v54; // [rsp+220h] [rbp-138h] BYREF
  __m128i v55; // [rsp+230h] [rbp-128h] BYREF
  __m128i v56; // [rsp+240h] [rbp-118h] BYREF
  __m128i v57; // [rsp+250h] [rbp-108h] BYREF
  __m128i v58; // [rsp+260h] [rbp-F8h] BYREF
  __m128i v59; // [rsp+270h] [rbp-E8h] BYREF
  __m128i v60; // [rsp+280h] [rbp-D8h] BYREF
  __m128i v61; // [rsp+290h] [rbp-C8h] BYREF
  __m128i v62; // [rsp+2A0h] [rbp-B8h] BYREF
  __m128i v63; // [rsp+2B0h] [rbp-A8h] BYREF
  __m128i v64; // [rsp+2C0h] [rbp-98h] BYREF
  __m128i v65; // [rsp+2D0h] [rbp-88h] BYREF
  __m128i v66; // [rsp+2E0h] [rbp-78h] BYREF
  __m128i v67; // [rsp+2F0h] [rbp-68h] BYREF
  __m128i v68; // [rsp+300h] [rbp-58h] BYREF
  __m128i v69; // [rsp+310h] [rbp-48h] BYREF
  __m128i v70[3]; // [rsp+320h] [rbp-38h] BYREF
  const __m128i *v71; // [rsp+360h] [rbp+8h] BYREF
  __int64 v72; // [rsp+368h] [rbp+10h]
  unsigned __int8 v73; // [rsp+370h] [rbp+18h]

  v73 = a3;
  v72 = a2;
  v71 = a1;
  v29 = a1;
  v30 = a1;
  v26 = a1;
  v16 = 0x8000;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v18 = sub_140024E60(v71, v72) & 0xFFFFFFFFFFFFFFF0ui64;
    v35 = 0x100000i64;
    if ( v18 > 0x100000 )
      v18 = 0x100000i64;
    v23[0] = (__int64)v71;
    sub_140024E30(v23, v18);
    v37 = _mm_loadu_si128(v71);
    v3 = _mm_load_si128(&v37);
    v38 = v3;
    *(double *)v3.m128i_i64 = sub_140025FF0(&v38, v73);
    v24 = v3;
    v70[1] = _mm_load_si128(&v24);
    v39 = 0i64;
    v70[2] = _mm_load_si128(&v39);
    si128 = _mm_load_si128(&v24);
    v40 = 0i64;
    v27 = _mm_load_si128(&v40);
    v41 = 0i64;
    v28 = _mm_load_si128(&v41);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v71, 16i64);
        v4 = _mm_load_si128(&v28);
        v42 = v4;
        *(double *)v4.m128i_i64 = sub_1400259F0(&v42);
        v43 = v4;
        v28 = _mm_load_si128(&v43);
        if ( v71 == (const __m128i *)v23[0] )
          break;
        v61 = _mm_loadu_si128(v71);
        v11 = _mm_load_si128(&v61);
        v62 = v11;
        *(double *)v11.m128i_i64 = sub_140025FF0(&v62, v73);
        v63 = v11;
        v24 = _mm_load_si128(&v63);
        v64 = _mm_load_si128(&si128);
        v12 = _mm_load_si128(&v24);
        v65 = v12;
        *(double *)v12.m128i_i64 = sub_140025110(&v65, &v64);
        v32 = v12;
        v66 = _mm_blendv_epi8(_mm_load_si128(&v27), v28, _mm_load_si128(&v32));
        v27 = _mm_load_si128(&v66);
        v67 = _mm_load_si128(&v32);
        v68 = _mm_load_si128(&v24);
        v13 = _mm_load_si128(&si128);
        v69 = v13;
        *(double *)v13.m128i_i64 = sub_140025B30(&v69, &v68, &v67);
        v70[0] = v13;
        si128 = _mm_load_si128(v70);
      }
      v5 = _mm_load_si128(&si128);
      v44 = v5;
      *(double *)v5.m128i_i64 = sub_1400254F0(&v44);
      v33 = v5;
      v45 = _mm_load_si128(&v33);
      v17 = sub_1400252F0(&v45);
      if ( v16 < v17 )
      {
        v16 = v17;
        v46 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v33);
        v47 = v6;
        *(double *)v6.m128i_i64 = sub_140025010(&v47, &v46);
        v34 = v6;
        v21 = _mm_movemask_epi8(_mm_load_si128(&v34));
        v48 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v49 = _mm_load_si128(&v48);
        v50 = _mm_blendv_epi8(_mm_load_si128(&v49), v27, _mm_load_si128(&v34));
        v31 = _mm_load_si128(&v50);
        v7 = _mm_load_si128(&v31);
        v51 = v7;
        *(double *)v7.m128i_i64 = sub_1400258B0(&v51);
        v52 = v7;
        v53 = _mm_load_si128(&v31);
        v8 = _mm_load_si128(&v52);
        v54 = v8;
        *(double *)v8.m128i_i64 = sub_140025010(&v54, &v53);
        v55 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v55)) & v21);
        v22 = v9;
        v56 = _mm_load_si128(&v27);
        v20 = sub_1400253A0(&v56, v9);
        v30 = (const __m128i *)((char *)&v26[v20] + v22);
      }
      v19 = sub_140024E60(v71, v72) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v19 )
        break;
      v36 = 0x100000i64;
      if ( v19 > 0x100000 )
        v19 = 0x100000i64;
      sub_140024E30(v23, v19);
      v26 = v71;
      v57 = _mm_loadu_si128(v71);
      v10 = _mm_load_si128(&v57);
      v58 = v10;
      *(double *)v10.m128i_i64 = sub_140025FF0(&v58, v73);
      v59 = v10;
      v24 = _mm_load_si128(&v59);
      si128 = _mm_load_si128(&v24);
      v60 = 0i64;
      v27 = _mm_load_si128(&v60);
    }
  }
  v15 = 0x7FFF;
  return sub_140021280((_DWORD)v71, v72, (unsigned int)&v29, v73, v15, v16);
}
// 140021280: using guessed type __int64 __fastcall sub_140021280(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025010: using guessed type double __fastcall sub_140025010(_QWORD, _QWORD);
// 140025110: using guessed type double __fastcall sub_140025110(_QWORD, _QWORD);
// 1400252F0: using guessed type __int64 __fastcall sub_1400252F0(_QWORD);
// 1400253A0: using guessed type __int64 __fastcall sub_1400253A0(_QWORD, _QWORD);
// 1400254F0: using guessed type double __fastcall sub_1400254F0(_QWORD);
// 1400258B0: using guessed type double __fastcall sub_1400258B0(_QWORD);
// 1400259F0: using guessed type double __fastcall sub_1400259F0(_QWORD);
// 140025B30: using guessed type double __fastcall sub_140025B30(_QWORD, _QWORD, _QWORD);
// 140025FF0: using guessed type double __fastcall sub_140025FF0(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001D170) ----------------------------------------------------
__int64 __fastcall sub_14001D170(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  unsigned __int64 v15; // [rsp+30h] [rbp-328h]
  unsigned __int64 v16; // [rsp+30h] [rbp-328h]
  int v17; // [rsp+38h] [rbp-320h]
  signed int v18; // [rsp+3Ch] [rbp-31Ch]
  signed int v19; // [rsp+40h] [rbp-318h]
  unsigned int v20; // [rsp+44h] [rbp-314h]
  int v21; // [rsp+48h] [rbp-310h]
  __int64 v22[2]; // [rsp+50h] [rbp-308h] BYREF
  __m128i v23; // [rsp+60h] [rbp-2F8h] BYREF
  __m128i si128; // [rsp+70h] [rbp-2E8h] BYREF
  const __m128i *v25; // [rsp+80h] [rbp-2D8h]
  __m128i v26; // [rsp+90h] [rbp-2C8h] BYREF
  __m128i v27; // [rsp+A0h] [rbp-2B8h] BYREF
  const __m128i *v28; // [rsp+B0h] [rbp-2A8h] BYREF
  const __m128i *v29; // [rsp+B8h] [rbp-2A0h]
  __m128i v30; // [rsp+C0h] [rbp-298h] BYREF
  __m128i v31; // [rsp+D0h] [rbp-288h] BYREF
  __m128i v32; // [rsp+E0h] [rbp-278h] BYREF
  __m128i v33; // [rsp+F0h] [rbp-268h] BYREF
  __int64 v34; // [rsp+100h] [rbp-258h]
  __int64 v35; // [rsp+108h] [rbp-250h]
  __m128i v36; // [rsp+110h] [rbp-248h] BYREF
  __m128i v37; // [rsp+120h] [rbp-238h] BYREF
  __m128i v38; // [rsp+130h] [rbp-228h] BYREF
  __m128i v39; // [rsp+140h] [rbp-218h] BYREF
  __m128i v40; // [rsp+150h] [rbp-208h] BYREF
  __m128i v41; // [rsp+160h] [rbp-1F8h] BYREF
  __m128i v42; // [rsp+170h] [rbp-1E8h] BYREF
  __m128i v43; // [rsp+180h] [rbp-1D8h] BYREF
  __m128i v44; // [rsp+190h] [rbp-1C8h] BYREF
  __m128i v45; // [rsp+1A0h] [rbp-1B8h] BYREF
  __m128i v46; // [rsp+1B0h] [rbp-1A8h] BYREF
  __m128i v47; // [rsp+1C0h] [rbp-198h] BYREF
  __m128i v48; // [rsp+1D0h] [rbp-188h] BYREF
  __m128i v49; // [rsp+1E0h] [rbp-178h] BYREF
  __m128i v50; // [rsp+1F0h] [rbp-168h] BYREF
  __m128i v51; // [rsp+200h] [rbp-158h] BYREF
  __m128i v52; // [rsp+210h] [rbp-148h] BYREF
  __m128i v53; // [rsp+220h] [rbp-138h] BYREF
  __m128i v54; // [rsp+230h] [rbp-128h] BYREF
  __m128i v55; // [rsp+240h] [rbp-118h] BYREF
  __m128i v56; // [rsp+250h] [rbp-108h] BYREF
  __m128i v57; // [rsp+260h] [rbp-F8h] BYREF
  __m128i v58; // [rsp+270h] [rbp-E8h] BYREF
  __m128i v59; // [rsp+280h] [rbp-D8h] BYREF
  __m128i v60; // [rsp+290h] [rbp-C8h] BYREF
  __m128i v61; // [rsp+2A0h] [rbp-B8h] BYREF
  __m128i v62; // [rsp+2B0h] [rbp-A8h] BYREF
  __m128i v63; // [rsp+2C0h] [rbp-98h] BYREF
  __m128i v64; // [rsp+2D0h] [rbp-88h] BYREF
  __m128i v65; // [rsp+2E0h] [rbp-78h] BYREF
  __m128i v66; // [rsp+2F0h] [rbp-68h] BYREF
  __m128i v67; // [rsp+300h] [rbp-58h] BYREF
  __m128i v68; // [rsp+310h] [rbp-48h] BYREF
  __m128i v69[3]; // [rsp+320h] [rbp-38h] BYREF
  const __m128i *v70; // [rsp+360h] [rbp+8h] BYREF
  __int64 v71; // [rsp+368h] [rbp+10h]
  unsigned __int8 v72; // [rsp+370h] [rbp+18h]

  v72 = a3;
  v71 = a2;
  v70 = a1;
  v28 = a1;
  v29 = a1;
  v25 = a1;
  v18 = 0x80000000;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v15 = sub_140024E60(v70, v71) & 0xFFFFFFFFFFFFFFF0ui64;
    v34 = 0x1000000000i64;
    if ( v15 > 0x1000000000i64 )
      v15 = 0x1000000000i64;
    v22[0] = (__int64)v70;
    sub_140024E30(v22, v15);
    v36 = _mm_loadu_si128(v70);
    v3 = _mm_load_si128(&v36);
    v37 = v3;
    *(double *)v3.m128i_i64 = sub_140026050(&v37, v72);
    v23 = v3;
    v69[1] = _mm_load_si128(&v23);
    v38 = 0i64;
    v69[2] = _mm_load_si128(&v38);
    si128 = _mm_load_si128(&v23);
    v39 = 0i64;
    v26 = _mm_load_si128(&v39);
    v40 = 0i64;
    v27 = _mm_load_si128(&v40);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v70, 16i64);
        v4 = _mm_load_si128(&v27);
        v41 = v4;
        *(double *)v4.m128i_i64 = sub_140025A40(&v41);
        v42 = v4;
        v27 = _mm_load_si128(&v42);
        if ( v70 == (const __m128i *)v22[0] )
          break;
        v60 = _mm_loadu_si128(v70);
        v11 = _mm_load_si128(&v60);
        v61 = v11;
        *(double *)v11.m128i_i64 = sub_140026050(&v61, v72);
        v62 = v11;
        v23 = _mm_load_si128(&v62);
        v63 = _mm_load_si128(&si128);
        v12 = _mm_load_si128(&v23);
        v64 = v12;
        *(double *)v12.m128i_i64 = sub_140025150(&v64, &v63);
        v31 = v12;
        v65 = _mm_blendv_epi8(_mm_load_si128(&v26), v27, _mm_load_si128(&v31));
        v26 = _mm_load_si128(&v65);
        v66 = _mm_load_si128(&v31);
        v67 = _mm_load_si128(&v23);
        v13 = _mm_load_si128(&si128);
        v68 = v13;
        *(double *)v13.m128i_i64 = sub_140025B80(&v68, &v67, &v66);
        v69[0] = v13;
        si128 = _mm_load_si128(v69);
      }
      v5 = _mm_load_si128(&si128);
      v43 = v5;
      *(double *)v5.m128i_i64 = sub_140025540(&v43);
      v32 = v5;
      v44 = _mm_load_si128(&v32);
      v19 = sub_140025310(&v44);
      if ( v18 < v19 )
      {
        v18 = v19;
        v45 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v32);
        v46 = v6;
        *(double *)v6.m128i_i64 = sub_140025050(&v46, &v45);
        v33 = v6;
        v17 = _mm_movemask_epi8(_mm_load_si128(&v33));
        v47 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v48 = _mm_load_si128(&v47);
        v49 = _mm_blendv_epi8(_mm_load_si128(&v48), v26, _mm_load_si128(&v33));
        v30 = _mm_load_si128(&v49);
        v7 = _mm_load_si128(&v30);
        v50 = v7;
        *(double *)v7.m128i_i64 = sub_140025900(&v50);
        v51 = v7;
        v52 = _mm_load_si128(&v30);
        v8 = _mm_load_si128(&v51);
        v53 = v8;
        *(double *)v8.m128i_i64 = sub_140025050(&v53, &v52);
        v54 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v54)) & v17);
        v20 = v9;
        v55 = _mm_load_si128(&v26);
        v21 = sub_140025400(&v55, v9);
        v29 = (const __m128i *)((char *)v25 + 16 * v21 + v20);
      }
      v16 = sub_140024E60(v70, v71) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v16 )
        break;
      v35 = 0x1000000000i64;
      if ( v16 > 0x1000000000i64 )
        v16 = 0x1000000000i64;
      sub_140024E30(v22, v16);
      v25 = v70;
      v56 = _mm_loadu_si128(v70);
      v10 = _mm_load_si128(&v56);
      v57 = v10;
      *(double *)v10.m128i_i64 = sub_140026050(&v57, v72);
      v58 = v10;
      v23 = _mm_load_si128(&v58);
      si128 = _mm_load_si128(&v23);
      v59 = 0i64;
      v26 = _mm_load_si128(&v59);
    }
  }
  return sub_140021320((_DWORD)v70, v71, (unsigned int)&v28, v72, 0x7FFFFFFF, v18);
}
// 140021320: using guessed type __int64 __fastcall sub_140021320(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025050: using guessed type double __fastcall sub_140025050(_QWORD, _QWORD);
// 140025150: using guessed type double __fastcall sub_140025150(_QWORD, _QWORD);
// 140025310: using guessed type __int64 __fastcall sub_140025310(_QWORD);
// 140025400: using guessed type __int64 __fastcall sub_140025400(_QWORD, _QWORD);
// 140025540: using guessed type double __fastcall sub_140025540(_QWORD);
// 140025900: using guessed type double __fastcall sub_140025900(_QWORD);
// 140025A40: using guessed type double __fastcall sub_140025A40(_QWORD);
// 140025B80: using guessed type double __fastcall sub_140025B80(_QWORD, _QWORD, _QWORD);
// 140026050: using guessed type double __fastcall sub_140026050(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001D980) ----------------------------------------------------
__int64 __fastcall sub_14001D980(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  int v14; // [rsp+30h] [rbp-2D8h]
  unsigned int v15; // [rsp+34h] [rbp-2D4h]
  __int64 v16; // [rsp+38h] [rbp-2D0h]
  const __m128i *v17; // [rsp+40h] [rbp-2C8h] BYREF
  __int64 v18; // [rsp+48h] [rbp-2C0h]
  __m128i v19; // [rsp+50h] [rbp-2B8h] BYREF
  __m128i si128; // [rsp+60h] [rbp-2A8h] BYREF
  __m128i v21; // [rsp+70h] [rbp-298h] BYREF
  unsigned __int64 v22; // [rsp+80h] [rbp-288h]
  __int64 v23; // [rsp+88h] [rbp-280h]
  const __m128i *v24; // [rsp+90h] [rbp-278h]
  __int64 v25; // [rsp+98h] [rbp-270h]
  __m128i v26; // [rsp+A0h] [rbp-268h] BYREF
  const __m128i *v27; // [rsp+B0h] [rbp-258h] BYREF
  const __m128i *v28; // [rsp+B8h] [rbp-250h]
  __m128i v29; // [rsp+C0h] [rbp-248h] BYREF
  __m128i v30; // [rsp+D0h] [rbp-238h] BYREF
  __m128i v31; // [rsp+E0h] [rbp-228h] BYREF
  __m128i v32; // [rsp+F0h] [rbp-218h] BYREF
  __m128i v33; // [rsp+100h] [rbp-208h] BYREF
  __m128i v34; // [rsp+110h] [rbp-1F8h] BYREF
  __m128i v35; // [rsp+120h] [rbp-1E8h] BYREF
  __m128i v36; // [rsp+130h] [rbp-1D8h] BYREF
  __m128i v37; // [rsp+140h] [rbp-1C8h] BYREF
  __m128i v38; // [rsp+150h] [rbp-1B8h] BYREF
  __m128i v39; // [rsp+160h] [rbp-1A8h] BYREF
  __m128i v40; // [rsp+170h] [rbp-198h] BYREF
  __m128i v41; // [rsp+180h] [rbp-188h] BYREF
  __m128i v42; // [rsp+190h] [rbp-178h] BYREF
  __m128i v43; // [rsp+1A0h] [rbp-168h] BYREF
  __m128i v44; // [rsp+1B0h] [rbp-158h] BYREF
  __m128i v45; // [rsp+1C0h] [rbp-148h] BYREF
  __m128i v46; // [rsp+1D0h] [rbp-138h] BYREF
  __m128i v47; // [rsp+1E0h] [rbp-128h] BYREF
  __m128i v48; // [rsp+1F0h] [rbp-118h] BYREF
  __m128i v49; // [rsp+200h] [rbp-108h] BYREF
  __m128i v50; // [rsp+210h] [rbp-F8h] BYREF
  __m128i v51; // [rsp+220h] [rbp-E8h] BYREF
  __m128i v52; // [rsp+230h] [rbp-D8h] BYREF
  __m128i v53; // [rsp+240h] [rbp-C8h] BYREF
  __m128i v54; // [rsp+250h] [rbp-B8h] BYREF
  __m128i v55; // [rsp+260h] [rbp-A8h] BYREF
  __m128i v56; // [rsp+270h] [rbp-98h] BYREF
  __m128i v57; // [rsp+280h] [rbp-88h] BYREF
  __m128i v58; // [rsp+290h] [rbp-78h] BYREF
  __m128i v59; // [rsp+2A0h] [rbp-68h] BYREF
  __m128i v60; // [rsp+2B0h] [rbp-58h] BYREF
  __m128i v61; // [rsp+2C0h] [rbp-48h] BYREF
  __m128i v62[3]; // [rsp+2D0h] [rbp-38h] BYREF
  const __m128i *v63; // [rsp+310h] [rbp+8h] BYREF
  __int64 v64; // [rsp+318h] [rbp+10h]
  unsigned __int8 v65; // [rsp+320h] [rbp+18h]

  v65 = a3;
  v64 = a2;
  v63 = a1;
  v27 = a1;
  v28 = a1;
  v24 = a1;
  v25 = 0x7FFFFFFFFFFFFFFFi64;
  v16 = 0x8000000000000000ui64;
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x10 )
  {
    if ( (unsigned __int8)sub_1400261D0() )
    {
      v22 = sub_140024E60(v63, v64) & 0xFFFFFFFFFFFFFFF0ui64;
      v17 = v63;
      sub_140024E30(&v17, v22);
      v33 = _mm_loadu_si128(v63);
      v3 = _mm_load_si128(&v33);
      v34 = v3;
      *(double *)v3.m128i_i64 = sub_1400260B0(&v34, v65);
      v19 = v3;
      v62[1] = _mm_load_si128(&v19);
      v35 = 0i64;
      v62[2] = _mm_load_si128(&v35);
      si128 = _mm_load_si128(&v19);
      v36 = 0i64;
      v21 = _mm_load_si128(&v36);
      v37 = 0i64;
      v26 = _mm_load_si128(&v37);
      while ( 1 )
      {
        sub_140024E30(&v63, 16i64);
        v4 = _mm_load_si128(&v26);
        v38 = v4;
        *(double *)v4.m128i_i64 = sub_140025A90(&v38);
        v39 = v4;
        v26 = _mm_load_si128(&v39);
        if ( v63 == v17 )
          break;
        v53 = _mm_loadu_si128(v63);
        v10 = _mm_load_si128(&v53);
        v54 = v10;
        *(double *)v10.m128i_i64 = sub_1400260B0(&v54, v65);
        v55 = v10;
        v19 = _mm_load_si128(&v55);
        v56 = _mm_load_si128(&si128);
        v11 = _mm_load_si128(&v19);
        v57 = v11;
        *(double *)v11.m128i_i64 = sub_140025190(&v57, &v56);
        v32 = v11;
        v58 = _mm_blendv_epi8(_mm_load_si128(&v21), v26, _mm_load_si128(&v32));
        v21 = _mm_load_si128(&v58);
        v59 = _mm_load_si128(&v32);
        v60 = _mm_load_si128(&v19);
        v12 = _mm_load_si128(&si128);
        v61 = v12;
        *(double *)v12.m128i_i64 = sub_140025BD0(&v61, &v60, &v59);
        v62[0] = v12;
        si128 = _mm_load_si128(v62);
      }
      v5 = _mm_load_si128(&si128);
      v40 = v5;
      *(double *)v5.m128i_i64 = sub_140025590(&v40);
      v29 = v5;
      v41 = _mm_load_si128(&v29);
      v18 = sub_140025330(&v41);
      if ( v18 != 0x8000000000000000ui64 )
      {
        v16 = v18;
        v42 = _mm_load_si128(&si128);
        v6 = _mm_load_si128(&v29);
        v43 = v6;
        *(double *)v6.m128i_i64 = sub_140025090(&v43, &v42);
        v30 = v6;
        v14 = _mm_movemask_epi8(_mm_load_si128(&v30));
        v44 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v45 = _mm_load_si128(&v44);
        v46 = _mm_blendv_epi8(_mm_load_si128(&v45), v21, _mm_load_si128(&v30));
        v31 = _mm_load_si128(&v46);
        v7 = _mm_load_si128(&v31);
        v47 = v7;
        *(double *)v7.m128i_i64 = sub_140025950(&v47);
        v48 = v7;
        v49 = _mm_load_si128(&v31);
        v8 = _mm_load_si128(&v48);
        v50 = v8;
        *(double *)v8.m128i_i64 = sub_140025090(&v50, &v49);
        v51 = v8;
        _BitScanForward(&v9, _mm_movemask_epi8(_mm_load_si128(&v51)) & v14);
        v15 = v9;
        v52 = _mm_load_si128(&v21);
        v23 = sub_140025460(&v52, v9);
        v28 = (const __m128i *)((char *)&v24[v23] + v15);
      }
    }
  }
  return sub_1400213B0((_DWORD)v63, v64, (unsigned int)&v27, v65, v25, v16);
}
// 1400213B0: using guessed type __int64 __fastcall sub_1400213B0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025090: using guessed type double __fastcall sub_140025090(_QWORD, _QWORD);
// 140025190: using guessed type double __fastcall sub_140025190(_QWORD, _QWORD);
// 140025330: using guessed type __int64 __fastcall sub_140025330(_QWORD);
// 140025460: using guessed type __int64 __fastcall sub_140025460(_QWORD, _QWORD);
// 140025590: using guessed type double __fastcall sub_140025590(_QWORD);
// 140025950: using guessed type double __fastcall sub_140025950(_QWORD);
// 140025A90: using guessed type double __fastcall sub_140025A90(_QWORD);
// 140025BD0: using guessed type double __fastcall sub_140025BD0(_QWORD, _QWORD, _QWORD);
// 1400260B0: using guessed type double __fastcall sub_1400260B0(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001E040) ----------------------------------------------------
__int64 __fastcall sub_14001E040(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4)
{
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  __m128i v9; // xmm0
  unsigned int v10; // eax
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  __m128i v18; // xmm0
  __m128i v19; // xmm0
  __m128i v20; // xmm0
  __m128i v21; // xmm0
  char v23; // [rsp+40h] [rbp-4C8h]
  char v24; // [rsp+41h] [rbp-4C7h]
  char v25; // [rsp+42h] [rbp-4C6h]
  char v26; // [rsp+43h] [rbp-4C5h]
  unsigned __int8 v27; // [rsp+44h] [rbp-4C4h]
  unsigned __int8 v28; // [rsp+45h] [rbp-4C3h]
  unsigned int v29; // [rsp+48h] [rbp-4C0h]
  unsigned __int64 v30; // [rsp+50h] [rbp-4B8h]
  unsigned __int64 v31; // [rsp+50h] [rbp-4B8h]
  int v32; // [rsp+58h] [rbp-4B0h]
  int v33; // [rsp+5Ch] [rbp-4ACh]
  unsigned int v34; // [rsp+60h] [rbp-4A8h]
  __m128i v35; // [rsp+70h] [rbp-498h] BYREF
  const __m128i *v36; // [rsp+80h] [rbp-488h] BYREF
  const __m128i *v37; // [rsp+88h] [rbp-480h]
  __m128i v38; // [rsp+90h] [rbp-478h] BYREF
  __m128i v39; // [rsp+A0h] [rbp-468h] BYREF
  __m128i v40; // [rsp+B0h] [rbp-458h] BYREF
  __m128i v41; // [rsp+C0h] [rbp-448h] BYREF
  __m128i v42; // [rsp+D0h] [rbp-438h] BYREF
  const __m128i *v43; // [rsp+E0h] [rbp-428h]
  const __m128i *v44; // [rsp+E8h] [rbp-420h]
  __m128i v45; // [rsp+F0h] [rbp-418h] BYREF
  __m128i v46; // [rsp+100h] [rbp-408h] BYREF
  __m128i v47; // [rsp+110h] [rbp-3F8h] BYREF
  __m128i v48; // [rsp+120h] [rbp-3E8h] BYREF
  __m128i v49; // [rsp+130h] [rbp-3D8h] BYREF
  __m128i v50; // [rsp+140h] [rbp-3C8h] BYREF
  __m128i v51; // [rsp+150h] [rbp-3B8h] BYREF
  __m128i v52; // [rsp+160h] [rbp-3A8h] BYREF
  __int64 v53; // [rsp+170h] [rbp-398h]
  __int64 v54; // [rsp+178h] [rbp-390h]
  __m128i v55; // [rsp+180h] [rbp-388h] BYREF
  __m128i v56; // [rsp+190h] [rbp-378h] BYREF
  __m128i v57; // [rsp+1A0h] [rbp-368h] BYREF
  __m128i v58; // [rsp+1B0h] [rbp-358h] BYREF
  __m128i v59; // [rsp+1C0h] [rbp-348h] BYREF
  __m128i v60; // [rsp+1D0h] [rbp-338h] BYREF
  __m128i v61; // [rsp+1E0h] [rbp-328h] BYREF
  __m128i v62; // [rsp+1F0h] [rbp-318h] BYREF
  __m128i v63; // [rsp+200h] [rbp-308h] BYREF
  __m128i v64; // [rsp+210h] [rbp-2F8h] BYREF
  __m128i v65; // [rsp+220h] [rbp-2E8h] BYREF
  __m128i si128; // [rsp+230h] [rbp-2D8h] BYREF
  __m128i v67; // [rsp+240h] [rbp-2C8h] BYREF
  __m128i v68; // [rsp+250h] [rbp-2B8h] BYREF
  __m128i v69; // [rsp+260h] [rbp-2A8h] BYREF
  __m128i v70; // [rsp+270h] [rbp-298h] BYREF
  __m128i v71; // [rsp+280h] [rbp-288h] BYREF
  __m128i v72; // [rsp+290h] [rbp-278h] BYREF
  __m128i v73; // [rsp+2A0h] [rbp-268h] BYREF
  __m128i v74; // [rsp+2B0h] [rbp-258h] BYREF
  __m128i v75; // [rsp+2C0h] [rbp-248h] BYREF
  __m128i v76; // [rsp+2D0h] [rbp-238h] BYREF
  __m128i v77; // [rsp+2E0h] [rbp-228h] BYREF
  __m128i v78; // [rsp+2F0h] [rbp-218h] BYREF
  __m128i v79; // [rsp+300h] [rbp-208h] BYREF
  __m128i v80; // [rsp+310h] [rbp-1F8h] BYREF
  __m128i v81; // [rsp+320h] [rbp-1E8h] BYREF
  __m128i v82; // [rsp+330h] [rbp-1D8h] BYREF
  __m128i v83; // [rsp+340h] [rbp-1C8h] BYREF
  __m128i v84; // [rsp+350h] [rbp-1B8h] BYREF
  __m128i v85; // [rsp+360h] [rbp-1A8h] BYREF
  __m128i v86; // [rsp+370h] [rbp-198h] BYREF
  __m128i v87; // [rsp+380h] [rbp-188h] BYREF
  __m128i v88; // [rsp+390h] [rbp-178h] BYREF
  __m128i v89; // [rsp+3A0h] [rbp-168h] BYREF
  __m128i v90; // [rsp+3B0h] [rbp-158h] BYREF
  __m128i v91; // [rsp+3C0h] [rbp-148h] BYREF
  __m128i v92; // [rsp+3D0h] [rbp-138h] BYREF
  __m128i v93; // [rsp+3E0h] [rbp-128h] BYREF
  __m128i v94; // [rsp+3F0h] [rbp-118h] BYREF
  __m128i v95; // [rsp+400h] [rbp-108h] BYREF
  __m128i v96; // [rsp+410h] [rbp-F8h] BYREF
  __m128i v97; // [rsp+420h] [rbp-E8h] BYREF
  __m128i v98; // [rsp+430h] [rbp-D8h] BYREF
  __m128i v99; // [rsp+440h] [rbp-C8h] BYREF
  __m128i v100; // [rsp+450h] [rbp-B8h] BYREF
  __m128i v101; // [rsp+460h] [rbp-A8h] BYREF
  __m128i v102; // [rsp+470h] [rbp-98h] BYREF
  __m128i v103; // [rsp+480h] [rbp-88h] BYREF
  __m128i v104; // [rsp+490h] [rbp-78h] BYREF
  __m128i v105; // [rsp+4A0h] [rbp-68h] BYREF
  __m128i v106; // [rsp+4B0h] [rbp-58h] BYREF
  __m128i v107; // [rsp+4C0h] [rbp-48h] BYREF
  __m128i v108; // [rsp+4D0h] [rbp-38h] BYREF
  const __m128i *v110; // [rsp+518h] [rbp+10h] BYREF
  __int64 v111; // [rsp+520h] [rbp+18h]
  unsigned __int8 v112; // [rsp+528h] [rbp+20h]

  v112 = a4;
  v111 = a3;
  v110 = a2;
  v43 = a2;
  v44 = a2;
  v37 = a2;
  v24 = 127;
  v23 = 0x80;
  if ( (unsigned __int64)sub_140024E60(a2, a3) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v30 = sub_140024E60(v110, v111) & 0xFFFFFFFFFFFFFFF0ui64;
    v53 = 4096i64;
    if ( v30 > 0x1000 )
      v30 = 4096i64;
    v36 = v110;
    sub_140024E30(&v36, v30);
    v55 = _mm_loadu_si128(v110);
    v4 = _mm_load_si128(&v55);
    v56 = v4;
    *(double *)v4.m128i_i64 = sub_140025F90(&v56, v112);
    v35 = v4;
    v38 = _mm_load_si128(&v35);
    v57 = 0i64;
    v40 = _mm_load_si128(&v57);
    v39 = _mm_load_si128(&v35);
    v58 = 0i64;
    v41 = _mm_load_si128(&v58);
    v59 = 0i64;
    v42 = _mm_load_si128(&v59);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v110, 16i64);
        v5 = _mm_load_si128(&v42);
        v60 = v5;
        *(double *)v5.m128i_i64 = sub_1400259A0(&v60);
        v61 = v5;
        v42 = _mm_load_si128(&v61);
        if ( v110 == v36 )
          break;
        v92 = _mm_loadu_si128(v110);
        v17 = _mm_load_si128(&v92);
        v93 = v17;
        *(double *)v17.m128i_i64 = sub_140025F90(&v93, v112);
        v94 = v17;
        v35 = _mm_load_si128(&v94);
        v95 = _mm_load_si128(&v35);
        v18 = _mm_load_si128(&v38);
        v96 = v18;
        *(double *)v18.m128i_i64 = sub_1400250D0(&v96, &v95);
        v45 = v18;
        v97 = _mm_blendv_epi8(_mm_load_si128(&v40), v42, _mm_load_si128(&v45));
        v40 = _mm_load_si128(&v97);
        v98 = _mm_load_si128(&v45);
        v99 = _mm_load_si128(&v35);
        v19 = _mm_load_si128(&v38);
        v100 = v19;
        *(double *)v19.m128i_i64 = sub_140025C30(&v100, &v99, &v98);
        v101 = v19;
        v38 = _mm_load_si128(&v101);
        v102 = _mm_load_si128(&v35);
        v20 = _mm_load_si128(&v39);
        v103 = v20;
        *(double *)v20.m128i_i64 = sub_1400250D0(&v103, &v102);
        v46 = v20;
        v104 = _mm_blendv_epi8(_mm_load_si128(&v42), v41, _mm_load_si128(&v46));
        v41 = _mm_load_si128(&v104);
        v105 = _mm_load_si128(&v46);
        v106 = _mm_load_si128(&v39);
        v21 = _mm_load_si128(&v35);
        v107 = v21;
        *(double *)v21.m128i_i64 = sub_140025AE0(&v107, &v106, &v105);
        v108 = v21;
        v39 = _mm_load_si128(&v108);
      }
      v6 = _mm_load_si128(&v38);
      v62 = v6;
      *(double *)v6.m128i_i64 = sub_140025720(&v62);
      v47 = v6;
      v63 = _mm_load_si128(&v47);
      v25 = sub_1400252D0(&v63);
      if ( v25 < v24 )
      {
        v24 = v25;
        v64 = _mm_load_si128(&v38);
        v7 = _mm_load_si128(&v47);
        v65 = v7;
        *(double *)v7.m128i_i64 = sub_140024FD0(&v65, &v64);
        v48 = v7;
        v32 = _mm_movemask_epi8(_mm_load_si128(&v48));
        si128 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v67 = _mm_load_si128(&si128);
        v68 = _mm_blendv_epi8(_mm_load_si128(&v67), v40, _mm_load_si128(&v48));
        v49 = _mm_load_si128(&v68);
        v8 = _mm_load_si128(&v49);
        v69 = v8;
        *(double *)v8.m128i_i64 = sub_140025860(&v69);
        v70 = v8;
        v71 = _mm_load_si128(&v49);
        v9 = _mm_load_si128(&v70);
        v72 = v9;
        *(double *)v9.m128i_i64 = sub_140024FD0(&v72, &v71);
        v73 = v9;
        _BitScanForward(&v10, _mm_movemask_epi8(_mm_load_si128(&v73)) & v32);
        v34 = v10;
        v74 = _mm_load_si128(&v40);
        v27 = sub_140025350(&v74, v10);
        v43 = (const __m128i *)((char *)&v37[v27] + v34);
      }
      v11 = _mm_load_si128(&v39);
      v75 = v11;
      *(double *)v11.m128i_i64 = sub_1400254A0(&v75);
      v50 = v11;
      v76 = _mm_load_si128(&v50);
      v26 = sub_1400252D0(&v76);
      if ( v23 <= v26 )
      {
        v23 = v26;
        v77 = _mm_load_si128(&v39);
        v12 = _mm_load_si128(&v50);
        v78 = v12;
        *(double *)v12.m128i_i64 = sub_140024FD0(&v78, &v77);
        v51 = v12;
        v33 = _mm_movemask_epi8(_mm_load_si128(&v51));
        v79 = 0i64;
        v80 = _mm_blendv_epi8(_mm_load_si128(&v79), v41, _mm_load_si128(&v51));
        v52 = _mm_load_si128(&v80);
        v13 = _mm_load_si128(&v52);
        v81 = v13;
        *(double *)v13.m128i_i64 = sub_1400255E0(&v81);
        v82 = v13;
        v83 = _mm_load_si128(&v52);
        v14 = _mm_load_si128(&v82);
        v84 = v14;
        *(double *)v14.m128i_i64 = sub_140024FD0(&v84, &v83);
        v85 = v14;
        _BitScanReverse(&v15, _mm_movemask_epi8(_mm_load_si128(&v85)) & v33);
        v29 = v15;
        v86 = _mm_load_si128(&v41);
        v28 = sub_140025350(&v86, v15);
        v44 = (const __m128i *)((char *)&v37[v28] + v29);
      }
      v31 = sub_140024E60(v110, v111) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v31 )
        break;
      v54 = 4096i64;
      if ( v31 > 0x1000 )
        v31 = 4096i64;
      sub_140024E30(&v36, v31);
      v37 = v110;
      v87 = _mm_loadu_si128(v110);
      v16 = _mm_load_si128(&v87);
      v88 = v16;
      *(double *)v16.m128i_i64 = sub_140025F90(&v88, v112);
      v89 = v16;
      v35 = _mm_load_si128(&v89);
      v38 = _mm_load_si128(&v35);
      v90 = 0i64;
      v40 = _mm_load_si128(&v90);
      v39 = _mm_load_si128(&v35);
      v91 = 0i64;
      v41 = _mm_load_si128(&v91);
    }
  }
  return a1;
}
// 140021460: using guessed type __int64 __fastcall sub_140021460(_DWORD, _DWORD, _DWORD, _DWORD, char, char, char);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140024FD0: using guessed type double __fastcall sub_140024FD0(_QWORD, _QWORD);
// 1400250D0: using guessed type double __fastcall sub_1400250D0(_QWORD, _QWORD);
// 1400252D0: using guessed type __int64 __fastcall sub_1400252D0(_QWORD);
// 140025350: using guessed type __int64 __fastcall sub_140025350(_QWORD, _QWORD);
// 1400254A0: using guessed type double __fastcall sub_1400254A0(_QWORD);
// 1400255E0: using guessed type double __fastcall sub_1400255E0(_QWORD);
// 140025720: using guessed type double __fastcall sub_140025720(_QWORD);
// 140025860: using guessed type double __fastcall sub_140025860(_QWORD);
// 1400259A0: using guessed type double __fastcall sub_1400259A0(_QWORD);
// 140025AE0: using guessed type double __fastcall sub_140025AE0(_QWORD, _QWORD, _QWORD);
// 140025C30: using guessed type double __fastcall sub_140025C30(_QWORD, _QWORD, _QWORD);
// 140025F90: using guessed type double __fastcall sub_140025F90(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001EC40) ----------------------------------------------------
__int64 __fastcall sub_14001EC40(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4)
{
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  __m128i v9; // xmm0
  unsigned int v10; // eax
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  __m128i v18; // xmm0
  __m128i v19; // xmm0
  __m128i v20; // xmm0
  __m128i v21; // xmm0
  __int16 v23; // [rsp+40h] [rbp-4D8h]
  __int16 v24; // [rsp+44h] [rbp-4D4h]
  __int16 v25; // [rsp+48h] [rbp-4D0h]
  __int16 v26; // [rsp+4Ch] [rbp-4CCh]
  unsigned int v27; // [rsp+50h] [rbp-4C8h]
  unsigned __int64 v28; // [rsp+58h] [rbp-4C0h]
  unsigned __int64 v29; // [rsp+58h] [rbp-4C0h]
  unsigned __int16 v30; // [rsp+60h] [rbp-4B8h]
  unsigned __int16 v31; // [rsp+64h] [rbp-4B4h]
  int v32; // [rsp+68h] [rbp-4B0h]
  int v33; // [rsp+6Ch] [rbp-4ACh]
  unsigned int v34; // [rsp+70h] [rbp-4A8h]
  __m128i v35; // [rsp+80h] [rbp-498h] BYREF
  const __m128i *v36; // [rsp+90h] [rbp-488h] BYREF
  const __m128i *v37; // [rsp+98h] [rbp-480h]
  __m128i v38; // [rsp+A0h] [rbp-478h] BYREF
  __m128i v39; // [rsp+B0h] [rbp-468h] BYREF
  __m128i v40; // [rsp+C0h] [rbp-458h] BYREF
  __m128i v41; // [rsp+D0h] [rbp-448h] BYREF
  __m128i v42; // [rsp+E0h] [rbp-438h] BYREF
  const __m128i *v43; // [rsp+F0h] [rbp-428h]
  const __m128i *v44; // [rsp+F8h] [rbp-420h]
  __m128i v45; // [rsp+100h] [rbp-418h] BYREF
  __m128i v46; // [rsp+110h] [rbp-408h] BYREF
  __m128i v47; // [rsp+120h] [rbp-3F8h] BYREF
  __m128i v48; // [rsp+130h] [rbp-3E8h] BYREF
  __m128i v49; // [rsp+140h] [rbp-3D8h] BYREF
  __m128i v50; // [rsp+150h] [rbp-3C8h] BYREF
  __m128i v51; // [rsp+160h] [rbp-3B8h] BYREF
  __m128i v52; // [rsp+170h] [rbp-3A8h] BYREF
  __int64 v53; // [rsp+180h] [rbp-398h]
  __int64 v54; // [rsp+188h] [rbp-390h]
  __m128i v55; // [rsp+190h] [rbp-388h] BYREF
  __m128i v56; // [rsp+1A0h] [rbp-378h] BYREF
  __m128i v57; // [rsp+1B0h] [rbp-368h] BYREF
  __m128i v58; // [rsp+1C0h] [rbp-358h] BYREF
  __m128i v59; // [rsp+1D0h] [rbp-348h] BYREF
  __m128i v60; // [rsp+1E0h] [rbp-338h] BYREF
  __m128i v61; // [rsp+1F0h] [rbp-328h] BYREF
  __m128i v62; // [rsp+200h] [rbp-318h] BYREF
  __m128i v63; // [rsp+210h] [rbp-308h] BYREF
  __m128i v64; // [rsp+220h] [rbp-2F8h] BYREF
  __m128i v65; // [rsp+230h] [rbp-2E8h] BYREF
  __m128i si128; // [rsp+240h] [rbp-2D8h] BYREF
  __m128i v67; // [rsp+250h] [rbp-2C8h] BYREF
  __m128i v68; // [rsp+260h] [rbp-2B8h] BYREF
  __m128i v69; // [rsp+270h] [rbp-2A8h] BYREF
  __m128i v70; // [rsp+280h] [rbp-298h] BYREF
  __m128i v71; // [rsp+290h] [rbp-288h] BYREF
  __m128i v72; // [rsp+2A0h] [rbp-278h] BYREF
  __m128i v73; // [rsp+2B0h] [rbp-268h] BYREF
  __m128i v74; // [rsp+2C0h] [rbp-258h] BYREF
  __m128i v75; // [rsp+2D0h] [rbp-248h] BYREF
  __m128i v76; // [rsp+2E0h] [rbp-238h] BYREF
  __m128i v77; // [rsp+2F0h] [rbp-228h] BYREF
  __m128i v78; // [rsp+300h] [rbp-218h] BYREF
  __m128i v79; // [rsp+310h] [rbp-208h] BYREF
  __m128i v80; // [rsp+320h] [rbp-1F8h] BYREF
  __m128i v81; // [rsp+330h] [rbp-1E8h] BYREF
  __m128i v82; // [rsp+340h] [rbp-1D8h] BYREF
  __m128i v83; // [rsp+350h] [rbp-1C8h] BYREF
  __m128i v84; // [rsp+360h] [rbp-1B8h] BYREF
  __m128i v85; // [rsp+370h] [rbp-1A8h] BYREF
  __m128i v86; // [rsp+380h] [rbp-198h] BYREF
  __m128i v87; // [rsp+390h] [rbp-188h] BYREF
  __m128i v88; // [rsp+3A0h] [rbp-178h] BYREF
  __m128i v89; // [rsp+3B0h] [rbp-168h] BYREF
  __m128i v90; // [rsp+3C0h] [rbp-158h] BYREF
  __m128i v91; // [rsp+3D0h] [rbp-148h] BYREF
  __m128i v92; // [rsp+3E0h] [rbp-138h] BYREF
  __m128i v93; // [rsp+3F0h] [rbp-128h] BYREF
  __m128i v94; // [rsp+400h] [rbp-118h] BYREF
  __m128i v95; // [rsp+410h] [rbp-108h] BYREF
  __m128i v96; // [rsp+420h] [rbp-F8h] BYREF
  __m128i v97; // [rsp+430h] [rbp-E8h] BYREF
  __m128i v98; // [rsp+440h] [rbp-D8h] BYREF
  __m128i v99; // [rsp+450h] [rbp-C8h] BYREF
  __m128i v100; // [rsp+460h] [rbp-B8h] BYREF
  __m128i v101; // [rsp+470h] [rbp-A8h] BYREF
  __m128i v102; // [rsp+480h] [rbp-98h] BYREF
  __m128i v103; // [rsp+490h] [rbp-88h] BYREF
  __m128i v104; // [rsp+4A0h] [rbp-78h] BYREF
  __m128i v105; // [rsp+4B0h] [rbp-68h] BYREF
  __m128i v106; // [rsp+4C0h] [rbp-58h] BYREF
  __m128i v107; // [rsp+4D0h] [rbp-48h] BYREF
  __m128i v108; // [rsp+4E0h] [rbp-38h] BYREF
  const __m128i *v110; // [rsp+528h] [rbp+10h] BYREF
  __int64 v111; // [rsp+530h] [rbp+18h]
  unsigned __int8 v112; // [rsp+538h] [rbp+20h]

  v112 = a4;
  v111 = a3;
  v110 = a2;
  v43 = a2;
  v44 = a2;
  v37 = a2;
  v24 = 0x7FFF;
  v23 = 0x8000;
  if ( (unsigned __int64)sub_140024E60(a2, a3) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v28 = sub_140024E60(v110, v111) & 0xFFFFFFFFFFFFFFF0ui64;
    v53 = 0x100000i64;
    if ( v28 > 0x100000 )
      v28 = 0x100000i64;
    v36 = v110;
    sub_140024E30(&v36, v28);
    v55 = _mm_loadu_si128(v110);
    v4 = _mm_load_si128(&v55);
    v56 = v4;
    *(double *)v4.m128i_i64 = sub_140025FF0(&v56, v112);
    v35 = v4;
    v38 = _mm_load_si128(&v35);
    v57 = 0i64;
    v40 = _mm_load_si128(&v57);
    v39 = _mm_load_si128(&v35);
    v58 = 0i64;
    v41 = _mm_load_si128(&v58);
    v59 = 0i64;
    v42 = _mm_load_si128(&v59);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v110, 16i64);
        v5 = _mm_load_si128(&v42);
        v60 = v5;
        *(double *)v5.m128i_i64 = sub_1400259F0(&v60);
        v61 = v5;
        v42 = _mm_load_si128(&v61);
        if ( v110 == v36 )
          break;
        v92 = _mm_loadu_si128(v110);
        v17 = _mm_load_si128(&v92);
        v93 = v17;
        *(double *)v17.m128i_i64 = sub_140025FF0(&v93, v112);
        v94 = v17;
        v35 = _mm_load_si128(&v94);
        v95 = _mm_load_si128(&v35);
        v18 = _mm_load_si128(&v38);
        v96 = v18;
        *(double *)v18.m128i_i64 = sub_140025110(&v96, &v95);
        v45 = v18;
        v97 = _mm_blendv_epi8(_mm_load_si128(&v40), v42, _mm_load_si128(&v45));
        v40 = _mm_load_si128(&v97);
        v98 = _mm_load_si128(&v45);
        v99 = _mm_load_si128(&v35);
        v19 = _mm_load_si128(&v38);
        v100 = v19;
        *(double *)v19.m128i_i64 = sub_140025C80(&v100, &v99, &v98);
        v101 = v19;
        v38 = _mm_load_si128(&v101);
        v102 = _mm_load_si128(&v35);
        v20 = _mm_load_si128(&v39);
        v103 = v20;
        *(double *)v20.m128i_i64 = sub_140025110(&v103, &v102);
        v46 = v20;
        v104 = _mm_blendv_epi8(_mm_load_si128(&v42), v41, _mm_load_si128(&v46));
        v41 = _mm_load_si128(&v104);
        v105 = _mm_load_si128(&v46);
        v106 = _mm_load_si128(&v39);
        v21 = _mm_load_si128(&v35);
        v107 = v21;
        *(double *)v21.m128i_i64 = sub_140025B30(&v107, &v106, &v105);
        v108 = v21;
        v39 = _mm_load_si128(&v108);
      }
      v6 = _mm_load_si128(&v38);
      v62 = v6;
      *(double *)v6.m128i_i64 = sub_140025770(&v62);
      v47 = v6;
      v63 = _mm_load_si128(&v47);
      v25 = sub_1400252F0(&v63);
      if ( v25 < v24 )
      {
        v24 = v25;
        v64 = _mm_load_si128(&v38);
        v7 = _mm_load_si128(&v47);
        v65 = v7;
        *(double *)v7.m128i_i64 = sub_140025010(&v65, &v64);
        v48 = v7;
        v32 = _mm_movemask_epi8(_mm_load_si128(&v48));
        si128 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v67 = _mm_load_si128(&si128);
        v68 = _mm_blendv_epi8(_mm_load_si128(&v67), v40, _mm_load_si128(&v48));
        v49 = _mm_load_si128(&v68);
        v8 = _mm_load_si128(&v49);
        v69 = v8;
        *(double *)v8.m128i_i64 = sub_1400258B0(&v69);
        v70 = v8;
        v71 = _mm_load_si128(&v49);
        v9 = _mm_load_si128(&v70);
        v72 = v9;
        *(double *)v9.m128i_i64 = sub_140025010(&v72, &v71);
        v73 = v9;
        _BitScanForward(&v10, _mm_movemask_epi8(_mm_load_si128(&v73)) & v32);
        v34 = v10;
        v74 = _mm_load_si128(&v40);
        v30 = sub_1400253A0(&v74, v10);
        v43 = (const __m128i *)((char *)&v37[v30] + v34);
      }
      v11 = _mm_load_si128(&v39);
      v75 = v11;
      *(double *)v11.m128i_i64 = sub_1400254F0(&v75);
      v50 = v11;
      v76 = _mm_load_si128(&v50);
      v26 = sub_1400252F0(&v76);
      if ( v23 <= v26 )
      {
        v23 = v26;
        v77 = _mm_load_si128(&v39);
        v12 = _mm_load_si128(&v50);
        v78 = v12;
        *(double *)v12.m128i_i64 = sub_140025010(&v78, &v77);
        v51 = v12;
        v33 = _mm_movemask_epi8(_mm_load_si128(&v51));
        v79 = 0i64;
        v80 = _mm_blendv_epi8(_mm_load_si128(&v79), v41, _mm_load_si128(&v51));
        v52 = _mm_load_si128(&v80);
        v13 = _mm_load_si128(&v52);
        v81 = v13;
        *(double *)v13.m128i_i64 = sub_140025630(&v81);
        v82 = v13;
        v83 = _mm_load_si128(&v52);
        v14 = _mm_load_si128(&v82);
        v84 = v14;
        *(double *)v14.m128i_i64 = sub_140025010(&v84, &v83);
        v85 = v14;
        _BitScanReverse(&v15, _mm_movemask_epi8(_mm_load_si128(&v85)) & v33);
        v27 = v15 - 1;
        v86 = _mm_load_si128(&v41);
        v31 = sub_1400253A0(&v86, v15 - 1);
        v44 = (const __m128i *)((char *)&v37[v31] + v27);
      }
      v29 = sub_140024E60(v110, v111) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v29 )
        break;
      v54 = 0x100000i64;
      if ( v29 > 0x100000 )
        v29 = 0x100000i64;
      sub_140024E30(&v36, v29);
      v37 = v110;
      v87 = _mm_loadu_si128(v110);
      v16 = _mm_load_si128(&v87);
      v88 = v16;
      *(double *)v16.m128i_i64 = sub_140025FF0(&v88, v112);
      v89 = v16;
      v35 = _mm_load_si128(&v89);
      v38 = _mm_load_si128(&v35);
      v90 = 0i64;
      v40 = _mm_load_si128(&v90);
      v39 = _mm_load_si128(&v35);
      v91 = 0i64;
      v41 = _mm_load_si128(&v91);
    }
  }
  return a1;
}
// 140021590: using guessed type __int64 __fastcall sub_140021590(_DWORD, _DWORD, _DWORD, _DWORD, char, __int16, __int16);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025010: using guessed type double __fastcall sub_140025010(_QWORD, _QWORD);
// 140025110: using guessed type double __fastcall sub_140025110(_QWORD, _QWORD);
// 1400252F0: using guessed type __int64 __fastcall sub_1400252F0(_QWORD);
// 1400253A0: using guessed type __int64 __fastcall sub_1400253A0(_QWORD, _QWORD);
// 1400254F0: using guessed type double __fastcall sub_1400254F0(_QWORD);
// 140025630: using guessed type double __fastcall sub_140025630(_QWORD);
// 140025770: using guessed type double __fastcall sub_140025770(_QWORD);
// 1400258B0: using guessed type double __fastcall sub_1400258B0(_QWORD);
// 1400259F0: using guessed type double __fastcall sub_1400259F0(_QWORD);
// 140025B30: using guessed type double __fastcall sub_140025B30(_QWORD, _QWORD, _QWORD);
// 140025C80: using guessed type double __fastcall sub_140025C80(_QWORD, _QWORD, _QWORD);
// 140025FF0: using guessed type double __fastcall sub_140025FF0(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (000000014001F890) ----------------------------------------------------
__int64 __fastcall sub_14001F890(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4)
{
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  __m128i v9; // xmm0
  unsigned int v10; // eax
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  __m128i v18; // xmm0
  __m128i v19; // xmm0
  __m128i v20; // xmm0
  __m128i v21; // xmm0
  unsigned int v23; // [rsp+40h] [rbp-4D8h]
  unsigned __int64 v24; // [rsp+48h] [rbp-4D0h]
  unsigned __int64 v25; // [rsp+48h] [rbp-4D0h]
  int v26; // [rsp+50h] [rbp-4C8h]
  int v27; // [rsp+54h] [rbp-4C4h]
  signed int v28; // [rsp+58h] [rbp-4C0h]
  int v29; // [rsp+5Ch] [rbp-4BCh]
  int v30; // [rsp+60h] [rbp-4B8h]
  unsigned int v31; // [rsp+64h] [rbp-4B4h]
  signed int v32; // [rsp+68h] [rbp-4B0h]
  __m128i v33; // [rsp+70h] [rbp-4A8h] BYREF
  int v34; // [rsp+80h] [rbp-498h]
  int v35; // [rsp+84h] [rbp-494h]
  const __m128i *v36; // [rsp+88h] [rbp-490h] BYREF
  const __m128i *v37; // [rsp+90h] [rbp-488h]
  __m128i v38; // [rsp+A0h] [rbp-478h] BYREF
  __m128i v39; // [rsp+B0h] [rbp-468h] BYREF
  __m128i v40; // [rsp+C0h] [rbp-458h] BYREF
  __m128i v41; // [rsp+D0h] [rbp-448h] BYREF
  __m128i v42; // [rsp+E0h] [rbp-438h] BYREF
  const __m128i *v43; // [rsp+F0h] [rbp-428h]
  const __m128i *v44; // [rsp+F8h] [rbp-420h]
  __m128i v45; // [rsp+100h] [rbp-418h] BYREF
  __m128i v46; // [rsp+110h] [rbp-408h] BYREF
  __m128i v47; // [rsp+120h] [rbp-3F8h] BYREF
  __m128i v48; // [rsp+130h] [rbp-3E8h] BYREF
  __m128i v49; // [rsp+140h] [rbp-3D8h] BYREF
  __m128i v50; // [rsp+150h] [rbp-3C8h] BYREF
  __m128i v51; // [rsp+160h] [rbp-3B8h] BYREF
  __m128i v52; // [rsp+170h] [rbp-3A8h] BYREF
  __int64 v53; // [rsp+180h] [rbp-398h]
  __int64 v54; // [rsp+188h] [rbp-390h]
  __m128i v55; // [rsp+190h] [rbp-388h] BYREF
  __m128i v56; // [rsp+1A0h] [rbp-378h] BYREF
  __m128i v57; // [rsp+1B0h] [rbp-368h] BYREF
  __m128i v58; // [rsp+1C0h] [rbp-358h] BYREF
  __m128i v59; // [rsp+1D0h] [rbp-348h] BYREF
  __m128i v60; // [rsp+1E0h] [rbp-338h] BYREF
  __m128i v61; // [rsp+1F0h] [rbp-328h] BYREF
  __m128i v62; // [rsp+200h] [rbp-318h] BYREF
  __m128i v63; // [rsp+210h] [rbp-308h] BYREF
  __m128i v64; // [rsp+220h] [rbp-2F8h] BYREF
  __m128i v65; // [rsp+230h] [rbp-2E8h] BYREF
  __m128i si128; // [rsp+240h] [rbp-2D8h] BYREF
  __m128i v67; // [rsp+250h] [rbp-2C8h] BYREF
  __m128i v68; // [rsp+260h] [rbp-2B8h] BYREF
  __m128i v69; // [rsp+270h] [rbp-2A8h] BYREF
  __m128i v70; // [rsp+280h] [rbp-298h] BYREF
  __m128i v71; // [rsp+290h] [rbp-288h] BYREF
  __m128i v72; // [rsp+2A0h] [rbp-278h] BYREF
  __m128i v73; // [rsp+2B0h] [rbp-268h] BYREF
  __m128i v74; // [rsp+2C0h] [rbp-258h] BYREF
  __m128i v75; // [rsp+2D0h] [rbp-248h] BYREF
  __m128i v76; // [rsp+2E0h] [rbp-238h] BYREF
  __m128i v77; // [rsp+2F0h] [rbp-228h] BYREF
  __m128i v78; // [rsp+300h] [rbp-218h] BYREF
  __m128i v79; // [rsp+310h] [rbp-208h] BYREF
  __m128i v80; // [rsp+320h] [rbp-1F8h] BYREF
  __m128i v81; // [rsp+330h] [rbp-1E8h] BYREF
  __m128i v82; // [rsp+340h] [rbp-1D8h] BYREF
  __m128i v83; // [rsp+350h] [rbp-1C8h] BYREF
  __m128i v84; // [rsp+360h] [rbp-1B8h] BYREF
  __m128i v85; // [rsp+370h] [rbp-1A8h] BYREF
  __m128i v86; // [rsp+380h] [rbp-198h] BYREF
  __m128i v87; // [rsp+390h] [rbp-188h] BYREF
  __m128i v88; // [rsp+3A0h] [rbp-178h] BYREF
  __m128i v89; // [rsp+3B0h] [rbp-168h] BYREF
  __m128i v90; // [rsp+3C0h] [rbp-158h] BYREF
  __m128i v91; // [rsp+3D0h] [rbp-148h] BYREF
  __m128i v92; // [rsp+3E0h] [rbp-138h] BYREF
  __m128i v93; // [rsp+3F0h] [rbp-128h] BYREF
  __m128i v94; // [rsp+400h] [rbp-118h] BYREF
  __m128i v95; // [rsp+410h] [rbp-108h] BYREF
  __m128i v96; // [rsp+420h] [rbp-F8h] BYREF
  __m128i v97; // [rsp+430h] [rbp-E8h] BYREF
  __m128i v98; // [rsp+440h] [rbp-D8h] BYREF
  __m128i v99; // [rsp+450h] [rbp-C8h] BYREF
  __m128i v100; // [rsp+460h] [rbp-B8h] BYREF
  __m128i v101; // [rsp+470h] [rbp-A8h] BYREF
  __m128i v102; // [rsp+480h] [rbp-98h] BYREF
  __m128i v103; // [rsp+490h] [rbp-88h] BYREF
  __m128i v104; // [rsp+4A0h] [rbp-78h] BYREF
  __m128i v105; // [rsp+4B0h] [rbp-68h] BYREF
  __m128i v106; // [rsp+4C0h] [rbp-58h] BYREF
  __m128i v107; // [rsp+4D0h] [rbp-48h] BYREF
  __m128i v108; // [rsp+4E0h] [rbp-38h] BYREF
  const __m128i *v110; // [rsp+528h] [rbp+10h] BYREF
  __int64 v111; // [rsp+530h] [rbp+18h]
  unsigned __int8 v112; // [rsp+538h] [rbp+20h]

  v112 = a4;
  v111 = a3;
  v110 = a2;
  v43 = a2;
  v44 = a2;
  v37 = a2;
  v29 = 0x7FFFFFFF;
  v28 = 0x80000000;
  if ( (unsigned __int64)sub_140024E60(a2, a3) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v24 = sub_140024E60(v110, v111) & 0xFFFFFFFFFFFFFFF0ui64;
    v53 = 0x1000000000i64;
    if ( v24 > 0x1000000000i64 )
      v24 = 0x1000000000i64;
    v36 = v110;
    sub_140024E30(&v36, v24);
    v55 = _mm_loadu_si128(v110);
    v4 = _mm_load_si128(&v55);
    v56 = v4;
    *(double *)v4.m128i_i64 = sub_140026050(&v56, v112);
    v33 = v4;
    v38 = _mm_load_si128(&v33);
    v57 = 0i64;
    v40 = _mm_load_si128(&v57);
    v39 = _mm_load_si128(&v33);
    v58 = 0i64;
    v41 = _mm_load_si128(&v58);
    v59 = 0i64;
    v42 = _mm_load_si128(&v59);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_140024E30(&v110, 16i64);
        v5 = _mm_load_si128(&v42);
        v60 = v5;
        *(double *)v5.m128i_i64 = sub_140025A40(&v60);
        v61 = v5;
        v42 = _mm_load_si128(&v61);
        if ( v110 == v36 )
          break;
        v92 = _mm_loadu_si128(v110);
        v17 = _mm_load_si128(&v92);
        v93 = v17;
        *(double *)v17.m128i_i64 = sub_140026050(&v93, v112);
        v94 = v17;
        v33 = _mm_load_si128(&v94);
        v95 = _mm_load_si128(&v33);
        v18 = _mm_load_si128(&v38);
        v96 = v18;
        *(double *)v18.m128i_i64 = sub_140025150(&v96, &v95);
        v45 = v18;
        v97 = _mm_blendv_epi8(_mm_load_si128(&v40), v42, _mm_load_si128(&v45));
        v40 = _mm_load_si128(&v97);
        v98 = _mm_load_si128(&v45);
        v99 = _mm_load_si128(&v33);
        v19 = _mm_load_si128(&v38);
        v100 = v19;
        *(double *)v19.m128i_i64 = sub_140025CD0(&v100, &v99, &v98);
        v101 = v19;
        v38 = _mm_load_si128(&v101);
        v102 = _mm_load_si128(&v33);
        v20 = _mm_load_si128(&v39);
        v103 = v20;
        *(double *)v20.m128i_i64 = sub_140025150(&v103, &v102);
        v46 = v20;
        v104 = _mm_blendv_epi8(_mm_load_si128(&v42), v41, _mm_load_si128(&v46));
        v41 = _mm_load_si128(&v104);
        v105 = _mm_load_si128(&v46);
        v106 = _mm_load_si128(&v39);
        v21 = _mm_load_si128(&v33);
        v107 = v21;
        *(double *)v21.m128i_i64 = sub_140025B80(&v107, &v106, &v105);
        v108 = v21;
        v39 = _mm_load_si128(&v108);
      }
      v6 = _mm_load_si128(&v38);
      v62 = v6;
      *(double *)v6.m128i_i64 = sub_1400257C0(&v62);
      v47 = v6;
      v63 = _mm_load_si128(&v47);
      v30 = sub_140025310(&v63);
      if ( v30 < v29 )
      {
        v29 = v30;
        v64 = _mm_load_si128(&v38);
        v7 = _mm_load_si128(&v47);
        v65 = v7;
        *(double *)v7.m128i_i64 = sub_140025050(&v65, &v64);
        v48 = v7;
        v26 = _mm_movemask_epi8(_mm_load_si128(&v48));
        si128 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
        v67 = _mm_load_si128(&si128);
        v68 = _mm_blendv_epi8(_mm_load_si128(&v67), v40, _mm_load_si128(&v48));
        v49 = _mm_load_si128(&v68);
        v8 = _mm_load_si128(&v49);
        v69 = v8;
        *(double *)v8.m128i_i64 = sub_140025900(&v69);
        v70 = v8;
        v71 = _mm_load_si128(&v49);
        v9 = _mm_load_si128(&v70);
        v72 = v9;
        *(double *)v9.m128i_i64 = sub_140025050(&v72, &v71);
        v73 = v9;
        _BitScanForward(&v10, _mm_movemask_epi8(_mm_load_si128(&v73)) & v26);
        v31 = v10;
        v74 = _mm_load_si128(&v40);
        v34 = sub_140025400(&v74, v10);
        v43 = (const __m128i *)((char *)v37 + 16 * v34 + v31);
      }
      v11 = _mm_load_si128(&v39);
      v75 = v11;
      *(double *)v11.m128i_i64 = sub_140025540(&v75);
      v50 = v11;
      v76 = _mm_load_si128(&v50);
      v32 = sub_140025310(&v76);
      if ( v28 <= v32 )
      {
        v28 = v32;
        v77 = _mm_load_si128(&v39);
        v12 = _mm_load_si128(&v50);
        v78 = v12;
        *(double *)v12.m128i_i64 = sub_140025050(&v78, &v77);
        v51 = v12;
        v27 = _mm_movemask_epi8(_mm_load_si128(&v51));
        v79 = 0i64;
        v80 = _mm_blendv_epi8(_mm_load_si128(&v79), v41, _mm_load_si128(&v51));
        v52 = _mm_load_si128(&v80);
        v13 = _mm_load_si128(&v52);
        v81 = v13;
        *(double *)v13.m128i_i64 = sub_140025680(&v81);
        v82 = v13;
        v83 = _mm_load_si128(&v52);
        v14 = _mm_load_si128(&v82);
        v84 = v14;
        *(double *)v14.m128i_i64 = sub_140025050(&v84, &v83);
        v85 = v14;
        _BitScanReverse(&v15, _mm_movemask_epi8(_mm_load_si128(&v85)) & v27);
        v23 = v15 - 3;
        v86 = _mm_load_si128(&v41);
        v35 = sub_140025400(&v86, v15 - 3);
        v44 = (const __m128i *)((char *)v37 + 16 * v35 + v23);
      }
      v25 = sub_140024E60(v110, v111) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( !v25 )
        break;
      v54 = 0x1000000000i64;
      if ( v25 > 0x1000000000i64 )
        v25 = 0x1000000000i64;
      sub_140024E30(&v36, v25);
      v37 = v110;
      v87 = _mm_loadu_si128(v110);
      v16 = _mm_load_si128(&v87);
      v88 = v16;
      *(double *)v16.m128i_i64 = sub_140026050(&v88, v112);
      v89 = v16;
      v33 = _mm_load_si128(&v89);
      v38 = _mm_load_si128(&v33);
      v90 = 0i64;
      v40 = _mm_load_si128(&v90);
      v39 = _mm_load_si128(&v33);
      v91 = 0i64;
      v41 = _mm_load_si128(&v91);
    }
  }
  return a1;
}
// 1400216D0: using guessed type __int64 __fastcall sub_1400216D0(_DWORD, _DWORD, _DWORD, _DWORD, char, _DWORD, _DWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025050: using guessed type double __fastcall sub_140025050(_QWORD, _QWORD);
// 140025150: using guessed type double __fastcall sub_140025150(_QWORD, _QWORD);
// 140025310: using guessed type __int64 __fastcall sub_140025310(_QWORD);
// 140025400: using guessed type __int64 __fastcall sub_140025400(_QWORD, _QWORD);
// 140025540: using guessed type double __fastcall sub_140025540(_QWORD);
// 140025680: using guessed type double __fastcall sub_140025680(_QWORD);
// 1400257C0: using guessed type double __fastcall sub_1400257C0(_QWORD);
// 140025900: using guessed type double __fastcall sub_140025900(_QWORD);
// 140025A40: using guessed type double __fastcall sub_140025A40(_QWORD);
// 140025B80: using guessed type double __fastcall sub_140025B80(_QWORD, _QWORD, _QWORD);
// 140025CD0: using guessed type double __fastcall sub_140025CD0(_QWORD, _QWORD, _QWORD);
// 140026050: using guessed type double __fastcall sub_140026050(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (00000001400204D0) ----------------------------------------------------
__int64 __fastcall sub_1400204D0(__int64 a1, const __m128i *a2, __int64 a3, unsigned __int8 a4)
{
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  __m128i v9; // xmm0
  unsigned int v10; // eax
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  __m128i v18; // xmm0
  __m128i v19; // xmm0
  __m128i v20; // xmm0
  unsigned int v22; // [rsp+40h] [rbp-488h]
  int v23; // [rsp+44h] [rbp-484h]
  int v24; // [rsp+48h] [rbp-480h]
  unsigned int v25; // [rsp+4Ch] [rbp-47Ch]
  __m128i v26; // [rsp+60h] [rbp-468h] BYREF
  const __m128i *v27; // [rsp+70h] [rbp-458h] BYREF
  __int64 v28; // [rsp+78h] [rbp-450h]
  __int64 v29; // [rsp+80h] [rbp-448h]
  const __m128i *v30; // [rsp+88h] [rbp-440h]
  __m128i v31; // [rsp+90h] [rbp-438h] BYREF
  __m128i v32; // [rsp+A0h] [rbp-428h] BYREF
  __m128i v33; // [rsp+B0h] [rbp-418h] BYREF
  __m128i v34; // [rsp+C0h] [rbp-408h] BYREF
  __m128i v35; // [rsp+D0h] [rbp-3F8h] BYREF
  const __m128i *v36; // [rsp+E0h] [rbp-3E8h]
  const __m128i *v37; // [rsp+E8h] [rbp-3E0h]
  unsigned __int64 v38; // [rsp+F0h] [rbp-3D8h]
  __int64 v39; // [rsp+F8h] [rbp-3D0h]
  __int64 v40; // [rsp+100h] [rbp-3C8h]
  __m128i v41; // [rsp+110h] [rbp-3B8h] BYREF
  __m128i v42; // [rsp+120h] [rbp-3A8h] BYREF
  __m128i v43; // [rsp+130h] [rbp-398h] BYREF
  __m128i v44; // [rsp+140h] [rbp-388h] BYREF
  __m128i v45; // [rsp+150h] [rbp-378h] BYREF
  __m128i v46; // [rsp+160h] [rbp-368h] BYREF
  __m128i v47; // [rsp+170h] [rbp-358h] BYREF
  __m128i v48; // [rsp+180h] [rbp-348h] BYREF
  __m128i v49; // [rsp+190h] [rbp-338h] BYREF
  __m128i v50; // [rsp+1A0h] [rbp-328h] BYREF
  __m128i v51; // [rsp+1B0h] [rbp-318h] BYREF
  __m128i v52; // [rsp+1C0h] [rbp-308h] BYREF
  __m128i v53; // [rsp+1D0h] [rbp-2F8h] BYREF
  __m128i v54; // [rsp+1E0h] [rbp-2E8h] BYREF
  __m128i v55; // [rsp+1F0h] [rbp-2D8h] BYREF
  __m128i v56; // [rsp+200h] [rbp-2C8h] BYREF
  __m128i v57; // [rsp+210h] [rbp-2B8h] BYREF
  __m128i v58; // [rsp+220h] [rbp-2A8h] BYREF
  __m128i v59; // [rsp+230h] [rbp-298h] BYREF
  __m128i si128; // [rsp+240h] [rbp-288h] BYREF
  __m128i v61; // [rsp+250h] [rbp-278h] BYREF
  __m128i v62; // [rsp+260h] [rbp-268h] BYREF
  __m128i v63; // [rsp+270h] [rbp-258h] BYREF
  __m128i v64; // [rsp+280h] [rbp-248h] BYREF
  __m128i v65; // [rsp+290h] [rbp-238h] BYREF
  __m128i v66; // [rsp+2A0h] [rbp-228h] BYREF
  __m128i v67; // [rsp+2B0h] [rbp-218h] BYREF
  __m128i v68; // [rsp+2C0h] [rbp-208h] BYREF
  __m128i v69; // [rsp+2D0h] [rbp-1F8h] BYREF
  __m128i v70; // [rsp+2E0h] [rbp-1E8h] BYREF
  __m128i v71; // [rsp+2F0h] [rbp-1D8h] BYREF
  __m128i v72; // [rsp+300h] [rbp-1C8h] BYREF
  __m128i v73; // [rsp+310h] [rbp-1B8h] BYREF
  __m128i v74; // [rsp+320h] [rbp-1A8h] BYREF
  __m128i v75; // [rsp+330h] [rbp-198h] BYREF
  __m128i v76; // [rsp+340h] [rbp-188h] BYREF
  __m128i v77; // [rsp+350h] [rbp-178h] BYREF
  __m128i v78; // [rsp+360h] [rbp-168h] BYREF
  __m128i v79; // [rsp+370h] [rbp-158h] BYREF
  __m128i v80; // [rsp+380h] [rbp-148h] BYREF
  __m128i v81; // [rsp+390h] [rbp-138h] BYREF
  __m128i v82; // [rsp+3A0h] [rbp-128h] BYREF
  __m128i v83; // [rsp+3B0h] [rbp-118h] BYREF
  __m128i v84; // [rsp+3C0h] [rbp-108h] BYREF
  __m128i v85; // [rsp+3D0h] [rbp-F8h] BYREF
  __m128i v86; // [rsp+3E0h] [rbp-E8h] BYREF
  __m128i v87; // [rsp+3F0h] [rbp-D8h] BYREF
  __m128i v88; // [rsp+400h] [rbp-C8h] BYREF
  __m128i v89; // [rsp+410h] [rbp-B8h] BYREF
  __m128i v90; // [rsp+420h] [rbp-A8h] BYREF
  __m128i v91; // [rsp+430h] [rbp-98h] BYREF
  __m128i v92; // [rsp+440h] [rbp-88h] BYREF
  __m128i v93; // [rsp+450h] [rbp-78h] BYREF
  __m128i v94; // [rsp+460h] [rbp-68h] BYREF
  __m128i v95; // [rsp+470h] [rbp-58h] BYREF
  __m128i v96; // [rsp+480h] [rbp-48h] BYREF
  __m128i v97; // [rsp+490h] [rbp-38h] BYREF
  const __m128i *v99; // [rsp+4D8h] [rbp+10h] BYREF
  __int64 v100; // [rsp+4E0h] [rbp+18h]
  unsigned __int8 v101; // [rsp+4E8h] [rbp+20h]

  v101 = a4;
  v100 = a3;
  v99 = a2;
  v36 = a2;
  v37 = a2;
  v30 = a2;
  if ( (unsigned __int64)sub_140024E60(a2, a3) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    v38 = sub_140024E60(v99, v100) & 0xFFFFFFFFFFFFFFF0ui64;
    v27 = v99;
    sub_140024E30(&v27, v38);
    v49 = _mm_loadu_si128(v99);
    v4 = _mm_load_si128(&v49);
    v50 = v4;
    *(double *)v4.m128i_i64 = sub_1400260B0(&v50, v101);
    v26 = v4;
    v31 = _mm_load_si128(&v26);
    v51 = 0i64;
    v33 = _mm_load_si128(&v51);
    v32 = _mm_load_si128(&v26);
    v52 = 0i64;
    v35 = _mm_load_si128(&v52);
    v53 = 0i64;
    v34 = _mm_load_si128(&v53);
    while ( 1 )
    {
      sub_140024E30(&v99, 16i64);
      v5 = _mm_load_si128(&v34);
      v54 = v5;
      *(double *)v5.m128i_i64 = sub_140025A90(&v54);
      v55 = v5;
      v34 = _mm_load_si128(&v55);
      if ( v99 == v27 )
        break;
      v81 = _mm_loadu_si128(v99);
      v16 = _mm_load_si128(&v81);
      v82 = v16;
      *(double *)v16.m128i_i64 = sub_1400260B0(&v82, v101);
      v83 = v16;
      v26 = _mm_load_si128(&v83);
      v84 = _mm_load_si128(&v26);
      v17 = _mm_load_si128(&v31);
      v85 = v17;
      *(double *)v17.m128i_i64 = sub_140025190(&v85, &v84);
      v47 = v17;
      v86 = _mm_blendv_epi8(_mm_load_si128(&v33), v34, _mm_load_si128(&v47));
      v33 = _mm_load_si128(&v86);
      v87 = _mm_load_si128(&v47);
      v88 = _mm_load_si128(&v26);
      v18 = _mm_load_si128(&v31);
      v89 = v18;
      *(double *)v18.m128i_i64 = sub_140025D20(&v89, &v88, &v87);
      v90 = v18;
      v31 = _mm_load_si128(&v90);
      v91 = _mm_load_si128(&v26);
      v19 = _mm_load_si128(&v32);
      v92 = v19;
      *(double *)v19.m128i_i64 = sub_140025190(&v92, &v91);
      v48 = v19;
      v93 = _mm_blendv_epi8(_mm_load_si128(&v34), v35, _mm_load_si128(&v48));
      v35 = _mm_load_si128(&v93);
      v94 = _mm_load_si128(&v48);
      v95 = _mm_load_si128(&v32);
      v20 = _mm_load_si128(&v26);
      v96 = v20;
      *(double *)v20.m128i_i64 = sub_140025BD0(&v96, &v95, &v94);
      v97 = v20;
      v32 = _mm_load_si128(&v97);
    }
    v6 = _mm_load_si128(&v31);
    v56 = v6;
    *(double *)v6.m128i_i64 = sub_140025810(&v56);
    v41 = v6;
    v57 = _mm_load_si128(&v41);
    v28 = sub_140025330(&v57);
    if ( v28 != 0x7FFFFFFFFFFFFFFFi64 )
    {
      v58 = _mm_load_si128(&v31);
      v7 = _mm_load_si128(&v41);
      v59 = v7;
      *(double *)v7.m128i_i64 = sub_140025090(&v59, &v58);
      v42 = v7;
      v23 = _mm_movemask_epi8(_mm_load_si128(&v42));
      si128 = _mm_load_si128((const __m128i *)&xmmword_140032F50);
      v61 = _mm_load_si128(&si128);
      v62 = _mm_blendv_epi8(_mm_load_si128(&v61), v33, _mm_load_si128(&v42));
      v43 = _mm_load_si128(&v62);
      v8 = _mm_load_si128(&v43);
      v63 = v8;
      *(double *)v8.m128i_i64 = sub_140025950(&v63);
      v64 = v8;
      v65 = _mm_load_si128(&v43);
      v9 = _mm_load_si128(&v64);
      v66 = v9;
      *(double *)v9.m128i_i64 = sub_140025090(&v66, &v65);
      v67 = v9;
      _BitScanForward(&v10, _mm_movemask_epi8(_mm_load_si128(&v67)) & v23);
      v25 = v10;
      v68 = _mm_load_si128(&v33);
      v39 = sub_140025460(&v68, v10);
      v36 = (const __m128i *)((char *)&v30[v39] + v25);
    }
    v11 = _mm_load_si128(&v32);
    v69 = v11;
    *(double *)v11.m128i_i64 = sub_140025590(&v69);
    v44 = v11;
    v70 = _mm_load_si128(&v44);
    v29 = sub_140025330(&v70);
    v71 = _mm_load_si128(&v32);
    v12 = _mm_load_si128(&v44);
    v72 = v12;
    *(double *)v12.m128i_i64 = sub_140025090(&v72, &v71);
    v45 = v12;
    v24 = _mm_movemask_epi8(_mm_load_si128(&v45));
    v73 = 0i64;
    v74 = _mm_blendv_epi8(_mm_load_si128(&v73), v35, _mm_load_si128(&v45));
    v46 = _mm_load_si128(&v74);
    v13 = _mm_load_si128(&v46);
    v75 = v13;
    *(double *)v13.m128i_i64 = sub_1400256D0(&v75);
    v76 = v13;
    v77 = _mm_load_si128(&v46);
    v14 = _mm_load_si128(&v76);
    v78 = v14;
    *(double *)v14.m128i_i64 = sub_140025090(&v78, &v77);
    v79 = v14;
    _BitScanReverse(&v15, _mm_movemask_epi8(_mm_load_si128(&v79)) & v24);
    v22 = v15 - 7;
    v80 = _mm_load_si128(&v35);
    v40 = sub_140025460(&v80, v15 - 7);
    v37 = (const __m128i *)((char *)&v30[v40] + v22);
  }
  return a1;
}
// 140021800: using guessed type __int64 __fastcall sub_140021800(_DWORD, _DWORD, _DWORD, _DWORD, char, __int64, __int64);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140025090: using guessed type double __fastcall sub_140025090(_QWORD, _QWORD);
// 140025190: using guessed type double __fastcall sub_140025190(_QWORD, _QWORD);
// 140025330: using guessed type __int64 __fastcall sub_140025330(_QWORD);
// 140025460: using guessed type __int64 __fastcall sub_140025460(_QWORD, _QWORD);
// 140025590: using guessed type double __fastcall sub_140025590(_QWORD);
// 1400256D0: using guessed type double __fastcall sub_1400256D0(_QWORD);
// 140025810: using guessed type double __fastcall sub_140025810(_QWORD);
// 140025950: using guessed type double __fastcall sub_140025950(_QWORD);
// 140025A90: using guessed type double __fastcall sub_140025A90(_QWORD);
// 140025BD0: using guessed type double __fastcall sub_140025BD0(_QWORD, _QWORD, _QWORD);
// 140025D20: using guessed type double __fastcall sub_140025D20(_QWORD, _QWORD, _QWORD);
// 1400260B0: using guessed type double __fastcall sub_1400260B0(_QWORD, _QWORD);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032F50: using guessed type __int128 xmmword_140032F50;

//----- (0000000140020F80) ----------------------------------------------------
__int64 __fastcall sub_140020F80(__int64 a1, __int64 a2, _QWORD *a3, char a4, unsigned __int8 a5)
{
  char v6; // [rsp+20h] [rbp-18h]

  v6 = 0x80;
  if ( a4 )
    return sub_140019EC0(a1, a2, *a3, a5, v6);
  else
    return sub_140019F50(a1, a2, *a3, (unsigned __int8)(a5 + 0x80), v6);
}
// 140019EC0: using guessed type __int64 __fastcall sub_140019EC0(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 140019F50: using guessed type __int64 __fastcall sub_140019F50(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (0000000140021010) ----------------------------------------------------
__int16 *__fastcall sub_140021010(__int16 *a1, __int16 *a2, __int16 **a3, char a4, __int16 a5)
{
  if ( a4 )
    return sub_140019FE0(a1, a2, *a3, a5);
  else
    return (__int16 *)sub_14001A070(
                        (unsigned __int16 *)a1,
                        (unsigned __int16 *)a2,
                        (unsigned __int16 *)*a3,
                        a5 + 0x8000);
}

//----- (00000001400210B0) ----------------------------------------------------
unsigned int *__fastcall sub_1400210B0(unsigned int *a1, unsigned int *a2, unsigned int **a3, char a4, int a5)
{
  if ( a4 )
    return sub_14001A100(a1, a2, *a3, a5);
  else
    return sub_14001A180(a1, a2, *a3, a5 + 0x80000000);
}

//----- (0000000140021140) ----------------------------------------------------
unsigned __int64 *__fastcall sub_140021140(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 **a3,
        char a4,
        __int64 a5)
{
  if ( a4 )
    return sub_14001A200(a1, a2, *a3, a5);
  else
    return sub_14001A290(a1, a2, *a3, a5 + 0x8000000000000000ui64);
}

//----- (00000001400211F0) ----------------------------------------------------
__int64 __fastcall sub_1400211F0(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, unsigned __int8 a6)
{
  char v7; // [rsp+20h] [rbp-18h]

  v7 = 0x80;
  if ( a4 )
    return sub_140019A60(a1, a2, *(_QWORD *)(a3 + 8), a6, v7);
  else
    return sub_140019AF0(a1, a2, *(_QWORD *)(a3 + 8), (unsigned __int8)(a6 + 0x80), v7);
}
// 140019A60: using guessed type __int64 __fastcall sub_140019A60(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 140019AF0: using guessed type __int64 __fastcall sub_140019AF0(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (0000000140021280) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140021280(
        unsigned __int16 *a1,
        unsigned __int16 *a2,
        __int64 a3,
        char a4,
        int a5,
        __int16 a6)
{
  if ( a4 )
    return sub_140019B80(a1, a2, *(_WORD **)(a3 + 8), a6);
  else
    return sub_140019C10(a1, a2, *(unsigned __int16 **)(a3 + 8), a6 + 0x8000);
}

//----- (0000000140021320) ----------------------------------------------------
unsigned int *__fastcall sub_140021320(unsigned int *a1, unsigned int *a2, __int64 a3, char a4, int a5, int a6)
{
  if ( a4 )
    return sub_140019CA0(a1, a2, *(_DWORD **)(a3 + 8), a6);
  else
    return sub_140019D20(a1, a2, *(unsigned int **)(a3 + 8), a6 + 0x80000000);
}

//----- (00000001400213B0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_1400213B0(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        __int64 a3,
        char a4,
        int a5,
        __int64 a6)
{
  if ( a4 )
    return sub_140019DA0(a1, a2, *(_QWORD **)(a3 + 8), a6);
  else
    return sub_140019E30(a1, a2, *(unsigned __int64 **)(a3 + 8), a6 + 0x8000000000000000ui64);
}

//----- (0000000140021460) ----------------------------------------------------
char **__fastcall sub_140021460(char **a1, char *a2, char *a3, char **a4, char a5, char a6, char a7)
{
  char v8[16]; // [rsp+38h] [rbp-40h] BYREF
  char v9[16]; // [rsp+48h] [rbp-30h] BYREF

  if ( a5 )
    qmemcpy(v8, sub_140017670(a1, a2, a3, a4, a6, a7), sizeof(v8));
  else
    qmemcpy(v9, sub_140017750(a1, a2, a3, a4, a6 + 0x80, a7 + 0x80), sizeof(v9));
  return a1;
}

//----- (0000000140021590) ----------------------------------------------------
__int16 **__fastcall sub_140021590(
        __int16 **a1,
        __int16 *a2,
        __int16 *a3,
        __int16 **a4,
        char a5,
        __int16 a6,
        __int16 a7)
{
  char v8[16]; // [rsp+38h] [rbp-40h] BYREF
  char v9[16]; // [rsp+48h] [rbp-30h] BYREF

  if ( a5 )
    qmemcpy(v8, sub_140017830(a1, a2, a3, a4, a6, a7), sizeof(v8));
  else
    qmemcpy(v9, sub_140017910(a1, a2, a3, a4, a6 + 0x8000, a7 + 0x8000), sizeof(v9));
  return a1;
}

//----- (00000001400216D0) ----------------------------------------------------
int **__fastcall sub_1400216D0(int **a1, int *a2, int *a3, int **a4, char a5, int a6, int a7)
{
  char v8[16]; // [rsp+38h] [rbp-40h] BYREF
  char v9[16]; // [rsp+48h] [rbp-30h] BYREF

  if ( a5 )
    qmemcpy(v8, sub_1400179F0(a1, a2, a3, a4, a6, a7), sizeof(v8));
  else
    qmemcpy(
      v9,
      sub_140017AC0(
        (unsigned int **)a1,
        (unsigned int *)a2,
        (unsigned int *)a3,
        (unsigned int **)a4,
        a6 + 0x80000000,
        a7 + 0x80000000),
      sizeof(v9));
  return a1;
}

//----- (0000000140021800) ----------------------------------------------------
__int64 **__fastcall sub_140021800(
        __int64 **a1,
        __int64 *a2,
        __int64 *a3,
        __int64 **a4,
        char a5,
        __int64 a6,
        __int64 a7)
{
  char v8[16]; // [rsp+38h] [rbp-40h] BYREF
  char v9[16]; // [rsp+48h] [rbp-30h] BYREF

  if ( a5 )
    qmemcpy(v8, sub_140017B90(a1, a2, a3, a4, a6, a7), sizeof(v8));
  else
    qmemcpy(v9, sub_140017C70(a1, a2, a3, a4, a6 + 0x8000000000000000ui64, a7 + 0x8000000000000000ui64), sizeof(v9));
  return a1;
}

//----- (0000000140021960) ----------------------------------------------------
__int64 __fastcall sub_140021960(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 result; // rax

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    *a3++ = *(_BYTE *)--a2;
  }
  return result;
}

//----- (00000001400219C0) ----------------------------------------------------
_WORD *__fastcall sub_1400219C0(_WORD *a1, _WORD *a2, _WORD *a3)
{
  _WORD *result; // rax

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    *a3++ = *--a2;
  }
  return result;
}

//----- (0000000140021A20) ----------------------------------------------------
_DWORD *__fastcall sub_140021A20(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // rax

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    *a3++ = *--a2;
  }
  return result;
}

//----- (0000000140021A80) ----------------------------------------------------
_QWORD *__fastcall sub_140021A80(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *result; // rax

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    *a3++ = *--a2;
  }
  return result;
}

//----- (0000000140021AE0) ----------------------------------------------------
char *__fastcall sub_140021AE0(char *a1, char *a2)
{
  char *result; // rax
  char v3; // [rsp+0h] [rbp-18h]

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    result = --a2;
    if ( a1 == a2 )
      break;
    v3 = *a1;
    *a1 = *a2;
    *a2 = v3;
    ++a1;
  }
  return result;
}

//----- (0000000140021B70) ----------------------------------------------------
__int16 *__fastcall sub_140021B70(__int16 *a1, __int16 *a2)
{
  __int16 *result; // rax
  __int16 v3; // [rsp+0h] [rbp-18h]

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    result = --a2;
    if ( a1 == a2 )
      break;
    v3 = *a1;
    *a1 = *a2;
    *a2 = v3;
    ++a1;
  }
  return result;
}

//----- (0000000140021C00) ----------------------------------------------------
int *__fastcall sub_140021C00(int *a1, int *a2)
{
  int *result; // rax
  int v3; // [rsp+0h] [rbp-18h]

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    result = --a2;
    if ( a1 == a2 )
      break;
    v3 = *a1;
    *a1 = *a2;
    *a2 = v3;
    ++a1;
  }
  return result;
}

//----- (0000000140021C90) ----------------------------------------------------
__int64 *__fastcall sub_140021C90(__int64 *a1, __int64 *a2)
{
  __int64 *result; // rax
  __int64 v3; // [rsp+0h] [rbp-18h]

  while ( 1 )
  {
    result = a2;
    if ( a1 == a2 )
      break;
    result = --a2;
    if ( a1 == a2 )
      break;
    v3 = *a1;
    *a1 = *a2;
    *a2 = v3;
    ++a1;
  }
  return result;
}

//----- (0000000140021D20) ----------------------------------------------------
__int64 __fastcall sub_140021D20(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  double v3; // xmm1_8
  __int64 v14; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v15; // [rsp+1B0h] [rbp+170h] BYREF
  unsigned __int8 *v16; // [rsp+1B8h] [rbp+178h]
  unsigned __int8 v17; // [rsp+1C0h] [rbp+180h]

  v17 = a3;
  v16 = a2;
  v15 = (__m128i *)a1;
  _RBP = (const __m128i *)((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) = 0i64;
  *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025D80(v17, v3);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v15;
    sub_140024E30(
      (const __m128i *)_RBP[2].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v15;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024E90((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      *(_DWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      sub_140024E30(&v15, 32i64);
    }
    while ( v15 != *(__m128i **)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) && sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025EB0(v17);
    *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v15;
    sub_140024E30(
      (const __m128i *)_RBP[3].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    do
    {
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v15);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_1400251D0(
                                                                                 _RBP + 8,
                                                                                 (__m128i *)&_RBP[7]);
      *(_DWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      sub_140024E30(&v15, 16i64);
    }
    while ( v15 != *(__m128i **)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) );
  }
  return sub_140017D50((unsigned __int8 *)v15, v16, _RBP->m128i_i64[0], v17);
}
// 140021D90: variable 'v3' is possibly undefined

//----- (0000000140022010) ----------------------------------------------------
__int64 __fastcall sub_140022010(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3)
{
  __int64 v13; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v14; // [rsp+1B0h] [rbp+170h] BYREF
  unsigned __int16 *v15; // [rsp+1B8h] [rbp+178h]
  __int16 v16; // [rsp+1C0h] [rbp+180h]

  v16 = a3;
  v15 = a2;
  v14 = (__m128i *)a1;
  _RBP = (const __m128i *)((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) = 0i64;
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025DD0(v16);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v14;
    sub_140024E30(
      (const __m128i *)_RBP[2].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v14;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024EE0((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      *(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      sub_140024E30(&v14, 32i64);
    }
    while ( v14 != *(__m128i **)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) && sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025EF0(v16);
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v14;
    sub_140024E30(
      (const __m128i *)_RBP[3].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    do
    {
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v14);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_140025210(
                                                                                 _RBP + 8,
                                                                                 (__m128i *)&_RBP[7]);
      *(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      sub_140024E30(&v14, 16i64);
    }
    while ( v14 != *(__m128i **)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) );
  }
  return sub_140017DD0((unsigned __int16 *)v14, v15, (unsigned __int64)_RBP->m128i_i64[0] >> 1, v16);
}

//----- (0000000140022310) ----------------------------------------------------
__int64 __fastcall sub_140022310(__m128i *a1, _DWORD *a2, unsigned int a3)
{
  __int64 v13; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v14; // [rsp+1B0h] [rbp+170h] BYREF
  _DWORD *v15; // [rsp+1B8h] [rbp+178h]
  unsigned int v16; // [rsp+1C0h] [rbp+180h]

  v16 = a3;
  v15 = a2;
  v14 = a1;
  _RBP = (const __m128i *)((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) = 0i64;
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025E20(v16);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v14;
    sub_140024E30(
      (const __m128i *)_RBP[2].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v14;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024F30((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      *(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      sub_140024E30(&v14, 32i64);
    }
    while ( v14 != *(__m128i **)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) && sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025F30(v16);
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v14;
    sub_140024E30(
      (const __m128i *)_RBP[3].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    do
    {
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v14);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_140025250(
                                                                                 _RBP + 8,
                                                                                 (__m128i *)&_RBP[7]);
      *(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      sub_140024E30(&v14, 16i64);
    }
    while ( v14 != *(__m128i **)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) );
  }
  return sub_140017E50(v14, v15, (unsigned __int64)_RBP->m128i_i64[0] >> 2, v16);
}

//----- (0000000140022610) ----------------------------------------------------
__int64 __fastcall sub_140022610(__m128i *a1, _QWORD *a2, __int64 a3)
{
  __int64 v13; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v14; // [rsp+1B0h] [rbp+170h] BYREF
  _QWORD *v15; // [rsp+1B8h] [rbp+178h]
  __int64 v16; // [rsp+1C0h] [rbp+180h]

  v16 = a3;
  v15 = a2;
  v14 = a1;
  _RBP = (const __m128i *)((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) = 0i64;
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025E70(v16);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v14;
    sub_140024E30(
      (const __m128i *)_RBP[2].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v14;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024F80((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      *(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      sub_140024E30(&v14, 32i64);
    }
    while ( v14 != *(__m128i **)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) && sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025F60(v16);
    *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v14;
    sub_140024E30(
      (const __m128i *)_RBP[3].m128i_i64,
      *(_QWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    do
    {
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v14);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_140025290(
                                                                                 _RBP + 8,
                                                                                 (__m128i *)&_RBP[7]);
      *(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
      _RBP->m128i_i64[0] += __popcnt(*(_DWORD *)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      sub_140024E30(&v14, 16i64);
    }
    while ( v14 != *(__m128i **)(((unsigned __int64)&v13 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) );
  }
  return sub_140017ED0(v14, v15, (unsigned __int64)_RBP->m128i_i64[0] >> 3, v16);
}

//----- (0000000140022910) ----------------------------------------------------
__m128i *__fastcall sub_140022910(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  double v3; // xmm1_8
  unsigned int v15; // eax
  int v16; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v17; // [rsp+1B0h] [rbp+170h] BYREF
  unsigned __int8 *v18; // [rsp+1B8h] [rbp+178h]
  unsigned __int8 v19; // [rsp+1C0h] [rbp+180h]

  v19 = a3;
  v18 = a2;
  v17 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025D80(v19, v3);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v17;
    sub_140024E30((__m128i *)_RBP[2].m128i_i64, *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v17;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024E90((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      _RBP->m128i_i32[0] = _EAX;
      if ( _RBP->m128i_i32[0] )
      {
        __asm { tzcnt   eax, [rbp+160h+var_160] }
        *(_DWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
        sub_140024E30(&v17, *(unsigned int *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
        return v17;
      }
      sub_140024E30(&v17, 32i64);
    }
    while ( v17 != *(__m128i **)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( !*(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) || !sub_140026110() )
    return (__m128i *)sub_140017F50((unsigned __int8 *)v17, v18, v19);
  *(__m128i *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025EB0(v19);
  *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v17;
  sub_140024E30((__m128i *)_RBP[3].m128i_i64, *(_QWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
  while ( 1 )
  {
    *(__m128i *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v17);
    *(__m128i *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
    *(__m128i *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_1400251D0(_RBP + 8, _RBP + 7);
    *(_DWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
    if ( *(_DWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
      break;
    sub_140024E30(&v17, 16i64);
    if ( v17 == *(__m128i **)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) )
      return (__m128i *)sub_140017F50((unsigned __int8 *)v17, v18, v19);
  }
  _BitScanForward(&v15, *(_DWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
  *(_DWORD *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = v15;
  sub_140024E30(&v17, *(unsigned int *)(((unsigned __int64)&v16 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
  return v17;
}
// 140022978: variable 'v3' is possibly undefined

//----- (0000000140022C30) ----------------------------------------------------
__m128i *__fastcall sub_140022C30(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3)
{
  unsigned int v14; // eax
  int v15; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v16; // [rsp+1B0h] [rbp+170h] BYREF
  unsigned __int16 *v17; // [rsp+1B8h] [rbp+178h]
  __int16 v18; // [rsp+1C0h] [rbp+180h]

  v18 = a3;
  v17 = a2;
  v16 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025DD0(v18);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v16;
    sub_140024E30((__m128i *)_RBP[2].m128i_i64, *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v16;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024EE0((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      _RBP->m128i_i32[0] = _EAX;
      if ( _RBP->m128i_i32[0] )
      {
        __asm { tzcnt   eax, [rbp+160h+var_160] }
        *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
        sub_140024E30(&v16, *(unsigned int *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
        return v16;
      }
      sub_140024E30(&v16, 32i64);
    }
    while ( v16 != *(__m128i **)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( !*(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) || !sub_140026130() )
    return (__m128i *)sub_140017FB0((unsigned __int16 *)v16, v17, v18);
  *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025EF0(v18);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v16;
  sub_140024E30((__m128i *)_RBP[3].m128i_i64, *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
  while ( 1 )
  {
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v16);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_140025210(_RBP + 8, _RBP + 7);
    *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
    if ( *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
      break;
    sub_140024E30(&v16, 16i64);
    if ( v16 == *(__m128i **)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) )
      return (__m128i *)sub_140017FB0((unsigned __int16 *)v16, v17, v18);
  }
  _BitScanForward(&v14, *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
  *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = v14;
  sub_140024E30(&v16, *(unsigned int *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
  return v16;
}

//----- (0000000140022F50) ----------------------------------------------------
__m128i *__fastcall sub_140022F50(__m128i *a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v14; // eax
  int v15; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v16; // [rsp+1B0h] [rbp+170h] BYREF
  _DWORD *v17; // [rsp+1B8h] [rbp+178h]
  unsigned int v18; // [rsp+1C0h] [rbp+180h]

  v18 = a3;
  v17 = a2;
  v16 = a1;
  _RBP = (__m128i *)((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025E20(v18);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v16;
    sub_140024E30((__m128i *)_RBP[2].m128i_i64, *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v16;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024F30((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      _RBP->m128i_i32[0] = _EAX;
      if ( _RBP->m128i_i32[0] )
      {
        __asm { tzcnt   eax, [rbp+160h+var_160] }
        *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
        sub_140024E30(&v16, *(unsigned int *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
        return v16;
      }
      sub_140024E30(&v16, 32i64);
    }
    while ( v16 != *(__m128i **)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( !*(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) || !sub_140026150() )
    return (__m128i *)sub_140018020(v16, v17, v18);
  *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025F30(v18);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v16;
  sub_140024E30((__m128i *)_RBP[3].m128i_i64, *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
  while ( 1 )
  {
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v16);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_140025250(_RBP + 8, _RBP + 7);
    *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
    if ( *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
      break;
    sub_140024E30(&v16, 16i64);
    if ( v16 == *(__m128i **)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) )
      return (__m128i *)sub_140018020(v16, v17, v18);
  }
  _BitScanForward(&v14, *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
  *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = v14;
  sub_140024E30(&v16, *(unsigned int *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
  return v16;
}

//----- (0000000140023270) ----------------------------------------------------
__m128i *__fastcall sub_140023270(__m128i *a1, _QWORD *a2, __int64 a3)
{
  unsigned int v14; // eax
  int v15; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v16; // [rsp+1B0h] [rbp+170h] BYREF
  _QWORD *v17; // [rsp+1B8h] [rbp+178h]
  __int64 v18; // [rsp+1C0h] [rbp+180h]

  v18 = a3;
  v17 = a2;
  v16 = a1;
  _RBP = (__m128i *)((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = sub_140024E60((__int64)a1, (__int64)a2);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) && sub_140026190() )
  {
    sub_140025E70(v18);
    __asm { vmovdqu [rbp+160h+var_A0], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v16;
    sub_140024E30((__m128i *)_RBP[2].m128i_i64, *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18));
    do
    {
      _RAX = v16;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+160h+var_C0], ymm0
        vmovdqu ymm0, [rbp+160h+var_C0]
        vmovdqu [rbp+160h+var_80], ymm0
        vmovdqu ymm0, [rbp+160h+var_A0]
        vmovdqu [rbp+160h+var_60], ymm0
        vmovdqu ymm0, [rbp+160h+var_80]
        vmovdqu [rbp+160h+var_40], ymm0
      }
      sub_140024F80((__int64)_RBP[18].m128i_i64);
      __asm
      {
        vmovdqu [rbp+160h+var_20], ymm0
        vmovdqu ymm0, [rbp+160h+var_20]
        vpmovmskb eax, ymm0
      }
      _RBP->m128i_i32[0] = _EAX;
      if ( _RBP->m128i_i32[0] )
      {
        __asm { tzcnt   eax, [rbp+160h+var_160] }
        *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
        sub_140024E30(&v16, *(unsigned int *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
        return v16;
      }
      sub_140024E30(&v16, 32i64);
    }
    while ( v16 != *(__m128i **)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
    *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 8) &= 0x1Fui64;
  }
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 8) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( !*(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) || !sub_140026170() )
    return (__m128i *)sub_140018080(v16, v17, v18);
  *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025F60(v18);
  *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v16;
  sub_140024E30((__m128i *)_RBP[3].m128i_i64, *(_QWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
  while ( 1 )
  {
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v16);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 6);
    *(__m128i *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = sub_140025290(_RBP + 8, _RBP + 7);
    *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 9));
    if ( *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
      break;
    sub_140024E30(&v16, 16i64);
    if ( v16 == *(__m128i **)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) )
      return (__m128i *)sub_140018080(v16, v17, v18);
  }
  _BitScanForward(&v14, *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
  *(_DWORD *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = v14;
  sub_140024E30(&v16, *(unsigned int *)(((unsigned __int64)&v15 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
  return v16;
}

//----- (0000000140023590) ----------------------------------------------------
__m128i *__fastcall sub_140023590(unsigned __int8 *a1, unsigned __int8 a2)
{
  double v2; // xmm1_8
  __int64 v5; // rax
  __int64 v23; // rax
  unsigned int v24; // eax
  unsigned int v25; // eax
  int v26; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v27; // [rsp+290h] [rbp+250h] BYREF
  unsigned __int8 v28; // [rsp+298h] [rbp+258h]

  v28 = a2;
  v27 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( sub_140026190() )
  {
    *(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = 31i64;
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = -1;
    sub_140025D80(v28, v2);
    __asm { vmovdqu [rbp+240h+var_120], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = (unsigned __int8)v27 & 0x1F;
    v5 = *(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28);
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = -1;
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) = *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                     + 8) << v5;
    sub_140024E30(&v27, -*(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    _RAX = v27;
    __asm
    {
      vmovdqu ymm0, ymmword ptr [rax]
      vmovdqu [rbp+240h+var_100], ymm0
      vmovdqu ymm0, [rbp+240h+var_100]
      vmovdqu [rbp+240h+var_140], ymm0
      vmovdqu ymm0, [rbp+240h+var_120]
      vmovdqu [rbp+240h+var_E0], ymm0
      vmovdqu ymm0, [rbp+240h+var_140]
      vmovdqu [rbp+240h+var_C0], ymm0
    }
    sub_140024E90((__int64)_RBP[24].m128i_i64);
    __asm
    {
      vmovdqu [rbp+240h+var_A0], ymm0
      vmovdqu ymm0, [rbp+240h+var_A0]
      vpmovmskb eax, ymm0
    }
    _RBP->m128i_i32[0] = _EAX;
    _RBP->m128i_i32[0] = *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) & *(_DWORD *)((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64);
    if ( _RBP->m128i_i32[0] )
    {
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      sub_140024E30(&v27, *(unsigned int *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      return v27;
    }
    else
    {
      while ( 1 )
      {
        _RAX = v27;
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rax]
          vmovdqu [rbp+240h+var_80], ymm0
          vmovdqu ymm0, [rbp+240h+var_80]
          vmovdqu [rbp+240h+var_140], ymm0
          vmovdqu ymm0, [rbp+240h+var_120]
          vmovdqu [rbp+240h+var_60], ymm0
          vmovdqu ymm0, [rbp+240h+var_140]
          vmovdqu [rbp+240h+var_40], ymm0
        }
        sub_140024E90((__int64)_RBP[32].m128i_i64);
        __asm
        {
          vmovdqu [rbp+240h+var_20], ymm0
          vmovdqu ymm0, [rbp+240h+var_20]
          vpmovmskb eax, ymm0
        }
        _RBP->m128i_i32[0] = _EAX;
        if ( _RBP->m128i_i32[0] )
          break;
        sub_140024E30(&v27, 32i64);
      }
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _EAX;
      sub_140024E30(&v27, *(unsigned int *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      return v27;
    }
  }
  else if ( sub_140026110() )
  {
    *(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x68) = 15i64;
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x3C) = 0xFFFF;
    *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025EB0(v28);
    *(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = (unsigned __int8)v27 & 0xF;
    v23 = *(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30);
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = 0xFFFF;
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1C) = *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                      + 0x18) << v23;
    sub_140024E30(&v27, -*(_QWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30));
    *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_loadu_si128(v27);
    *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 7);
    *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xA0) = sub_1400251D0(_RBP + 9, _RBP + 8);
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 10));
    *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4) &= *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 0x1C);
    if ( *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
    {
      _BitScanForward(&v24, *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v24;
      sub_140024E30(&v27, *(unsigned int *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20));
      return v27;
    }
    else
    {
      while ( 1 )
      {
        *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xB0) = _mm_loadu_si128(v27);
        *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 11);
        *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC0) = _mm_load_si128(_RBP + 5);
        *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xD0) = _mm_load_si128(_RBP + 4);
        *(__m128i *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0xE0) = sub_1400251D0(_RBP + 13, _RBP + 12);
        *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 14));
        if ( *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
          break;
        sub_140024E30(&v27, 16i64);
      }
      _BitScanForward(&v25, *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24) = v25;
      sub_140024E30(&v27, *(unsigned int *)(((unsigned __int64)&v26 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24));
      return v27;
    }
  }
  else
  {
    return (__m128i *)sub_1400180E0((unsigned __int8 *)v27, v28);
  }
}
// 1400235D1: variable 'v2' is possibly undefined

//----- (0000000140023A40) ----------------------------------------------------
__m128i *__fastcall sub_140023A40(unsigned __int16 *a1, __int16 a2)
{
  __int64 v4; // rax
  __int64 v22; // rax
  unsigned int v23; // eax
  unsigned int v24; // eax
  int v25; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v26; // [rsp+290h] [rbp+250h] BYREF
  __int16 v27; // [rsp+298h] [rbp+258h]

  v27 = a2;
  v26 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( sub_140026190() )
  {
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = 31i64;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = -1;
    sub_140025DD0(v27);
    __asm { vmovdqu [rbp+240h+var_120], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = (unsigned __int8)v26 & 0x1F;
    v4 = *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = -1;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                     + 8) << v4;
    sub_140024E30(&v26, -*(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    _RAX = v26;
    __asm
    {
      vmovdqu ymm0, ymmword ptr [rax]
      vmovdqu [rbp+240h+var_100], ymm0
      vmovdqu ymm0, [rbp+240h+var_100]
      vmovdqu [rbp+240h+var_140], ymm0
      vmovdqu ymm0, [rbp+240h+var_120]
      vmovdqu [rbp+240h+var_E0], ymm0
      vmovdqu ymm0, [rbp+240h+var_140]
      vmovdqu [rbp+240h+var_C0], ymm0
    }
    sub_140024EE0((__int64)_RBP[24].m128i_i64);
    __asm
    {
      vmovdqu [rbp+240h+var_A0], ymm0
      vmovdqu ymm0, [rbp+240h+var_A0]
      vpmovmskb eax, ymm0
    }
    _RBP->m128i_i32[0] = _EAX;
    _RBP->m128i_i32[0] = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) & *(_DWORD *)((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64);
    if ( _RBP->m128i_i32[0] )
    {
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      return v26;
    }
    else
    {
      while ( 1 )
      {
        _RAX = v26;
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rax]
          vmovdqu [rbp+240h+var_80], ymm0
          vmovdqu ymm0, [rbp+240h+var_80]
          vmovdqu [rbp+240h+var_140], ymm0
          vmovdqu ymm0, [rbp+240h+var_120]
          vmovdqu [rbp+240h+var_60], ymm0
          vmovdqu ymm0, [rbp+240h+var_140]
          vmovdqu [rbp+240h+var_40], ymm0
        }
        sub_140024EE0((__int64)_RBP[32].m128i_i64);
        __asm
        {
          vmovdqu [rbp+240h+var_20], ymm0
          vmovdqu ymm0, [rbp+240h+var_20]
          vpmovmskb eax, ymm0
        }
        _RBP->m128i_i32[0] = _EAX;
        if ( _RBP->m128i_i32[0] )
          break;
        sub_140024E30(&v26, 32i64);
      }
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _EAX;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      return v26;
    }
  }
  else if ( sub_140026130() )
  {
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x68) = 15i64;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x3C) = 0xFFFF;
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025EF0(v27);
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = (unsigned __int8)v26 & 0xF;
    v22 = *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = 0xFFFF;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1C) = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                      + 0x18) << v22;
    sub_140024E30(&v26, -*(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30));
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_loadu_si128(v26);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 7);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xA0) = sub_140025210(_RBP + 9, _RBP + 8);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 10));
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) &= *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 0x1C);
    if ( *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
    {
      _BitScanForward(&v23, *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v23;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20));
      return v26;
    }
    else
    {
      while ( 1 )
      {
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xB0) = _mm_loadu_si128(v26);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 11);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC0) = _mm_load_si128(_RBP + 5);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xD0) = _mm_load_si128(_RBP + 4);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xE0) = sub_140025210(_RBP + 13, _RBP + 12);
        *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 14));
        if ( *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
          break;
        sub_140024E30(&v26, 16i64);
      }
      _BitScanForward(&v24, *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24) = v24;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24));
      return v26;
    }
  }
  else
  {
    return (__m128i *)sub_140018130((unsigned __int16 *)v26, v27);
  }
}

//----- (0000000140023EF0) ----------------------------------------------------
__m128i *__fastcall sub_140023EF0(__m128i *a1, unsigned int a2)
{
  __int64 v4; // rax
  __int64 v22; // rax
  unsigned int v23; // eax
  unsigned int v24; // eax
  int v25; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v26; // [rsp+290h] [rbp+250h] BYREF
  unsigned int v27; // [rsp+298h] [rbp+258h]

  v27 = a2;
  v26 = a1;
  _RBP = (__m128i *)((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( sub_140026190() )
  {
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = 31i64;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = -1;
    sub_140025E20(v27);
    __asm { vmovdqu [rbp+240h+var_120], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = (unsigned __int8)v26 & 0x1F;
    v4 = *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = -1;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                     + 8) << v4;
    sub_140024E30(&v26, -*(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    _RAX = v26;
    __asm
    {
      vmovdqu ymm0, ymmword ptr [rax]
      vmovdqu [rbp+240h+var_100], ymm0
      vmovdqu ymm0, [rbp+240h+var_100]
      vmovdqu [rbp+240h+var_140], ymm0
      vmovdqu ymm0, [rbp+240h+var_120]
      vmovdqu [rbp+240h+var_E0], ymm0
      vmovdqu ymm0, [rbp+240h+var_140]
      vmovdqu [rbp+240h+var_C0], ymm0
    }
    sub_140024F30((__int64)_RBP[24].m128i_i64);
    __asm
    {
      vmovdqu [rbp+240h+var_A0], ymm0
      vmovdqu ymm0, [rbp+240h+var_A0]
      vpmovmskb eax, ymm0
    }
    _RBP->m128i_i32[0] = _EAX;
    _RBP->m128i_i32[0] = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) & *(_DWORD *)((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64);
    if ( _RBP->m128i_i32[0] )
    {
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      return v26;
    }
    else
    {
      while ( 1 )
      {
        _RAX = v26;
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rax]
          vmovdqu [rbp+240h+var_80], ymm0
          vmovdqu ymm0, [rbp+240h+var_80]
          vmovdqu [rbp+240h+var_140], ymm0
          vmovdqu ymm0, [rbp+240h+var_120]
          vmovdqu [rbp+240h+var_60], ymm0
          vmovdqu ymm0, [rbp+240h+var_140]
          vmovdqu [rbp+240h+var_40], ymm0
        }
        sub_140024F30((__int64)_RBP[32].m128i_i64);
        __asm
        {
          vmovdqu [rbp+240h+var_20], ymm0
          vmovdqu ymm0, [rbp+240h+var_20]
          vpmovmskb eax, ymm0
        }
        _RBP->m128i_i32[0] = _EAX;
        if ( _RBP->m128i_i32[0] )
          break;
        sub_140024E30(&v26, 32i64);
      }
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _EAX;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      return v26;
    }
  }
  else if ( sub_140026150() )
  {
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x68) = 15i64;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x3C) = 0xFFFF;
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025F30(v27);
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = (unsigned __int8)v26 & 0xF;
    v22 = *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = 0xFFFF;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1C) = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                      + 0x18) << v22;
    sub_140024E30(&v26, -*(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30));
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_loadu_si128(v26);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 7);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xA0) = sub_140025250(_RBP + 9, _RBP + 8);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 10));
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) &= *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 0x1C);
    if ( *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
    {
      _BitScanForward(&v23, *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v23;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20));
      return v26;
    }
    else
    {
      while ( 1 )
      {
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xB0) = _mm_loadu_si128(v26);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 11);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC0) = _mm_load_si128(_RBP + 5);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xD0) = _mm_load_si128(_RBP + 4);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xE0) = sub_140025250(_RBP + 13, _RBP + 12);
        *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 14));
        if ( *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
          break;
        sub_140024E30(&v26, 16i64);
      }
      _BitScanForward(&v24, *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24) = v24;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24));
      return v26;
    }
  }
  else
  {
    return (__m128i *)sub_140018180(v26, v27);
  }
}

//----- (0000000140024390) ----------------------------------------------------
__m128i *__fastcall sub_140024390(__m128i *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v22; // rax
  unsigned int v23; // eax
  unsigned int v24; // eax
  int v25; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v26; // [rsp+290h] [rbp+250h] BYREF
  __int64 v27; // [rsp+298h] [rbp+258h]

  v27 = a2;
  v26 = a1;
  _RBP = (__m128i *)((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( sub_140026190() )
  {
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = 31i64;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = -1;
    sub_140025E70(v27);
    __asm { vmovdqu [rbp+240h+var_120], ymm0 }
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = (unsigned __int8)v26 & 0x1F;
    v4 = *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = -1;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                     + 8) << v4;
    sub_140024E30(&v26, -*(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28));
    _RAX = v26;
    __asm
    {
      vmovdqu ymm0, ymmword ptr [rax]
      vmovdqu [rbp+240h+var_100], ymm0
      vmovdqu ymm0, [rbp+240h+var_100]
      vmovdqu [rbp+240h+var_140], ymm0
      vmovdqu ymm0, [rbp+240h+var_120]
      vmovdqu [rbp+240h+var_E0], ymm0
      vmovdqu ymm0, [rbp+240h+var_140]
      vmovdqu [rbp+240h+var_C0], ymm0
    }
    sub_140024F80((__int64)_RBP[24].m128i_i64);
    __asm
    {
      vmovdqu [rbp+240h+var_A0], ymm0
      vmovdqu ymm0, [rbp+240h+var_A0]
      vpmovmskb eax, ymm0
    }
    _RBP->m128i_i32[0] = _EAX;
    _RBP->m128i_i32[0] = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC) & *(_DWORD *)((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64);
    if ( _RBP->m128i_i32[0] )
    {
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _EAX;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10));
      return v26;
    }
    else
    {
      while ( 1 )
      {
        _RAX = v26;
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rax]
          vmovdqu [rbp+240h+var_80], ymm0
          vmovdqu ymm0, [rbp+240h+var_80]
          vmovdqu [rbp+240h+var_140], ymm0
          vmovdqu ymm0, [rbp+240h+var_120]
          vmovdqu [rbp+240h+var_60], ymm0
          vmovdqu ymm0, [rbp+240h+var_140]
          vmovdqu [rbp+240h+var_40], ymm0
        }
        sub_140024F80((__int64)_RBP[32].m128i_i64);
        __asm
        {
          vmovdqu [rbp+240h+var_20], ymm0
          vmovdqu ymm0, [rbp+240h+var_20]
          vpmovmskb eax, ymm0
        }
        _RBP->m128i_i32[0] = _EAX;
        if ( _RBP->m128i_i32[0] )
          break;
        sub_140024E30(&v26, 32i64);
      }
      __asm { tzcnt   eax, [rbp+240h+var_240] }
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14) = _EAX;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x14));
      return v26;
    }
  }
  else if ( sub_140026170() )
  {
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x68) = 15i64;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x3C) = 0xFFFF;
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = sub_140025F60(v27);
    *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = (unsigned __int8)v26 & 0xF;
    v22 = *(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = 0xFFFF;
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x1C) = *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                      + 0x18) << v22;
    sub_140024E30(&v26, -*(_QWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30));
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_loadu_si128(v26);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 7);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 5);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 4);
    *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xA0) = sub_140025290(_RBP + 9, _RBP + 8);
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 10));
    *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) &= *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                    + 0x1C);
    if ( *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
    {
      _BitScanForward(&v23, *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v23;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20));
      return v26;
    }
    else
    {
      while ( 1 )
      {
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xB0) = _mm_loadu_si128(v26);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 11);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xC0) = _mm_load_si128(_RBP + 5);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xD0) = _mm_load_si128(_RBP + 4);
        *(__m128i *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0xE0) = sub_140025290(_RBP + 13, _RBP + 12);
        *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) = _mm_movemask_epi8(_mm_load_si128(_RBP + 14));
        if ( *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4) )
          break;
        sub_140024E30(&v26, 16i64);
      }
      _BitScanForward(&v24, *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 4));
      *(_DWORD *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24) = v24;
      sub_140024E30(&v26, *(unsigned int *)(((unsigned __int64)&v25 & 0xFFFFFFFFFFFFFFE0ui64) + 0x24));
      return v26;
    }
  }
  else
  {
    return (__m128i *)sub_1400181D0(v26, v27);
  }
}

//----- (0000000140024840) ----------------------------------------------------
__m128i *__fastcall sub_140024840(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_max_epi8(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024840: using guessed type __m128i var_18;

//----- (00000001400248A0) ----------------------------------------------------
__m128i *__fastcall sub_1400248A0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_max_epi16(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 1400248A0: using guessed type __m128i var_18;

//----- (0000000140024900) ----------------------------------------------------
__m128i *__fastcall sub_140024900(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_max_epi32(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024900: using guessed type __m128i var_18;

//----- (0000000140024960) ----------------------------------------------------
_BOOL8 __fastcall sub_140024960(__int64 a1, __int64 a2, __int64 a3)
{
  return a2 > a3;
}

//----- (00000001400249B0) ----------------------------------------------------
__m128i *__fastcall sub_1400249B0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_max_epu8(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 1400249B0: using guessed type __m128i var_18;

//----- (0000000140024A10) ----------------------------------------------------
__m128i *__fastcall sub_140024A10(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_max_epu16(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024A10: using guessed type __m128i var_18;

//----- (0000000140024A70) ----------------------------------------------------
__m128i *__fastcall sub_140024A70(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_max_epu32(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024A70: using guessed type __m128i var_18;

//----- (0000000140024AD0) ----------------------------------------------------
_BOOL8 __fastcall sub_140024AD0(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  return a2 > a3;
}

//----- (0000000140024B20) ----------------------------------------------------
__m128i *__fastcall sub_140024B20(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_min_epi8(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024B20: using guessed type __m128i var_18;

//----- (0000000140024B80) ----------------------------------------------------
__m128i *__fastcall sub_140024B80(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_min_epi16(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024B80: using guessed type __m128i var_18;

//----- (0000000140024BE0) ----------------------------------------------------
__m128i *__fastcall sub_140024BE0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_min_epi32(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024BE0: using guessed type __m128i var_18;

//----- (0000000140024C40) ----------------------------------------------------
_BOOL8 __fastcall sub_140024C40(__int64 a1, __int64 a2, __int64 a3)
{
  return a2 < a3;
}

//----- (0000000140024C90) ----------------------------------------------------
__m128i *__fastcall sub_140024C90(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_min_epu8(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024C90: using guessed type __m128i var_18;

//----- (0000000140024CF0) ----------------------------------------------------
__m128i *__fastcall sub_140024CF0(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_min_epu16(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024CF0: using guessed type __m128i var_18;

//----- (0000000140024D50) ----------------------------------------------------
__m128i *__fastcall sub_140024D50(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  __m128i v5; // [rsp+0h] [rbp-18h] BYREF

  v5 = _mm_min_epu32(_mm_loadu_si128(a3), *a4);
  *a2 = _mm_load_si128(&v5);
  return a2;
}
// 140024D50: using guessed type __m128i var_18;

//----- (0000000140024DB0) ----------------------------------------------------
_BOOL8 __fastcall sub_140024DB0(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  return a2 < a3;
}

//----- (0000000140024E00) ----------------------------------------------------
__int64 __fastcall sub_140024E00(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = a2 + *a1;
  *a1 = result;
  return result;
}

//----- (0000000140024E30) ----------------------------------------------------
__int64 __fastcall sub_140024E30(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = a2 + *a1;
  *a1 = result;
  return result;
}

//----- (0000000140024E60) ----------------------------------------------------
__int64 __fastcall sub_140024E60(__int64 a1, __int64 a2)
{
  return a2 - a1;
}

//----- (0000000140024E90) ----------------------------------------------------
__int64 __fastcall sub_140024E90(__int64 a1)
{
  __int64 result; // rax
  __m256 v6; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v6 & 0xFFFFFFFFFFFFFFE0ui64;
  result = a1;
  __asm
  {
    vmovdqu ymm0, ymmword ptr [rax]
    vpcmpeqb ymm0, ymm0, ymmword ptr [rcx]
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}

//----- (0000000140024EE0) ----------------------------------------------------
__int64 __fastcall sub_140024EE0(__int64 a1)
{
  __int64 result; // rax
  __m256 v6; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v6 & 0xFFFFFFFFFFFFFFE0ui64;
  result = a1;
  __asm
  {
    vmovdqu ymm0, ymmword ptr [rax]
    vpcmpeqw ymm0, ymm0, ymmword ptr [rcx]
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}

//----- (0000000140024F30) ----------------------------------------------------
__int64 __fastcall sub_140024F30(__int64 a1)
{
  __int64 result; // rax
  __m256 v6; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v6 & 0xFFFFFFFFFFFFFFE0ui64;
  result = a1;
  __asm
  {
    vmovdqu ymm0, ymmword ptr [rax]
    vpcmpeqd ymm0, ymm0, ymmword ptr [rcx]
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}

//----- (0000000140024F80) ----------------------------------------------------
__int64 __fastcall sub_140024F80(__int64 a1)
{
  __int64 result; // rax
  __m256 v6; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v6 & 0xFFFFFFFFFFFFFFE0ui64;
  result = a1;
  __asm
  {
    vmovdqu ymm0, ymmword ptr [rax]
    vpcmpeqq ymm0, ymm0, ymmword ptr [rcx]
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}

//----- (0000000140024FD0) ----------------------------------------------------
__m128i __fastcall sub_140024FD0(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi8(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140024FD0: using guessed type __m128i var_18;

//----- (0000000140025010) ----------------------------------------------------
__m128i __fastcall sub_140025010(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi16(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025010: using guessed type __m128i var_18;

//----- (0000000140025050) ----------------------------------------------------
__m128i __fastcall sub_140025050(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi32(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025050: using guessed type __m128i var_18;

//----- (0000000140025090) ----------------------------------------------------
__m128i __fastcall sub_140025090(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi64(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025090: using guessed type __m128i var_18;

//----- (00000001400250D0) ----------------------------------------------------
__m128i __fastcall sub_1400250D0(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpgt_epi8(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 1400250D0: using guessed type __m128i var_18;

//----- (0000000140025110) ----------------------------------------------------
__m128i __fastcall sub_140025110(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpgt_epi16(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025110: using guessed type __m128i var_18;

//----- (0000000140025150) ----------------------------------------------------
__m128i __fastcall sub_140025150(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpgt_epi32(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025150: using guessed type __m128i var_18;

//----- (0000000140025190) ----------------------------------------------------
__m128i __fastcall sub_140025190(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpgt_epi64(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025190: using guessed type __m128i var_18;

//----- (00000001400251D0) ----------------------------------------------------
__m128i __fastcall sub_1400251D0(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi8(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 1400251D0: using guessed type __m128i var_18;

//----- (0000000140025210) ----------------------------------------------------
__m128i __fastcall sub_140025210(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi16(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025210: using guessed type __m128i var_18;

//----- (0000000140025250) ----------------------------------------------------
__m128i __fastcall sub_140025250(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi32(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025250: using guessed type __m128i var_18;

//----- (0000000140025290) ----------------------------------------------------
__m128i __fastcall sub_140025290(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_cmpeq_epi64(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025290: using guessed type __m128i var_18;

//----- (00000001400252D0) ----------------------------------------------------
__int64 __fastcall sub_1400252D0(const __m128i *a1)
{
  return (unsigned int)_mm_cvtsi128_si32(_mm_loadu_si128(a1));
}

//----- (00000001400252F0) ----------------------------------------------------
__int64 __fastcall sub_1400252F0(const __m128i *a1)
{
  return (unsigned int)_mm_cvtsi128_si32(_mm_loadu_si128(a1));
}

//----- (0000000140025310) ----------------------------------------------------
__int64 __fastcall sub_140025310(const __m128i *a1)
{
  return (unsigned int)_mm_cvtsi128_si32(_mm_loadu_si128(a1));
}

//----- (0000000140025330) ----------------------------------------------------
unsigned __int64 __fastcall sub_140025330(const __m128i *a1)
{
  return _mm_loadu_si128(a1).m128i_u64[0];
}

//----- (0000000140025350) ----------------------------------------------------
__int64 __fastcall sub_140025350(const __m128i *a1, unsigned int a2)
{
  __m128i v3; // [rsp+10h] [rbp-18h] BYREF

  v3 = _mm_shuffle_epi8(_mm_loadu_si128(a1), _mm_cvtsi32_si128(a2));
  return (unsigned int)_mm_cvtsi128_si32(_mm_load_si128(&v3));
}
// 140025350: using guessed type __m128i var_18;

//----- (00000001400253A0) ----------------------------------------------------
__int64 __fastcall sub_1400253A0(const __m128i *a1, unsigned int a2)
{
  __m128i v3; // [rsp+10h] [rbp-18h] BYREF

  v3 = _mm_shuffle_epi8(_mm_loadu_si128(a1), _mm_cvtsi32_si128(word_140032DD8[a2 >> 1]));
  return (unsigned int)_mm_cvtsi128_si32(_mm_load_si128(&v3));
}
// 140032DD8: using guessed type unsigned __int16 word_140032DD8[12];
// 1400253A0: using guessed type __m128i var_18;

//----- (0000000140025400) ----------------------------------------------------
__int64 __fastcall sub_140025400(const __m128i *a1, unsigned int a2)
{
  __m128i v3; // [rsp+0h] [rbp-28h]

  v3 = _mm_loadu_si128(a1);
  return v3.m128i_u32[a2 >> 2];
}

//----- (0000000140025460) ----------------------------------------------------
__int64 __fastcall sub_140025460(const __m128i *a1, unsigned int a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h]

  v3 = _mm_loadu_si128(a1);
  return v3.m128i_i64[a2 >> 3];
}
// 140025460: using guessed type __m128i var_18;

//----- (00000001400254A0) ----------------------------------------------------
__m128i __fastcall sub_1400254A0(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018220(&v3, v2);
  return _mm_load_si128(&v4);
}
// 1400254C2: variable 'v2' is possibly undefined
// 1400254A0: using guessed type __m128i var_18;

//----- (00000001400254F0) ----------------------------------------------------
__m128i __fastcall sub_1400254F0(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018490(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025512: variable 'v2' is possibly undefined
// 1400254F0: using guessed type __m128i var_18;

//----- (0000000140025540) ----------------------------------------------------
__m128i __fastcall sub_140025540(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018650(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025562: variable 'v2' is possibly undefined
// 140025540: using guessed type __m128i var_18;

//----- (0000000140025590) ----------------------------------------------------
__m128i __fastcall sub_140025590(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018760(&v3, v2);
  return _mm_load_si128(&v4);
}
// 1400255B2: variable 'v2' is possibly undefined
// 140025590: using guessed type __m128i var_18;

//----- (00000001400255E0) ----------------------------------------------------
__m128i __fastcall sub_1400255E0(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018830(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025602: variable 'v2' is possibly undefined
// 1400255E0: using guessed type __m128i var_18;

//----- (0000000140025630) ----------------------------------------------------
__m128i __fastcall sub_140025630(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018AA0(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025652: variable 'v2' is possibly undefined
// 140025630: using guessed type __m128i var_18;

//----- (0000000140025680) ----------------------------------------------------
__m128i __fastcall sub_140025680(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018C60(&v3, v2);
  return _mm_load_si128(&v4);
}
// 1400256A2: variable 'v2' is possibly undefined
// 140025680: using guessed type __m128i var_18;

//----- (00000001400256D0) ----------------------------------------------------
__m128i __fastcall sub_1400256D0(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018D70(&v3, v2);
  return _mm_load_si128(&v4);
}
// 1400256F2: variable 'v2' is possibly undefined
// 1400256D0: using guessed type __m128i var_18;

//----- (0000000140025720) ----------------------------------------------------
__m128i __fastcall sub_140025720(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140018E40(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025742: variable 'v2' is possibly undefined
// 140025720: using guessed type __m128i var_18;

//----- (0000000140025770) ----------------------------------------------------
__m128i __fastcall sub_140025770(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_1400190B0(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025792: variable 'v2' is possibly undefined
// 140025770: using guessed type __m128i var_18;

//----- (00000001400257C0) ----------------------------------------------------
__m128i __fastcall sub_1400257C0(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140019270(&v3, v2);
  return _mm_load_si128(&v4);
}
// 1400257E2: variable 'v2' is possibly undefined
// 1400257C0: using guessed type __m128i var_18;

//----- (0000000140025810) ----------------------------------------------------
__m128i __fastcall sub_140025810(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140019380(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025832: variable 'v2' is possibly undefined
// 140025810: using guessed type __m128i var_18;

//----- (0000000140025860) ----------------------------------------------------
__m128i __fastcall sub_140025860(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140019450(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025882: variable 'v2' is possibly undefined
// 140025860: using guessed type __m128i var_18;

//----- (00000001400258B0) ----------------------------------------------------
__m128i __fastcall sub_1400258B0(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_1400196C0(&v3, v2);
  return _mm_load_si128(&v4);
}
// 1400258D2: variable 'v2' is possibly undefined
// 1400258B0: using guessed type __m128i var_18;

//----- (0000000140025900) ----------------------------------------------------
__m128i __fastcall sub_140025900(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140019880(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025922: variable 'v2' is possibly undefined
// 140025900: using guessed type __m128i var_18;

//----- (0000000140025950) ----------------------------------------------------
__m128i __fastcall sub_140025950(const __m128i *a1)
{
  char v2; // [rsp+20h] [rbp-38h]
  __m128i v3; // [rsp+30h] [rbp-28h] BYREF
  __m128i v4; // [rsp+40h] [rbp-18h] BYREF

  v3 = _mm_loadu_si128(a1);
  v4 = sub_140019990(&v3, v2);
  return _mm_load_si128(&v4);
}
// 140025972: variable 'v2' is possibly undefined
// 140025950: using guessed type __m128i var_18;

//----- (00000001400259A0) ----------------------------------------------------
__m128i __fastcall sub_1400259A0(const __m128i *a1)
{
  __m128i v2; // [rsp+10h] [rbp-18h] BYREF

  v2 = _mm_add_epi8(_mm_loadu_si128(a1), _mm_load_si128(xmmword_140032EF0));
  return _mm_load_si128(&v2);
}
// 140032EF0: using guessed type __m128i xmmword_140032EF0[2];
// 1400259A0: using guessed type __m128i var_18;

//----- (00000001400259F0) ----------------------------------------------------
__m128i __fastcall sub_1400259F0(const __m128i *a1)
{
  __m128i v2; // [rsp+10h] [rbp-18h] BYREF

  v2 = _mm_add_epi16(_mm_loadu_si128(a1), _mm_load_si128(xmmword_140032E90));
  return _mm_load_si128(&v2);
}
// 140032E90: using guessed type __m128i xmmword_140032E90[2];
// 1400259F0: using guessed type __m128i var_18;

//----- (0000000140025A40) ----------------------------------------------------
__m128i __fastcall sub_140025A40(const __m128i *a1)
{
  __m128i v2; // [rsp+10h] [rbp-18h] BYREF

  v2 = _mm_add_epi32(_mm_loadu_si128(a1), _mm_load_si128(xmmword_140032E70));
  return _mm_load_si128(&v2);
}
// 140032E70: using guessed type __m128i xmmword_140032E70[2];
// 140025A40: using guessed type __m128i var_18;

//----- (0000000140025A90) ----------------------------------------------------
__m128i __fastcall sub_140025A90(const __m128i *a1)
{
  __m128i v2; // [rsp+10h] [rbp-18h] BYREF

  v2 = _mm_add_epi64(_mm_loadu_si128(a1), _mm_load_si128(xmmword_140032E50));
  return _mm_load_si128(&v2);
}
// 140032E50: using guessed type __m128i xmmword_140032E50[2];
// 140025A90: using guessed type __m128i var_18;

//----- (0000000140025AE0) ----------------------------------------------------
__m128i __fastcall sub_140025AE0(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_max_epi8(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025AE0: using guessed type __m128i var_18;

//----- (0000000140025B30) ----------------------------------------------------
__m128i __fastcall sub_140025B30(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_max_epi16(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025B30: using guessed type __m128i var_18;

//----- (0000000140025B80) ----------------------------------------------------
__m128i __fastcall sub_140025B80(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_max_epi32(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025B80: using guessed type __m128i var_18;

//----- (0000000140025BD0) ----------------------------------------------------
__m128i __fastcall sub_140025BD0(const __m128i *a1, __m128i *a2, const __m128i *a3)
{
  __m128i v4; // [rsp+0h] [rbp-18h] BYREF

  v4 = _mm_blendv_epi8(_mm_loadu_si128(a1), *a2, _mm_loadu_si128(a3));
  return _mm_load_si128(&v4);
}
// 140025BD0: using guessed type __m128i var_18;

//----- (0000000140025C30) ----------------------------------------------------
__m128i __fastcall sub_140025C30(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_min_epi8(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025C30: using guessed type __m128i var_18;

//----- (0000000140025C80) ----------------------------------------------------
__m128i __fastcall sub_140025C80(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_min_epi16(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025C80: using guessed type __m128i var_18;

//----- (0000000140025CD0) ----------------------------------------------------
__m128i __fastcall sub_140025CD0(const __m128i *a1, __m128i *a2)
{
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v3 = _mm_min_epi32(_mm_loadu_si128(a1), *a2);
  return _mm_load_si128(&v3);
}
// 140025CD0: using guessed type __m128i var_18;

//----- (0000000140025D20) ----------------------------------------------------
__m128i __fastcall sub_140025D20(const __m128i *a1, __m128i *a2, const __m128i *a3)
{
  __m128i v4; // [rsp+0h] [rbp-18h] BYREF

  v4 = _mm_blendv_epi8(_mm_loadu_si128(a1), *a2, _mm_loadu_si128(a3));
  return _mm_load_si128(&v4);
}
// 140025D20: using guessed type __m128i var_18;

//----- (0000000140025D80) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_140025D80(char a1, double _XMM1_8)
{
  __int64 result; // rax
  __m256 v10; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v10 & 0xFFFFFFFFFFFFFFE0ui64;
  result = (unsigned int)a1;
  __asm
  {
    vmovd   xmm0, eax
    vpxor   xmm1, xmm1, xmm1
    vpshufb xmm0, xmm0, xmm1
    vinsertf128 ymm0, ymm0, xmm0, 1
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}
// 140025D80: inconsistent variable size for 'xmm1_8.8'

//----- (0000000140025DD0) ----------------------------------------------------
__int64 __fastcall sub_140025DD0(__int16 a1)
{
  __int64 result; // rax
  __m256 v9; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v9 & 0xFFFFFFFFFFFFFFE0ui64;
  result = (unsigned int)a1;
  __asm
  {
    vmovd   xmm0, eax
    vpunpcklwd xmm0, xmm0, xmm0
    vpshufd xmm0, xmm0, 0
    vinsertf128 ymm0, ymm0, xmm0, 1
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}

//----- (0000000140025E20) ----------------------------------------------------
__int64 __fastcall sub_140025E20(unsigned int a1)
{
  __int64 result; // rax
  __m256 v8; // [rsp+20h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v8 & 0xFFFFFFFFFFFFFFE0ui64;
  result = a1;
  __asm
  {
    vmovd   xmm0, eax
    vpshufd xmm0, xmm0, 0
    vinsertf128 ymm0, ymm0, xmm0, 1
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
  return result;
}

//----- (0000000140025E70) ----------------------------------------------------
void __fastcall sub_140025E70(__int64 a1)
{
  __m256 v7; // [rsp+20h] [rbp+0h] BYREF
  __int64 v8; // [rsp+50h] [rbp+30h]

  v8 = a1;
  _RBP = (unsigned __int64)&v7 & 0xFFFFFFFFFFFFFFE0ui64;
  __asm
  {
    vmovq   xmm0, [rsp+40h+arg_0]
    vpunpcklqdq xmm0, xmm0, xmm0
    vinsertf128 ymm0, ymm0, xmm0, 1
    vmovdqu [rbp+20h+var_20], ymm0
    vmovdqu ymm0, [rbp+20h+var_20]
  }
}

//----- (0000000140025EB0) ----------------------------------------------------
__m128i __fastcall sub_140025EB0(char a1)
{
  __m128i v1; // xmm0
  __m128i v2; // xmm0
  __m128i v4; // [rsp+0h] [rbp-18h] BYREF

  v1 = _mm_cvtsi32_si128(a1);
  v2 = _mm_unpacklo_epi8(v1, v1);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v2, v2), 0);
  return _mm_load_si128(&v4);
}
// 140025EB0: using guessed type __m128i var_18;

//----- (0000000140025EF0) ----------------------------------------------------
__m128i __fastcall sub_140025EF0(__int16 a1)
{
  __m128i v1; // xmm0
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF

  v1 = _mm_cvtsi32_si128(a1);
  v3 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v1, v1), 0);
  return _mm_load_si128(&v3);
}
// 140025EF0: using guessed type __m128i var_18;

//----- (0000000140025F30) ----------------------------------------------------
__m128i __fastcall sub_140025F30(unsigned int a1)
{
  __m128i v2; // [rsp+0h] [rbp-18h] BYREF

  v2 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a1), 0);
  return _mm_load_si128(&v2);
}
// 140025F30: using guessed type __m128i var_18;

//----- (0000000140025F60) ----------------------------------------------------
__m128i __fastcall sub_140025F60(__int64 a1)
{
  __m128i v1; // xmm0
  __m128i v3; // [rsp+0h] [rbp-18h] BYREF
  __m128i v4; // [rsp+20h] [rbp+8h] BYREF

  v4.m128i_i64[0] = a1;
  v1 = _mm_loadl_epi64(&v4);
  v3 = _mm_unpacklo_epi64(v1, v1);
  return _mm_load_si128(&v3);
}
// 140025F60: using guessed type __m128i var_18;

//----- (0000000140025F90) ----------------------------------------------------
__m128i __fastcall sub_140025F90(const __m128i *a1, unsigned __int8 a2)
{
  __m128i v3; // [rsp+10h] [rbp-18h] BYREF

  v3 = _mm_sub_epi8(_mm_loadu_si128(a1), _mm_loadu_si128(&stru_140032D80[a2]));
  return _mm_load_si128(&v3);
}
// 140032D80: using guessed type __m128i stru_140032D80[3];
// 140025F90: using guessed type __m128i var_18;

//----- (0000000140025FF0) ----------------------------------------------------
__m128i __fastcall sub_140025FF0(const __m128i *a1, unsigned __int8 a2)
{
  __m128i v3; // [rsp+10h] [rbp-18h] BYREF

  v3 = _mm_sub_epi16(_mm_loadu_si128(a1), _mm_loadu_si128(&stru_140032DB0[a2]));
  return _mm_load_si128(&v3);
}
// 140032DB0: using guessed type __m128i stru_140032DB0[2];
// 140025FF0: using guessed type __m128i var_18;

//----- (0000000140026050) ----------------------------------------------------
__m128i __fastcall sub_140026050(const __m128i *a1, unsigned __int8 a2)
{
  __m128i v3; // [rsp+10h] [rbp-18h] BYREF

  v3 = _mm_sub_epi32(_mm_loadu_si128(a1), _mm_loadu_si128(&stru_140032DF0[a2]));
  return _mm_load_si128(&v3);
}
// 140032DF0: using guessed type __m128i stru_140032DF0[3];
// 140026050: using guessed type __m128i var_18;

//----- (00000001400260B0) ----------------------------------------------------
__m128i __fastcall sub_1400260B0(const __m128i *a1, unsigned __int8 a2)
{
  __m128i v3; // [rsp+10h] [rbp-18h] BYREF

  v3 = _mm_sub_epi64(_mm_loadu_si128(a1), _mm_loadu_si128(&stru_140032E20[a2]));
  return _mm_load_si128(&v3);
}
// 140032E20: using guessed type __m128i stru_140032E20[3];
// 1400260B0: using guessed type __m128i var_18;

//----- (0000000140026110) ----------------------------------------------------
char sub_140026110()
{
  return sub_1400261C0();
}

//----- (0000000140026130) ----------------------------------------------------
char sub_140026130()
{
  return sub_1400261C0();
}

//----- (0000000140026150) ----------------------------------------------------
char sub_140026150()
{
  return sub_1400261C0();
}

//----- (0000000140026170) ----------------------------------------------------
_BOOL8 sub_140026170()
{
  return sub_1400261D0();
}

//----- (0000000140026190) ----------------------------------------------------
_BOOL8 sub_140026190()
{
  return (dword_14003702C & 0x20) != 0;
}
// 14003702C: using guessed type int dword_14003702C;

//----- (00000001400261C0) ----------------------------------------------------
char sub_1400261C0()
{
  return 1;
}

//----- (00000001400261D0) ----------------------------------------------------
_BOOL8 sub_1400261D0()
{
  return (dword_14003702C & 4) != 0;
}
// 14003702C: using guessed type int dword_14003702C;

//----- (0000000140026200) ----------------------------------------------------
__int64 __fastcall sub_140026200(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  return sub_140021D20(a1, a2, a3);
}

//----- (0000000140026240) ----------------------------------------------------
__int64 __fastcall sub_140026240(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3)
{
  return sub_140022010(a1, a2, a3);
}

//----- (0000000140026280) ----------------------------------------------------
__int64 __fastcall sub_140026280(__m128i *a1, _DWORD *a2, unsigned int a3)
{
  return sub_140022310(a1, a2, a3);
}

//----- (00000001400262C0) ----------------------------------------------------
__int64 __fastcall sub_1400262C0(__m128i *a1, _QWORD *a2, __int64 a3)
{
  return sub_140022610(a1, a2, a3);
}

//----- (0000000140026300) ----------------------------------------------------
__m128i *__fastcall sub_140026300(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  return sub_140022910(a1, a2, a3);
}

//----- (0000000140026340) ----------------------------------------------------
__m128i *__fastcall sub_140026340(unsigned __int16 *a1, unsigned __int16 *a2, __int16 a3)
{
  return sub_140022C30(a1, a2, a3);
}

//----- (0000000140026380) ----------------------------------------------------
__m128i *__fastcall sub_140026380(__m128i *a1, _DWORD *a2, unsigned int a3)
{
  return sub_140022F50(a1, a2, a3);
}

//----- (00000001400263C0) ----------------------------------------------------
__m128i *__fastcall sub_1400263C0(__m128i *a1, _QWORD *a2, __int64 a3)
{
  return sub_140023270(a1, a2, a3);
}

//----- (0000000140026400) ----------------------------------------------------
__m128i *__fastcall sub_140026400(unsigned __int8 *a1, unsigned __int8 a2)
{
  return sub_140023590(a1, a2);
}

//----- (0000000140026430) ----------------------------------------------------
__m128i *__fastcall sub_140026430(unsigned __int16 *a1, __int16 a2)
{
  return sub_140023A40(a1, a2);
}

//----- (0000000140026460) ----------------------------------------------------
__m128i *__fastcall sub_140026460(__m128i *a1, unsigned int a2)
{
  return sub_140023EF0(a1, a2);
}

//----- (0000000140026490) ----------------------------------------------------
__m128i *__fastcall sub_140026490(__m128i *a1, __int64 a2)
{
  return sub_140024390(a1, a2);
}

//----- (00000001400264C0) ----------------------------------------------------
__int64 __fastcall sub_1400264C0(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001C190(a1, a2, a3);
}

//----- (0000000140026500) ----------------------------------------------------
__int64 __fastcall sub_140026500(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001C970(a1, a2, a3);
}

//----- (0000000140026540) ----------------------------------------------------
__int64 __fastcall sub_140026540(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001D170(a1, a2, a3);
}

//----- (0000000140026580) ----------------------------------------------------
__int64 __fastcall sub_140026580(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001D980(a1, a2, a3);
}

//----- (00000001400265C0) ----------------------------------------------------
__int64 __fastcall sub_1400265C0(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001A320(a1, a2, a3);
}

//----- (0000000140026600) ----------------------------------------------------
__int64 __fastcall sub_140026600(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001AAF0(a1, a2, a3);
}

//----- (0000000140026640) ----------------------------------------------------
__int64 __fastcall sub_140026640(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001B2E0(a1, a2, a3);
}

//----- (0000000140026680) ----------------------------------------------------
__int64 __fastcall sub_140026680(const __m128i *a1, __int64 a2, unsigned __int8 a3)
{
  return sub_14001BAE0(a1, a2, a3);
}

//----- (00000001400266C0) ----------------------------------------------------
__int64 __fastcall sub_1400266C0(__int64 a1)
{
  return a1;
}

//----- (0000000140026730) ----------------------------------------------------
__int64 __fastcall sub_140026730(__int64 a1)
{
  return a1;
}

//----- (00000001400267A0) ----------------------------------------------------
__int64 __fastcall sub_1400267A0(__int64 a1)
{
  return a1;
}

//----- (0000000140026810) ----------------------------------------------------
__int64 __fastcall sub_140026810(__int64 a1)
{
  return a1;
}

//----- (0000000140026880) ----------------------------------------------------
__int64 __fastcall sub_140026880(__int64 a1, const __m128i *a2, __m128i *a3)
{
  __int64 v6; // rax
  __int64 v17; // rax
  __int64 v19; // [rsp+40h] [rbp+0h] BYREF
  const __m128i *v21; // [rsp+1D8h] [rbp+198h] BYREF
  __m128i *v22; // [rsp+1E0h] [rbp+1A0h] BYREF

  v22 = a3;
  v21 = a2;
  _RBP = (__m128i *)((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, (__int64)a2) >= 0x20 && sub_140026190() )
  {
    __asm
    {
      vmovdqu ymm0, cs:ymmword_140032FC0
      vmovdqu [rbp+180h+var_100], ymm0
      vmovdqu ymm0, [rbp+180h+var_100]
      vmovdqu [rbp+180h+var_60], ymm0
    }
    _RBP->m128i_i64[0] = (__int64)v22;
    v6 = sub_140024E60(a1, (__int64)v21);
    sub_140024E30((_QWORD *)((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64), v6 & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      sub_140024E30(&v21, -32i64);
      _RAX = v21;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+180h+var_E0], ymm0
        vmovdqu ymm0, [rbp+180h+var_E0]
        vmovdqu [rbp+180h+var_C0], ymm0
        vpermq  ymm0, [rbp+180h+var_C0], 4Eh
        vmovdqu [rbp+180h+var_A0], ymm0
        vmovdqu ymm0, [rbp+180h+var_A0]
        vmovdqu [rbp+180h+var_80], ymm0
        vmovdqu ymm0, [rbp+180h+var_80]
        vpshufb ymm0, ymm0, [rbp+180h+var_60]
        vmovdqu [rbp+180h+var_40], ymm0
        vmovdqu ymm0, [rbp+180h+var_40]
        vmovdqu [rbp+180h+var_20], ymm0
      }
      _RAX = v22;
      __asm
      {
        vmovdqu ymm0, [rbp+180h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v22, 32i64);
    }
    while ( v22 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(a1, (__int64)v21) >= 0x10 && sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_load_si128(xmmword_140032EB0);
    *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 1);
    *(_QWORD *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v22;
    v17 = sub_140024E60(a1, (__int64)v21);
    sub_140024E30(&_RBP->m128i_i64[1], v17 & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E30(&v21, -16i64);
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_loadu_si128(v21);
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_load_si128(_RBP + 2);
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = _mm_shuffle_epi8(
                                                                                 _mm_load_si128(_RBP + 3),
                                                                                 *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                            + 0x40));
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 5);
      *v22 = _mm_load_si128(_RBP + 6);
      sub_140024E00(&v22, 16i64);
    }
    while ( v22 != *(__m128i **)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021960(a1, (__int64)v21, v22);
}
// 140032EB0: using guessed type __m128i xmmword_140032EB0[2];

//----- (0000000140026B90) ----------------------------------------------------
__int64 __fastcall sub_140026B90(__int64 a1, const __m128i *a2, __m128i *a3)
{
  __int64 v6; // rax
  __int64 v17; // rax
  __int64 v19; // [rsp+40h] [rbp+0h] BYREF
  const __m128i *v21; // [rsp+1D8h] [rbp+198h] BYREF
  __m128i *v22; // [rsp+1E0h] [rbp+1A0h] BYREF

  v22 = a3;
  v21 = a2;
  _RBP = (__m128i *)((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x20 && (unsigned __int8)sub_140026190() )
  {
    __asm
    {
      vmovdqu ymm0, cs:ymmword_140033000
      vmovdqu [rbp+180h+var_100], ymm0
      vmovdqu ymm0, [rbp+180h+var_100]
      vmovdqu [rbp+180h+var_60], ymm0
    }
    _RBP->m128i_i64[0] = (__int64)v22;
    v6 = sub_140024E60(a1, v21);
    sub_140024E30((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64, v6 & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      sub_140024E30(&v21, -32i64);
      _RAX = v21;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+180h+var_E0], ymm0
        vmovdqu ymm0, [rbp+180h+var_E0]
        vmovdqu [rbp+180h+var_C0], ymm0
        vpermq  ymm0, [rbp+180h+var_C0], 4Eh
        vmovdqu [rbp+180h+var_A0], ymm0
        vmovdqu ymm0, [rbp+180h+var_A0]
        vmovdqu [rbp+180h+var_80], ymm0
        vmovdqu ymm0, [rbp+180h+var_80]
        vpshufb ymm0, ymm0, [rbp+180h+var_60]
        vmovdqu [rbp+180h+var_40], ymm0
        vmovdqu ymm0, [rbp+180h+var_40]
        vmovdqu [rbp+180h+var_20], ymm0
      }
      _RAX = v22;
      __asm
      {
        vmovdqu ymm0, [rbp+180h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v22, 32i64);
    }
    while ( v22 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(a1, v21) >= 0x10 && (unsigned __int8)sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_load_si128(xmmword_140032ED0);
    *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 1);
    *(_QWORD *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v22;
    v17 = sub_140024E60(a1, v21);
    sub_140024E30(&_RBP->m128i_u64[1], v17 & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E30(&v21, -16i64);
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_loadu_si128(v21);
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_load_si128(_RBP + 2);
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = _mm_shuffle_epi8(
                                                                                 _mm_load_si128(_RBP + 3),
                                                                                 *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                            + 0x40));
      *(__m128i *)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_load_si128(_RBP + 5);
      *v22 = _mm_load_si128(_RBP + 6);
      sub_140024E00(&v22, 16i64);
    }
    while ( v22 != *(__m128i **)(((unsigned __int64)&v19 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_1400219C0(a1, v21, v22);
}
// 1400219C0: using guessed type __int64 __fastcall sub_1400219C0(_QWORD, _QWORD, _QWORD);
// 140024E00: using guessed type __int64 __fastcall sub_140024E00(_QWORD, _QWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140026190: using guessed type __int64 sub_140026190(void);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032ED0: using guessed type __m128i xmmword_140032ED0[2];

//----- (0000000140026EA0) ----------------------------------------------------
__int64 __fastcall sub_140026EA0(__int64 a1, const __m128i *a2, __m128i *a3)
{
  __int64 v4; // rax
  __int64 v15; // rax
  __int64 v17; // [rsp+40h] [rbp+0h] BYREF
  const __m128i *v19; // [rsp+178h] [rbp+138h] BYREF
  __m128i *v20; // [rsp+180h] [rbp+140h] BYREF

  v20 = a3;
  v19 = a2;
  _RBP = (__m128i *)((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x20 && (unsigned __int8)sub_140026190() )
  {
    _RBP->m128i_i64[0] = (__int64)v20;
    v4 = sub_140024E60(a1, v19);
    sub_140024E30((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64, v4 & 0xFFFFFFFFFFFFFFE0ui64);
    __asm
    {
      vmovdqu ymm0, cs:ymmword_140032F80
      vmovdqu [rbp+120h+var_C0], ymm0
      vmovdqu ymm0, [rbp+120h+var_C0]
      vmovdqu [rbp+120h+var_80], ymm0
    }
    do
    {
      sub_140024E30(&v19, -32i64);
      _RAX = v19;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+120h+var_A0], ymm0
        vmovdqu ymm0, [rbp+120h+var_A0]
        vmovdqu [rbp+120h+var_60], ymm0
        vmovdqu ymm0, [rbp+120h+var_80]
        vpermd  ymm0, ymm0, [rbp+120h+var_60]
        vmovdqu [rbp+120h+var_40], ymm0
        vmovdqu ymm0, [rbp+120h+var_40]
        vmovdqu [rbp+120h+var_20], ymm0
      }
      _RAX = v20;
      __asm
      {
        vmovdqu ymm0, [rbp+120h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v20, 32i64);
    }
    while ( v20 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(a1, v19) >= 0x10 && (unsigned __int8)sub_1400261C0() )
  {
    *(_QWORD *)(((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v20;
    v15 = sub_140024E60(a1, v19);
    sub_140024E30(&_RBP->m128i_u64[1], v15 & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E30(&v19, -16i64);
      *(__m128i *)(((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_loadu_si128(v19);
      *(__m128i *)(((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_load_si128(_RBP + 1);
      *(__m128i *)(((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_shuffle_epi32(
                                                                                 _mm_load_si128(_RBP + 2),
                                                                                 27);
      *(__m128i *)(((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 3);
      *v20 = _mm_load_si128(_RBP + 4);
      sub_140024E00(&v20, 16i64);
    }
    while ( v20 != *(__m128i **)(((unsigned __int64)&v17 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021A20(a1, v19, v20);
}
// 140021A20: using guessed type __int64 __fastcall sub_140021A20(_QWORD, _QWORD, _QWORD);
// 140024E00: using guessed type __int64 __fastcall sub_140024E00(_QWORD, _QWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140026190: using guessed type __int64 sub_140026190(void);
// 1400261C0: using guessed type __int64 sub_1400261C0(void);

//----- (0000000140027160) ----------------------------------------------------
_QWORD *__fastcall sub_140027160(_QWORD *a1, __m128i *a2, __m128i *a3)
{
  __int64 v4; // rax
  __int64 v12; // rax
  __int64 v14; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v16; // [rsp+138h] [rbp+F8h] BYREF
  __m128i *v17; // [rsp+140h] [rbp+100h] BYREF

  v17 = a3;
  v16 = a2;
  _RBP = (__m128i *)((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60((__int64)a1, (__int64)a2) >= 0x20 && sub_140026190() )
  {
    _RBP->m128i_i64[0] = (__int64)v17;
    v4 = sub_140024E60((__int64)a1, (__int64)v16);
    sub_140024E30((_QWORD *)((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64), v4 & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      sub_140024E30(&v16, -32i64);
      _RAX = v16;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+0E0h+var_80], ymm0
        vmovdqu ymm0, [rbp+0E0h+var_80]
        vmovdqu [rbp+0E0h+var_60], ymm0
        vpermq  ymm0, [rbp+0E0h+var_60], 1Bh
        vmovdqu [rbp+0E0h+var_40], ymm0
        vmovdqu ymm0, [rbp+0E0h+var_40]
        vmovdqu [rbp+0E0h+var_20], ymm0
      }
      _RAX = v17;
      __asm
      {
        vmovdqu ymm0, [rbp+0E0h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v17, 32i64);
    }
    while ( v17 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60((__int64)a1, (__int64)v16) >= 0x10 && sub_1400261C0() )
  {
    *(_QWORD *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v17;
    v12 = sub_140024E60((__int64)a1, (__int64)v16);
    sub_140024E30(&_RBP->m128i_i64[1], v12 & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E30(&v16, -16i64);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_loadu_si128(v16);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_load_si128(_RBP + 1);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_shuffle_epi32(
                                                                                 _mm_load_si128(_RBP + 2),
                                                                                 78);
      *(__m128i *)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_load_si128(_RBP + 3);
      *v17 = _mm_load_si128(_RBP + 4);
      sub_140024E00(&v17, 16i64);
    }
    while ( v17 != *(__m128i **)(((unsigned __int64)&v14 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021A80(a1, v16, v17);
}

//----- (00000001400273F0) ----------------------------------------------------
__int64 __fastcall sub_1400273F0(const __m128i *a1, const __m128i *a2)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v26; // rax
  __int64 v28; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v29; // [rsp+2D0h] [rbp+290h] BYREF
  __m128i *v30; // [rsp+2D8h] [rbp+298h] BYREF

  v30 = (__m128i *)a2;
  v29 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x40 && (unsigned __int8)sub_140026190() )
  {
    __asm
    {
      vmovdqu ymm0, cs:ymmword_140032FC0
      vmovdqu [rbp+280h+var_1A0], ymm0
      vmovdqu ymm0, [rbp+280h+var_1A0]
      vmovdqu [rbp+280h+var_1C0], ymm0
    }
    _RBP->m128i_i64[0] = (__int64)v29;
    v5 = sub_140024E60(v29, v30);
    sub_140024E30((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64, (v5 >> 1) & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      sub_140024E00(&v30, -32i64);
      _RAX = v29;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+280h+var_180], ymm0
        vmovdqu ymm0, [rbp+280h+var_180]
        vmovdqu [rbp+280h+var_140], ymm0
      }
      _RAX = v30;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+280h+var_160], ymm0
        vmovdqu ymm0, [rbp+280h+var_160]
        vmovdqu [rbp+280h+var_100], ymm0
        vpermq  ymm0, [rbp+280h+var_140], 4Eh
        vmovdqu [rbp+280h+var_120], ymm0
        vmovdqu ymm0, [rbp+280h+var_120]
        vmovdqu [rbp+280h+var_C0], ymm0
        vpermq  ymm0, [rbp+280h+var_100], 4Eh
        vmovdqu [rbp+280h+var_E0], ymm0
        vmovdqu ymm0, [rbp+280h+var_E0]
        vmovdqu [rbp+280h+var_80], ymm0
        vmovdqu ymm0, [rbp+280h+var_C0]
        vpshufb ymm0, ymm0, [rbp+280h+var_1C0]
        vmovdqu [rbp+280h+var_A0], ymm0
        vmovdqu ymm0, [rbp+280h+var_A0]
        vmovdqu [rbp+280h+var_20], ymm0
        vmovdqu ymm0, [rbp+280h+var_80]
        vpshufb ymm0, ymm0, [rbp+280h+var_1C0]
        vmovdqu [rbp+280h+var_60], ymm0
        vmovdqu ymm0, [rbp+280h+var_60]
        vmovdqu [rbp+280h+var_40], ymm0
      }
      _RAX = v29;
      __asm
      {
        vmovdqu ymm0, [rbp+280h+var_40]
        vmovdqu ymmword ptr [rax], ymm0
      }
      _RAX = v30;
      __asm
      {
        vmovdqu ymm0, [rbp+280h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v29, 32i64);
    }
    while ( v29 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(v29, v30) >= 0x20 && (unsigned __int8)sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_load_si128(xmmword_140032EB0);
    *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_load_si128(_RBP + 2);
    *(_QWORD *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v29;
    v26 = sub_140024E60(v29, v30);
    sub_140024E30(&_RBP->m128i_u64[1], (v26 >> 1) & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E00(&v30, -16i64);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_loadu_si128(v29);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = _mm_load_si128(_RBP + 3);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v30);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_shuffle_epi8(
                                                                                 _mm_load_si128(_RBP + 5),
                                                                                 *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                            + 0x10));
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0xA0) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_shuffle_epi8(
                                                                                 _mm_load_si128(_RBP + 7),
                                                                                 *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                            + 0x10));
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 8);
      *v29 = _mm_load_si128(_RBP + 9);
      *v30 = _mm_load_si128(_RBP + 10);
      sub_140024E00(&v29, 16i64);
    }
    while ( v29 != *(__m128i **)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021AE0(v29, v30);
}
// 140021AE0: using guessed type __int64 __fastcall sub_140021AE0(_QWORD, _QWORD);
// 140024E00: using guessed type __int64 __fastcall sub_140024E00(_QWORD, _QWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140026190: using guessed type __int64 sub_140026190(void);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032EB0: using guessed type __m128i xmmword_140032EB0[2];

//----- (0000000140027810) ----------------------------------------------------
__int64 __fastcall sub_140027810(const __m128i *a1, const __m128i *a2)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v26; // rax
  __int64 v28; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v29; // [rsp+2D0h] [rbp+290h] BYREF
  __m128i *v30; // [rsp+2D8h] [rbp+298h] BYREF

  v30 = (__m128i *)a2;
  v29 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x40 && (unsigned __int8)sub_140026190() )
  {
    __asm
    {
      vmovdqu ymm0, cs:ymmword_140033000
      vmovdqu [rbp+280h+var_1A0], ymm0
      vmovdqu ymm0, [rbp+280h+var_1A0]
      vmovdqu [rbp+280h+var_1C0], ymm0
    }
    _RBP->m128i_i64[0] = (__int64)v29;
    v5 = sub_140024E60(v29, v30);
    sub_140024E30((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64, (v5 >> 1) & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      sub_140024E00(&v30, -32i64);
      _RAX = v29;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+280h+var_180], ymm0
        vmovdqu ymm0, [rbp+280h+var_180]
        vmovdqu [rbp+280h+var_140], ymm0
      }
      _RAX = v30;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+280h+var_160], ymm0
        vmovdqu ymm0, [rbp+280h+var_160]
        vmovdqu [rbp+280h+var_100], ymm0
        vpermq  ymm0, [rbp+280h+var_140], 4Eh
        vmovdqu [rbp+280h+var_120], ymm0
        vmovdqu ymm0, [rbp+280h+var_120]
        vmovdqu [rbp+280h+var_C0], ymm0
        vpermq  ymm0, [rbp+280h+var_100], 4Eh
        vmovdqu [rbp+280h+var_E0], ymm0
        vmovdqu ymm0, [rbp+280h+var_E0]
        vmovdqu [rbp+280h+var_80], ymm0
        vmovdqu ymm0, [rbp+280h+var_C0]
        vpshufb ymm0, ymm0, [rbp+280h+var_1C0]
        vmovdqu [rbp+280h+var_A0], ymm0
        vmovdqu ymm0, [rbp+280h+var_A0]
        vmovdqu [rbp+280h+var_20], ymm0
        vmovdqu ymm0, [rbp+280h+var_80]
        vpshufb ymm0, ymm0, [rbp+280h+var_1C0]
        vmovdqu [rbp+280h+var_60], ymm0
        vmovdqu ymm0, [rbp+280h+var_60]
        vmovdqu [rbp+280h+var_40], ymm0
      }
      _RAX = v29;
      __asm
      {
        vmovdqu ymm0, [rbp+280h+var_40]
        vmovdqu ymmword ptr [rax], ymm0
      }
      _RAX = v30;
      __asm
      {
        vmovdqu ymm0, [rbp+280h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v29, 32i64);
    }
    while ( v29 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(v29, v30) >= 0x20 && (unsigned __int8)sub_1400261D0() )
  {
    *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_load_si128(xmmword_140032ED0);
    *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_load_si128(_RBP + 2);
    *(_QWORD *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v29;
    v26 = sub_140024E60(v29, v30);
    sub_140024E30(&_RBP->m128i_u64[1], (v26 >> 1) & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E00(&v30, -16i64);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_loadu_si128(v29);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = _mm_load_si128(_RBP + 3);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_loadu_si128(v30);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_shuffle_epi8(
                                                                                 _mm_load_si128(_RBP + 5),
                                                                                 *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                            + 0x10));
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0xA0) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_shuffle_epi8(
                                                                                 _mm_load_si128(_RBP + 7),
                                                                                 *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                            + 0x10));
      *(__m128i *)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 8);
      *v29 = _mm_load_si128(_RBP + 9);
      *v30 = _mm_load_si128(_RBP + 10);
      sub_140024E00(&v29, 16i64);
    }
    while ( v29 != *(__m128i **)(((unsigned __int64)&v28 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021B70(v29, v30);
}
// 140021B70: using guessed type __int64 __fastcall sub_140021B70(_QWORD, _QWORD);
// 140024E00: using guessed type __int64 __fastcall sub_140024E00(_QWORD, _QWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140026190: using guessed type __int64 sub_140026190(void);
// 1400261D0: using guessed type __int64 sub_1400261D0(void);
// 140032ED0: using guessed type __m128i xmmword_140032ED0[2];

//----- (0000000140027C30) ----------------------------------------------------
__int64 __fastcall sub_140027C30(const __m128i *a1, const __m128i *a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v22; // rax
  __int64 v24; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v25; // [rsp+230h] [rbp+1F0h] BYREF
  __m128i *v26; // [rsp+238h] [rbp+1F8h] BYREF

  v26 = (__m128i *)a2;
  v25 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x40 && (unsigned __int8)sub_140026190() )
  {
    _RBP->m128i_i64[0] = (__int64)v25;
    v3 = sub_140024E60(v25, v26);
    sub_140024E30((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64, (v3 >> 1) & 0xFFFFFFFFFFFFFFE0ui64);
    __asm
    {
      vmovdqu ymm0, cs:ymmword_140032F80
      vmovdqu [rbp+1E0h+var_120], ymm0
      vmovdqu ymm0, [rbp+1E0h+var_120]
      vmovdqu [rbp+1E0h+var_140], ymm0
    }
    do
    {
      sub_140024E00(&v26, -32i64);
      _RAX = v25;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+1E0h+var_100], ymm0
        vmovdqu ymm0, [rbp+1E0h+var_100]
        vmovdqu [rbp+1E0h+var_C0], ymm0
      }
      _RAX = v26;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+1E0h+var_E0], ymm0
        vmovdqu ymm0, [rbp+1E0h+var_E0]
        vmovdqu [rbp+1E0h+var_80], ymm0
        vmovdqu ymm0, [rbp+1E0h+var_140]
        vpermd  ymm0, ymm0, [rbp+1E0h+var_C0]
        vmovdqu [rbp+1E0h+var_A0], ymm0
        vmovdqu ymm0, [rbp+1E0h+var_A0]
        vmovdqu [rbp+1E0h+var_20], ymm0
        vmovdqu ymm0, [rbp+1E0h+var_140]
        vpermd  ymm0, ymm0, [rbp+1E0h+var_80]
        vmovdqu [rbp+1E0h+var_60], ymm0
        vmovdqu ymm0, [rbp+1E0h+var_60]
        vmovdqu [rbp+1E0h+var_40], ymm0
      }
      _RAX = v25;
      __asm
      {
        vmovdqu ymm0, [rbp+1E0h+var_40]
        vmovdqu ymmword ptr [rax], ymm0
      }
      _RAX = v26;
      __asm
      {
        vmovdqu ymm0, [rbp+1E0h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v25, 32i64);
    }
    while ( v25 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(v25, v26) >= 0x20 && (unsigned __int8)sub_1400261C0() )
  {
    *(_QWORD *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v25;
    v22 = sub_140024E60(v25, v26);
    sub_140024E30(&_RBP->m128i_u64[1], (v22 >> 1) & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E00(&v26, -16i64);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_loadu_si128(v25);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_load_si128(_RBP + 1);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_loadu_si128(v26);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = _mm_load_si128(_RBP + 2);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_shuffle_epi32(
                                                                                 _mm_load_si128(_RBP + 3),
                                                                                 27);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_shuffle_epi32(
                                                                                 _mm_load_si128(_RBP + 5),
                                                                                 27);
      *(__m128i *)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 6);
      *v25 = _mm_load_si128(_RBP + 7);
      *v26 = _mm_load_si128(_RBP + 8);
      sub_140024E00(&v25, 16i64);
    }
    while ( v25 != *(__m128i **)(((unsigned __int64)&v24 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021C00(v25, v26);
}
// 140021C00: using guessed type __int64 __fastcall sub_140021C00(_QWORD, _QWORD);
// 140024E00: using guessed type __int64 __fastcall sub_140024E00(_QWORD, _QWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140026190: using guessed type __int64 sub_140026190(void);
// 1400261C0: using guessed type __int64 sub_1400261C0(void);

//----- (0000000140027FD0) ----------------------------------------------------
__int64 __fastcall sub_140027FD0(const __m128i *a1, const __m128i *a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v18; // rax
  __int64 v20; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v21; // [rsp+1F0h] [rbp+1B0h] BYREF
  __m128i *v22; // [rsp+1F8h] [rbp+1B8h] BYREF

  v22 = (__m128i *)a2;
  v21 = (__m128i *)a1;
  _RBP = (__m128i *)((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64);
  if ( (unsigned __int64)sub_140024E60(a1, a2) >= 0x40 && (unsigned __int8)sub_140026190() )
  {
    _RBP->m128i_i64[0] = (__int64)v21;
    v3 = sub_140024E60(v21, v22);
    sub_140024E30((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64, (v3 >> 1) & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      sub_140024E00(&v22, -32i64);
      _RAX = v21;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+1A0h+var_100], ymm0
        vmovdqu ymm0, [rbp+1A0h+var_100]
        vmovdqu [rbp+1A0h+var_C0], ymm0
      }
      _RAX = v22;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+1A0h+var_E0], ymm0
        vmovdqu ymm0, [rbp+1A0h+var_E0]
        vmovdqu [rbp+1A0h+var_80], ymm0
        vpermq  ymm0, [rbp+1A0h+var_C0], 1Bh
        vmovdqu [rbp+1A0h+var_A0], ymm0
        vmovdqu ymm0, [rbp+1A0h+var_A0]
        vmovdqu [rbp+1A0h+var_20], ymm0
        vpermq  ymm0, [rbp+1A0h+var_80], 1Bh
        vmovdqu [rbp+1A0h+var_60], ymm0
        vmovdqu ymm0, [rbp+1A0h+var_60]
        vmovdqu [rbp+1A0h+var_40], ymm0
      }
      _RAX = v21;
      __asm
      {
        vmovdqu ymm0, [rbp+1A0h+var_40]
        vmovdqu ymmword ptr [rax], ymm0
      }
      _RAX = v22;
      __asm
      {
        vmovdqu ymm0, [rbp+1A0h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v21, 32i64);
    }
    while ( v21 != (__m128i *)_RBP->m128i_i64[0] );
  }
  if ( (unsigned __int64)sub_140024E60(v21, v22) >= 0x20 && (unsigned __int8)sub_1400261C0() )
  {
    *(_QWORD *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v21;
    v18 = sub_140024E60(v21, v22);
    sub_140024E30(&_RBP->m128i_u64[1], (v18 >> 1) & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      sub_140024E00(&v22, -16i64);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _mm_loadu_si128(v21);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = _mm_load_si128(_RBP + 1);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = _mm_loadu_si128(v22);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = _mm_load_si128(_RBP + 2);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = _mm_shuffle_epi32(
                                                                                 _mm_load_si128(_RBP + 3),
                                                                                 78);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 4);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_shuffle_epi32(
                                                                                 _mm_load_si128(_RBP + 5),
                                                                                 78);
      *(__m128i *)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_load_si128(_RBP + 6);
      *v21 = _mm_load_si128(_RBP + 7);
      *v22 = _mm_load_si128(_RBP + 8);
      sub_140024E00(&v21, 16i64);
    }
    while ( v21 != *(__m128i **)(((unsigned __int64)&v20 & 0xFFFFFFFFFFFFFFE0ui64) + 8) );
  }
  return sub_140021C90(v21, v22);
}
// 140021C90: using guessed type __int64 __fastcall sub_140021C90(_QWORD, _QWORD);
// 140024E00: using guessed type __int64 __fastcall sub_140024E00(_QWORD, _QWORD);
// 140024E30: using guessed type __int64 __fastcall sub_140024E30(_QWORD, _QWORD);
// 140024E60: using guessed type __int64 __fastcall sub_140024E60(_QWORD, _QWORD);
// 140026190: using guessed type __int64 sub_140026190(void);
// 1400261C0: using guessed type __int64 sub_1400261C0(void);

//----- (0000000140028330) ----------------------------------------------------
__int64 __fastcall sub_140028330(__int64 a1, __int64 a2, __int64 a3)
{
  sub_1400110AF(a1, a2, a3);
  return a2 - a1 + a3;
}
// 1400110AF: using guessed type __int64 __fastcall sub_1400110AF(_QWORD, _QWORD, _QWORD);

//----- (0000000140028390) ----------------------------------------------------
__int64 __fastcall sub_140028390(const __m128i *a1, __int64 a2, const __m128i *a3)
{
  __int64 v4; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 result; // rax
  char v18; // [rsp+40h] [rbp+0h] BYREF
  __m128i *v19; // [rsp+170h] [rbp+130h] BYREF
  __int64 v20; // [rsp+178h] [rbp+138h]
  __m128i *v21; // [rsp+180h] [rbp+140h] BYREF

  v21 = (__m128i *)a3;
  v20 = a2;
  v19 = (__m128i *)a1;
  _RBP = (const __m128i *)((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64);
  *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x48) = -32i64;
  if ( (unsigned __int64)sub_140024E60((__int64)v19, v20) >= 0x20 && sub_140026190() )
  {
    *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = v19;
    v4 = sub_140024E60((__int64)v19, v20);
    sub_140024E30(&_RBP[1].m128i_i64[1], v4 & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      _RAX = v19;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+120h+var_80], ymm0
        vmovdqu ymm0, [rbp+120h+var_80]
        vmovdqu [rbp+120h+var_20], ymm0
      }
      _RAX = v21;
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rax]
        vmovdqu [rbp+120h+var_60], ymm0
        vmovdqu ymm0, [rbp+120h+var_60]
        vmovdqu [rbp+120h+var_40], ymm0
      }
      _RAX = v19;
      __asm
      {
        vmovdqu ymm0, [rbp+120h+var_40]
        vmovdqu ymmword ptr [rax], ymm0
      }
      _RAX = v21;
      __asm
      {
        vmovdqu ymm0, [rbp+120h+var_20]
        vmovdqu ymmword ptr [rax], ymm0
      }
      sub_140024E00(&v19, 32i64);
      sub_140024E00(&v21, 32i64);
    }
    while ( v19 != *(__m128i **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x18) );
  }
  *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x50) = -16i64;
  if ( (unsigned __int64)sub_140024E60((__int64)v19, v20) >= 0x10 && sub_1400261C0() )
  {
    *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = v19;
    v15 = sub_140024E60((__int64)v19, v20);
    sub_140024E30((const __m128i *)_RBP[2].m128i_i64, v15 & 0xFFFFFFFFFFFFFFF0ui64);
    do
    {
      *(__m128i *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = _mm_loadu_si128(v19);
      *(__m128i *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = _mm_load_si128(_RBP + 6);
      *(__m128i *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = _mm_loadu_si128(v21);
      *(__m128i *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = _mm_load_si128(_RBP + 7);
      *v19 = _mm_load_si128(_RBP + 8);
      *v21 = _mm_load_si128(_RBP + 9);
      sub_140024E00(&v19, 16i64);
      sub_140024E00(&v21, 16i64);
    }
    while ( v19 != *(__m128i **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20) );
  }
  *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x58) = -8i64;
  if ( (unsigned __int64)sub_140024E60((__int64)v19, v20) >= 8 )
  {
    *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = v19;
    v16 = sub_140024E60((__int64)v19, v20);
    sub_140024E30(&_RBP[2].m128i_i64[1], v16 & 0xFFFFFFFFFFFFFFF8ui64);
    do
    {
      *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = v19->m128i_i64[0];
      *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = v21->m128i_i64[0];
      v19->m128i_i64[0] = *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x30);
      v21->m128i_i64[0] = *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x38);
      sub_140024E00(&v19, 8i64);
      sub_140024E00(&v21, 8i64);
    }
    while ( v19 != *(__m128i **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x28) );
  }
  *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = v19;
  *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = v20;
  for ( *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = v21;
        ;
        ++*(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) )
  {
    result = *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x40);
    if ( *(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 8) == result )
      break;
    *(_BYTE *)((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) = **(_BYTE **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                             + 8);
    **(_BYTE **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 8) = **(_BYTE **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64)
                                                                                     + 0x10);
    **(_BYTE **)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = _RBP->m128i_i8[0];
    ++*(_QWORD *)(((unsigned __int64)&v18 & 0xFFFFFFFFFFFFFFE0ui64) + 8);
  }
  return result;
}

//----- (0000000140028860) ----------------------------------------------------
void *__fastcall sub_140028860(size_t a1)
{
  void *v2; // [rsp+20h] [rbp-18h]

  while ( 1 )
  {
    v2 = j_malloc(a1);
    if ( v2 )
      break;
    if ( !j__callnewh(a1) )
    {
      if ( a1 == -1i64 )
        sub_14001177B();
      sub_1400111FE();
    }
  }
  return v2;
}
// 1400111FE: using guessed type void __noreturn sub_1400111FE(void);
// 14001177B: using guessed type void __noreturn sub_14001177B(void);

//----- (00000001400288D0) ----------------------------------------------------
__int64 __fastcall sub_1400288D0(__int64 a1)
{
  return sub_140011663(a1);
}
// 140011663: using guessed type __int64 __fastcall sub_140011663(_QWORD);

//----- (0000000140028E50) ----------------------------------------------------
__int64 __fastcall sub_140028E50(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  __int64 result; // rax

  if ( a1 && a2 )
  {
    if ( a3 )
    {
      memset((void *)a1, 204, a2);
      result = *a3;
      *(_QWORD *)(a1 + 4) = *a3;
      *(_QWORD *)(a1 + 12) = a2;
      *a3 = a1;
    }
  }
  return result;
}

//----- (0000000140028EA0) ----------------------------------------------------
__int64 __fastcall sub_140028EA0(__int64 a1, __int64 a2)
{
  int v2; // ebx
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 result; // rax
  void *retaddr; // [rsp+28h] [rbp+0h]

  v2 = 0;
  if ( *(int *)a2 > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = *(_QWORD *)(a2 + 8);
      v7 = *(int *)(v6 + v5);
      if ( *(_DWORD *)(v7 + a1 - 4) != -858993460
        || (result = v7 + *(int *)(v6 + v5 + 4), *(_DWORD *)(result + a1) != -858993460) )
      {
        result = sub_1400114E2(retaddr, *(_QWORD *)(v6 + v5 + 8));
      }
      ++v2;
      v5 += 16i64;
    }
    while ( v2 < *(_DWORD *)a2 );
  }
  return result;
}
// 1400114E2: using guessed type __int64 __fastcall sub_1400114E2(_QWORD, _QWORD);

//----- (0000000140028F50) ----------------------------------------------------
__int64 __fastcall sub_140028F50(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // edi
  int v7; // esi
  __int64 v8; // r14
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 result; // rax
  __int64 retaddr; // [rsp+38h] [rbp+0h]

  v3 = 0;
  if ( a2 )
  {
    v7 = 0;
    if ( *(int *)a2 > 0 )
    {
      v8 = 0i64;
      do
      {
        v9 = *(_QWORD *)(a2 + 8);
        v10 = *(int *)(v9 + v8);
        if ( *(_DWORD *)(v10 + a1 - 4) != -858993460 || *(_DWORD *)(v10 + *(int *)(v9 + v8 + 4) + a1) != -858993460 )
          sub_1400114E2(retaddr, *(_QWORD *)(v9 + v8 + 8));
        ++v7;
        v8 += 16i64;
      }
      while ( v7 < *(_DWORD *)a2 );
    }
  }
  result = a3;
  if ( a3 )
  {
    do
    {
      result = *(_QWORD *)(result + 4);
      ++v3;
    }
    while ( result );
    do
    {
      if ( *(_DWORD *)a3 != -858993460
        || *(_DWORD *)(a3 + 20) != -858993460
        || *(_DWORD *)(a3 + 24) != -858993460
        || *(_DWORD *)(a3 + 28) != -858993460 )
      {
        sub_14001171C(retaddr, a3, v3);
      }
      result = *(_QWORD *)(a3 + 12);
      if ( *(_DWORD *)(result + a3 - 4) != -858993460 )
        result = sub_14001171C(retaddr, a3, v3);
      a3 = *(_QWORD *)(a3 + 4);
      --v3;
    }
    while ( a3 );
  }
  return result;
}
// 1400114E2: using guessed type __int64 __fastcall sub_1400114E2(_QWORD, _QWORD);

//----- (00000001400290B0) ----------------------------------------------------
void *sub_1400290B0()
{
  return &sub_1400110E6;
}

//----- (00000001400290C0) ----------------------------------------------------
void sub_1400290C0()
{
  if ( !byte_140037AC6 )
  {
    byte_140037AC6 = 1;
    qword_140037AE8 = (__int64)sub_14001105F();
    qword_140037AE0 = 0i64;
  }
}
// 140037AC6: using guessed type char byte_140037AC6;
// 140037AE0: using guessed type __int64 qword_140037AE0;
// 140037AE8: using guessed type __int64 qword_140037AE8;

//----- (0000000140029110) ----------------------------------------------------
void *sub_140029110()
{
  return sub_14001105F();
}

//----- (0000000140029140) ----------------------------------------------------
DWORD __fastcall sub_140029140(_BYTE *a1)
{
  DWORD result; // eax

  result = (unsigned __int8)*a1;
  if ( *a1 )
  {
    if ( dword_140037BC4 )
      return GetCurrentThreadId();
  }
  return result;
}
// 140037BC4: using guessed type int dword_140037BC4;

//----- (0000000140029430) ----------------------------------------------------
_QWORD *__fastcall sub_140029430(_QWORD *a1)
{
  _QWORD *result; // rax

  result = a1;
  *a1 = &type_info::`vftable';
  return result;
}
// 140033048: using guessed type void *type_info::`vftable';

//----- (0000000140029450) ----------------------------------------------------
__int64 __fastcall sub_140029450(__int64 a1, char a2)
{
  sub_140011776(a1);
  if ( (a2 & 1) != 0 )
    sub_1400115EB(a1, 24i64);
  return a1;
}
// 1400115EB: using guessed type __int64 __fastcall sub_1400115EB(_QWORD, _QWORD);
// 140011776: using guessed type __int64 __fastcall sub_140011776(_QWORD);

//----- (00000001400294A0) ----------------------------------------------------
__int64 sub_1400294A0()
{
  int v0; // eax

  sub_140011190();
  sub_140011668();
  sub_14001100F();
  if ( !(unsigned __int8)sub_1400111CC(1i64) )
    sub_14001160E(7i64);
  sub_140011438();
  sub_1400112DF(sub_140011483);
  if ( (unsigned int)sub_140011479() )
    sub_14001160E(7i64);
  sub_14001117C();
  if ( (unsigned int)sub_14001149C() )
    j___setusermatherr(UserMathErrorFunction);
  j_nullsub_2();
  j_nullsub_1();
  v0 = sub_1400110C8();
  j__configthreadlocale(v0);
  if ( (unsigned __int8)sub_14001137F() )
    sub_14001127B();
  sub_1400113FC();
  if ( (unsigned int)sub_14001173F() )
    sub_14001160E(7i64);
  return 0i64;
}
// 14001100F: using guessed type __int64 sub_14001100F(void);
// 1400110C8: using guessed type __int64 sub_1400110C8(void);
// 14001117C: using guessed type __int64 sub_14001117C(void);
// 140011190: using guessed type __int64 sub_140011190(void);
// 1400111CC: using guessed type __int64 __fastcall sub_1400111CC(_QWORD);
// 14001122B: using guessed type __int64 j_nullsub_1(void);
// 14001127B: using guessed type __int64 sub_14001127B(void);
// 1400112DF: using guessed type __int64 __fastcall sub_1400112DF(_QWORD);
// 14001137F: using guessed type __int64 sub_14001137F(void);
// 1400113FC: using guessed type __int64 sub_1400113FC(void);
// 140011438: using guessed type __int64 sub_140011438(void);
// 140011479: using guessed type __int64 sub_140011479(void);
// 140011483: using guessed type __int64 __fastcall sub_140011483();
// 14001149C: using guessed type __int64 sub_14001149C(void);
// 14001160E: using guessed type __int64 __fastcall sub_14001160E(_QWORD);
// 140011668: using guessed type __int64 sub_140011668(void);
// 14001173A: using guessed type __int64 j_nullsub_2(void);
// 14001173F: using guessed type __int64 sub_14001173F(void);
// 1400294A0: using guessed type __int64 __fastcall sub_1400294A0();

//----- (0000000140029580) ----------------------------------------------------
__int64 sub_140029580()
{
  sub_1400115B9();
  return 0i64;
}
// 1400115B9: using guessed type __int64 sub_1400115B9(void);
// 140029580: using guessed type __int64 __fastcall sub_140029580();

//----- (00000001400295A0) ----------------------------------------------------
int sub_1400295A0()
{
  int v0; // eax

  sub_1400114A6();
  v0 = sub_1400110EB();
  return j__set_new_mode(v0);
}
// 1400110EB: using guessed type __int64 sub_1400110EB(void);
// 1400114A6: using guessed type __int64 sub_1400114A6(void);

//----- (00000001400295C0) ----------------------------------------------------
__int64 sub_1400295C0()
{
  sub_140011532();
  return sub_1400295E0();
}
// 140011532: using guessed type __int64 sub_140011532(void);

//----- (00000001400295E0) ----------------------------------------------------
__int64 sub_1400295E0()
{
  __int64 v1; // rcx
  char v2; // [rsp+20h] [rbp-48h]
  unsigned __int8 v3; // [rsp+21h] [rbp-47h]
  unsigned int Code; // [rsp+28h] [rbp-40h]
  void (__fastcall **v5)(_QWORD, __int64, _QWORD); // [rsp+30h] [rbp-38h]
  _tls_callback_type *v6; // [rsp+38h] [rbp-30h]

  if ( !(unsigned __int8)sub_14001175D(1i64) )
    sub_14001160E(7i64);
  v2 = 0;
  v3 = sub_140011654();
  if ( dword_140037AF8 == 1 )
  {
    sub_14001160E(7i64);
  }
  else if ( dword_140037AF8 )
  {
    v2 = 1;
  }
  else
  {
    dword_140037AF8 = 1;
    if ( j__initterm_e((_PIFV *)&First, (_PIFV *)&Last) )
      return 255i64;
    j__initterm((_PVFV *)&qword_140031000, (_PVFV *)&qword_140031220);
    dword_140037AF8 = 2;
  }
  sub_1400115F0(v3);
  v5 = (void (__fastcall **)(_QWORD, __int64, _QWORD))sub_140011550();
  if ( *v5 && (unsigned __int8)sub_1400112D5((__int64)v5) )
    (*v5)(0i64, 2i64, 0i64);
  v6 = (_tls_callback_type *)sub_14001159B();
  if ( *v6 && (unsigned __int8)sub_1400112D5((__int64)v6) )
    j__register_thread_local_exe_atexit_callback(*v6);
  Code = sub_140029830();
  if ( !(unsigned __int8)sub_14001151E() )
    j_exit(Code);
  if ( !v2 )
    j__cexit();
  LOBYTE(v1) = 1;
  sub_1400112A3(v1, 0i64);
  return Code;
}
// 140029739: variable 'v1' is possibly undefined
// 14001151E: using guessed type __int64 sub_14001151E(void);
// 140011550: using guessed type __int64 sub_140011550(void);
// 14001159B: using guessed type __int64 sub_14001159B(void);
// 1400115F0: using guessed type __int64 __fastcall sub_1400115F0(_QWORD);
// 14001160E: using guessed type __int64 __fastcall sub_14001160E(_QWORD);
// 140011654: using guessed type __int64 sub_140011654(void);
// 14001175D: using guessed type __int64 __fastcall sub_14001175D(_QWORD);
// 140029830: using guessed type __int64 sub_140029830(void);
// 140037AF8: using guessed type int dword_140037AF8;

//----- (00000001400297F0) ----------------------------------------------------
errno_t sub_1400297F0()
{
  _crt_argv_mode v0; // eax

  v0 = (unsigned int)sub_1400113F2();
  return j__configure_narrow_argv(v0);
}
// 1400113F2: using guessed type __int64 sub_1400113F2(void);

//----- (0000000140029810) ----------------------------------------------------
int sub_140029810()
{
  return j__initialize_narrow_environment();
}

//----- (0000000140029830) ----------------------------------------------------
__int64 sub_140029830()
{
  unsigned int v1; // [rsp+20h] [rbp-28h]
  char **initial_narrow_environment; // [rsp+28h] [rbp-20h]
  char **v3; // [rsp+30h] [rbp-18h]

  initial_narrow_environment = j__get_initial_narrow_environment();
  v3 = *j___p___argv();
  v1 = *j___p___argc();
  return sub_140011505(v1, v3, initial_narrow_environment);
}
// 140011505: using guessed type __int64 __fastcall sub_140011505(_QWORD, _QWORD, _QWORD);

//----- (0000000140029880) ----------------------------------------------------
void sub_140029880()
{
  j__set_app_type(_crt_console_app);
}

//----- (00000001400298A0) ----------------------------------------------------
int *sub_1400298A0()
{
  int *result; // rax
  int v1; // [rsp+20h] [rbp-18h]

  v1 = sub_14001135C();
  result = j___p__commode();
  *result = v1;
  return result;
}
// 14001135C: using guessed type __int64 sub_14001135C(void);

//----- (00000001400298D0) ----------------------------------------------------
errno_t sub_1400298D0()
{
  int v0; // eax

  v0 = sub_1400113E8();
  return j__set_fmode(v0);
}
// 1400113E8: using guessed type __int64 sub_1400113E8(void);

//----- (00000001400298F0) ----------------------------------------------------
__int64 start_0()
{
  return sub_1400295C0();
}
// 1400298F0: using guessed type __int64 __fastcall start_0();

//----- (0000000140029910) ----------------------------------------------------
__int64 sub_140029910()
{
  bool v16; // [rsp+0h] [rbp-58h]
  int v17; // [rsp+14h] [rbp-44h]
  int v18; // [rsp+34h] [rbp-24h]

  _RAX = 0i64;
  __asm { cpuid }
  v17 = _RAX;
  v16 = ((unsigned int)_RCX ^ 0x6C65746E | (unsigned int)_RDX ^ 0x49656E69 | (unsigned int)_RBX ^ 0x756E6547) == 0;
  _RAX = 1i64;
  __asm { cpuid }
  if ( v16 )
  {
    qword_140037030 = 0x8000i64;
    qword_140037038 = -1i64;
    if ( (_RAX & 0xFFF3FF0) == 67264
      || (_RAX & 0xFFF3FF0) == 132704
      || (_RAX & 0xFFF3FF0) == 132720
      || (_RAX & 0xFFF3FF0) == 198224
      || (_RAX & 0xFFF3FF0) == 198240
      || (_RAX & 0xFFF3FF0) == 198256 )
    {
      dword_140037AC8 |= 1u;
    }
  }
  v18 = _RCX;
  if ( v17 >= 7 )
  {
    _RAX = 7i64;
    __asm { cpuid }
    if ( (_RBX & 0x200) != 0 )
      dword_140037AC8 |= 2u;
  }
  dword_140037028 = 1;
  dword_14003702C = 2;
  if ( (v18 & 0x100000) != 0 )
  {
    dword_140037028 = 2;
    dword_14003702C |= 4u;
    if ( (v18 & 0x8000000) != 0 && (v18 & 0x10000000) != 0 )
      __asm { xgetbv }
  }
  return 0i64;
}
// 140029910: using guessed type __int64 __fastcall sub_140029910();
// 140037028: using guessed type int dword_140037028;
// 14003702C: using guessed type int dword_14003702C;
// 140037030: using guessed type __int64 qword_140037030;
// 140037038: using guessed type __int64 qword_140037038;
// 140037AC8: using guessed type int dword_140037AC8;

//----- (0000000140029DA0) ----------------------------------------------------
_QWORD *__fastcall sub_140029DA0(_QWORD *a1)
{
  sub_14001150A(a1, "bad allocation", 1i64);
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 14001150A: using guessed type __int64 __fastcall sub_14001150A(_QWORD, _QWORD, _QWORD);
// 1400325B0: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140029DF0) ----------------------------------------------------
void __noreturn sub_140029DF0()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_1400117C6(pExceptionObject);
  j__CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 140029DF0: using guessed type void __fastcall __noreturn sub_140029DF0();
// 140029DF0: using guessed type _QWORD pExceptionObject[5];

//----- (0000000140029E20) ----------------------------------------------------
void __noreturn sub_140029E20()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_140011627(pExceptionObject);
  j__CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 140029E20: using guessed type void __fastcall __noreturn sub_140029E20();
// 140029E20: using guessed type _QWORD pExceptionObject[5];

//----- (0000000140029E50) ----------------------------------------------------
__int64 __fastcall sub_140029E50(__int64 a1)
{
  return j__free_dbg(a1, 0xFFFFFFFFi64);
}
// 14001116D: using guessed type __int64 __fastcall j__free_dbg(_QWORD, _QWORD);

//----- (0000000140029E80) ----------------------------------------------------
bool __fastcall sub_140029E80(int a1)
{
  ULONG_PTR Arguments; // [rsp+20h] [rbp-38h] BYREF
  int v3; // [rsp+28h] [rbp-30h]
  char *v4; // [rsp+30h] [rbp-28h]
  char v5; // [rsp+60h] [rbp+8h] BYREF

  v3 = a1;
  v4 = &v5;
  v5 = 0;
  LODWORD(Arguments) = 4097;
  sub_14002A660(&Arguments);
  return v5 != 0;
}

//----- (0000000140029ED0) ----------------------------------------------------
bool __fastcall sub_140029ED0(int a1, int a2, __int64 a3, __int64 a4)
{
  ULONG_PTR Arguments; // [rsp+20h] [rbp-38h] BYREF
  int v6; // [rsp+28h] [rbp-30h]
  int v7; // [rsp+2Ch] [rbp-2Ch]
  __int64 v8; // [rsp+30h] [rbp-28h]
  char *v9; // [rsp+38h] [rbp-20h]
  __int64 v10; // [rsp+40h] [rbp-18h]
  char v11; // [rsp+60h] [rbp+8h] BYREF

  v6 = a1;
  v9 = &v11;
  v11 = 0;
  LODWORD(Arguments) = 4098;
  v7 = a2;
  v8 = a3;
  v10 = a4;
  sub_14002A660(&Arguments);
  return v11 != 0;
}

//----- (0000000140029F30) ----------------------------------------------------
__int64 __fastcall sub_140029F30(__int64 a1, __int64 a2, int a3)
{
  unsigned int v3; // edi
  __int64 result; // rax
  const void *v8; // rbx
  int v9; // [rsp+48h] [rbp-1D0h]
  char v10[24]; // [rsp+80h] [rbp-198h] BYREF
  char v11[56]; // [rsp+98h] [rbp-180h] BYREF
  char v12[272]; // [rsp+D0h] [rbp-148h] BYREF

  v3 = dword_140037058;
  if ( dword_140037058 != -1 )
  {
    if ( a2 )
    {
      v8 = (const void *)(a2 + 32);
      sub_14002A260(v10, v11, a2 + 32, *(_QWORD *)(a2 + 12) - 36i64);
      v9 = a3;
      sub_140011451(
        v12,
        262i64,
        "%s%s%p%s%zd%s%d%s%s%s%s%s",
        "Stack area around _alloca memory reserved by this function is corrupted",
        "\nAddress: 0x",
        v8,
        "\nSize: ",
        *(_QWORD *)(a2 + 12) - 36i64,
        "\nAllocation number within this function: ",
        v9,
        "\nData: <",
        v10,
        "> ",
        v11,
        "\n");
      return sub_14002A360(a1, v3, 4i64, v12);
    }
    else
    {
      return sub_14002A360(
               a1,
               (unsigned int)dword_140037058,
               4i64,
               "Stack area around _alloca memory reserved by this function is corrupted\n");
    }
  }
  return result;
}
// 140011451: using guessed type __int64 sub_140011451(_QWORD, _QWORD, const char *, ...);
// 14002A260: using guessed type __int64 __fastcall sub_14002A260(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002A360: using guessed type __int64 __fastcall sub_14002A360(_QWORD, _QWORD, _QWORD, _QWORD);
// 140037058: using guessed type int dword_140037058;

//----- (000000014002A150) ----------------------------------------------------
void __fastcall sub_14002A150(__int64 a1, char *a2)
{
  unsigned int v2; // edi
  char *v5; // r9
  char Destination[1024]; // [rsp+20h] [rbp-418h] BYREF

  v2 = dword_140037050;
  if ( dword_140037050 != -1 )
  {
    if ( *a2 && (unsigned __int64)(sub_14002A340(a2) + 45) <= 0x400 )
    {
      j_strcpy_s(Destination, 0x400ui64, "Stack around the variable '");
      j_strcat_s(Destination, 0x400ui64, a2);
      j_strcat_s(Destination, 0x400ui64, "' was corrupted.");
      v5 = Destination;
    }
    else
    {
      v5 = "Stack corrupted near unknown variable";
    }
    sub_14002A360(a1, v2, 2, v5);
  }
}
// 140037050: using guessed type int dword_140037050;

//----- (000000014002A260) ----------------------------------------------------
__int64 __fastcall sub_14002A260(unsigned __int8 *a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // r15
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v8; // r12
  __int64 v9; // rbp
  unsigned __int8 *v10; // rdi
  __int64 v11; // r14
  unsigned __int8 v12; // bl
  __int64 result; // rax

  v4 = 0i64;
  v5 = 16i64;
  v6 = a2;
  if ( a4 < 0x10 )
    v5 = a4;
  if ( v5 )
  {
    v8 = a3 - (_QWORD)a1;
    v9 = a2;
    v10 = a1;
    v11 = 49i64;
    v4 = v5;
    do
    {
      v12 = v10[v8];
      sub_140011451(v9, v11, "%.2X ", v12);
      v11 -= 3i64;
      *v10 = v12;
      v9 += 3i64;
      ++v10;
      --v5;
    }
    while ( v5 );
    v6 = a2;
  }
  result = v6 + 2 * v4;
  a1[v4] = 0;
  *(_BYTE *)(v4 + result) = 0;
  return result;
}
// 140011451: using guessed type __int64 sub_140011451(_QWORD, _QWORD, const char *, ...);

//----- (000000014002A340) ----------------------------------------------------
__int64 __fastcall sub_14002A340(_BYTE *a1)
{
  _BYTE *v1; // rax

  v1 = a1;
  while ( *v1++ )
    ;
  return v1 - a1 - 1;
}

//----- (000000014002A360) ----------------------------------------------------
char __fastcall sub_14002A360(__int64 a1, unsigned int a2, int a3, const CHAR *a4)
{
  __int64 v4; // rbp
  __int64 (__fastcall *v5)(_QWORD, CHAR *, _QWORD, CHAR *, const char *, _DWORD, const CHAR *); // r14
  __int64 (__fastcall *v9)(_QWORD, WCHAR *, _QWORD, WCHAR *, const wchar_t *, _DWORD, WCHAR *); // rdi
  int cchWideChar; // eax
  WCHAR *v11; // rsi
  int v12; // eax
  CHAR *v13; // rbx
  int v14; // eax
  CHAR *v15; // r9
  unsigned int v17; // [rsp+40h] [rbp-EA8h] BYREF
  WCHAR v18[264]; // [rsp+50h] [rbp-E98h] BYREF
  WCHAR v19[264]; // [rsp+260h] [rbp-C88h] BYREF
  CHAR MultiByteStr[784]; // [rsp+470h] [rbp-A78h] BYREF
  CHAR v21[784]; // [rsp+780h] [rbp-768h] BYREF
  WCHAR WideCharStr[512]; // [rsp+A90h] [rbp-458h] BYREF

  v4 = a3;
  v5 = 0i64;
  v9 = (__int64 (__fastcall *)(_QWORD, WCHAR *, _QWORD, WCHAR *, const wchar_t *, _DWORD, WCHAR *))sub_140011109();
  if ( !v9 )
    v5 = (__int64 (__fastcall *)(_QWORD, CHAR *, _QWORD, CHAR *, const char *, _DWORD, const CHAR *))sub_140011717(a1);
  cchWideChar = MultiByteToWideChar(0xFDE9u, 0, a4, -1, 0i64, 0);
  if ( (unsigned __int64)cchWideChar >= 0x200
    || (v11 = WideCharStr, !MultiByteToWideChar(0xFDE9u, 0, a4, -1, WideCharStr, cchWideChar)) )
  {
    v11 = L"Runtime Check Error.\r\n Unable to display RTC Message.";
  }
  if ( sub_140029E80(4098) )
  {
    LOBYTE(v12) = sub_140029ED0(v4, dword_1400330A0[v4], a1, (__int64)v11);
    if ( (_BYTE)v12 )
      return v12;
  }
  else
  {
    LOBYTE(v12) = 1;
  }
  if ( !v5 && !v9 )
    goto LABEL_22;
  if ( (_BYTE)v12 )
  {
    v12 = IsDebuggerPresent();
    if ( v12 )
      goto LABEL_22;
  }
  sub_140011573(a1 - 5, (unsigned int)v18, 260, (unsigned int)&v17, (__int64)v19, 260);
  if ( v9 )
  {
    v12 = v9(a2, v18, v17, v19, L"Run-Time Check Failure #%d - %s", v4, v11);
  }
  else
  {
    v13 = MultiByteStr;
    if ( !WideCharToMultiByte(0xFDE9u, 0, v18, -1, MultiByteStr, 778, 0i64, 0i64) )
      v13 = "Unknown Filename";
    v14 = WideCharToMultiByte(0xFDE9u, 0, v19, -1, v21, 778, 0i64, 0i64);
    v15 = v21;
    if ( !v14 )
      v15 = "Unknown Module Name";
    v12 = v5(a2, v13, v17, v15, "Run-Time Check Failure #%d - %s", v4, a4);
  }
  if ( v12 == 1 )
LABEL_22:
    __debugbreak();
  return v12;
}
// 140011109: using guessed type __int64 sub_140011109(void);
// 140011573: using guessed type __int64 __fastcall sub_140011573(_DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD);
// 140011717: using guessed type __int64 __fastcall sub_140011717(_QWORD);
// 1400330A0: using guessed type _DWORD dword_1400330A0[6];
// 140033480: using guessed type wchar_t aRuntimeCheckEr[54];
// 140033510: using guessed type wchar_t aRunTimeCheckFa[32];

//----- (000000014002A660) ----------------------------------------------------
void __fastcall sub_14002A660(ULONG_PTR *lpArguments)
{
  RaiseException(0x406D1388u, 0, 5u, lpArguments);
}

//----- (000000014002A690) ----------------------------------------------------
void __fastcall sub_14002A690(char *Source)
{
  unsigned int v1; // edi
  char *v3; // r9
  char Destination[1024]; // [rsp+20h] [rbp-418h] BYREF
  __int64 retaddr; // [rsp+438h] [rbp+0h]

  v1 = dword_140037054;
  if ( dword_140037054 != -1 )
  {
    if ( Source && (unsigned __int64)(sub_14002A340(Source) + 58) <= 0x400 )
    {
      j_strcpy_s(Destination, 0x400ui64, "The variable '");
      j_strcat_s(Destination, 0x400ui64, Source);
      j_strcat_s(Destination, 0x400ui64, "' is being used without being initialized.");
      v3 = Destination;
    }
    else
    {
      v3 = "A variable is being used without being initialized.";
    }
    sub_14002A360(retaddr, v1, 3, v3);
  }
}
// 140037054: using guessed type int dword_140037054;

//----- (000000014002A790) ----------------------------------------------------
void *sub_14002A790()
{
  return &unk_140037AD0;
}

//----- (000000014002A7A0) ----------------------------------------------------
int __fastcall sub_14002A7A0(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList)
{
  unsigned __int64 *v9; // rax
  int result; // eax

  v9 = (unsigned __int64 *)sub_14001103C();
  result = j___stdio_common_vsprintf_s(*v9, Buffer, BufferCount, Format, Locale, ArgList);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (000000014002A820) ----------------------------------------------------
__int64 sub_14002A820(char *a1, size_t a2, char *a3, ...)
{
  va_list va; // [rsp+58h] [rbp+20h] BYREF

  va_start(va, a3);
  return sub_1400116F4(a1, a2, a3, 0i64, va);
}

//----- (000000014002A850) ----------------------------------------------------
__int64 sub_14002A850()
{
  return qword_140037AE0;
}
// 14002A850: using guessed type __int64 __fastcall sub_14002A850();
// 140037AE0: using guessed type __int64 qword_140037AE0;

//----- (000000014002A860) ----------------------------------------------------
__int64 sub_14002A860()
{
  return qword_140037AE8;
}
// 14002A860: using guessed type __int64 __fastcall sub_14002A860();
// 140037AE8: using guessed type __int64 qword_140037AE8;

//----- (000000014002A910) ----------------------------------------------------
__int64 __fastcall sub_14002A910(__int64 a1, unsigned __int64 a2)
{
  __int64 i; // [rsp+0h] [rbp-38h]
  __int64 v4; // [rsp+8h] [rbp-30h]

  v4 = *(int *)(a1 + 60) + a1;
  for ( i = v4 + *(unsigned __int16 *)(v4 + 20) + 24;
        i != 40i64 * *(unsigned __int16 *)(v4 + 6) + v4 + *(unsigned __int16 *)(v4 + 20) + 24;
        i += 40i64 )
  {
    if ( a2 >= *(unsigned int *)(i + 12) && a2 < (unsigned int)(*(_DWORD *)(i + 8) + *(_DWORD *)(i + 12)) )
      return i;
  }
  return 0i64;
}

//----- (000000014002AA10) ----------------------------------------------------
bool __fastcall sub_14002AA10(__int64 a1)
{
  __int64 v2; // [rsp+8h] [rbp-20h]

  if ( !a1 )
    return 0;
  if ( *(_WORD *)a1 != 23117 )
    return 0;
  v2 = *(int *)(a1 + 60) + a1;
  return *(_DWORD *)v2 == 17744 && *(_WORD *)(v2 + 24) == 523;
}

//----- (000000014002AAC0) ----------------------------------------------------
struct _TEB *sub_14002AAC0()
{
  return NtCurrentTeb();
}

//----- (000000014002AAD0) ----------------------------------------------------
char sub_14002AAD0()
{
  signed __int64 v1; // [rsp+20h] [rbp-28h]
  PVOID StackBase; // [rsp+28h] [rbp-20h]

  if ( !(unsigned int)sub_1400112B2() )
    return 0;
  StackBase = sub_140011636()->NtTib.StackBase;
  while ( 1 )
  {
    v1 = _InterlockedCompareExchange64(&qword_140037B00, (signed __int64)StackBase, 0i64);
    if ( !v1 )
      break;
    if ( StackBase == (PVOID)v1 )
      return 1;
  }
  return 0;
}
// 1400112B2: using guessed type __int64 sub_1400112B2(void);
// 140037B00: using guessed type signed __int64 qword_140037B00;

//----- (000000014002AB50) ----------------------------------------------------
char sub_14002AB50()
{
  if ( (unsigned int)sub_1400112B2() )
  {
    sub_1400115FF();
  }
  else
  {
    if ( (unsigned int)sub_140011479() )
      return 0;
    sub_14001127B();
  }
  return 1;
}
// 14001127B: using guessed type __int64 sub_14001127B(void);
// 1400112B2: using guessed type __int64 sub_1400112B2(void);
// 140011479: using guessed type __int64 sub_140011479(void);
// 1400115FF: using guessed type __int64 sub_1400115FF(void);

//----- (000000014002AB90) ----------------------------------------------------
bool sub_14002AB90()
{
  return (unsigned __int8)sub_1400111CC(0i64) != 0;
}
// 1400111CC: using guessed type __int64 __fastcall sub_1400111CC(_QWORD);

//----- (000000014002ABC0) ----------------------------------------------------
char sub_14002ABC0()
{
  if ( !(unsigned __int8)sub_1400111B3() )
    return 0;
  if ( (unsigned __int8)sub_140011366() )
    return 1;
  sub_1400112FD();
  return 0;
}
// 1400111B3: using guessed type __int64 sub_1400111B3(void);
// 1400112FD: using guessed type __int64 sub_1400112FD(void);
// 140011366: using guessed type __int64 sub_140011366(void);

//----- (000000014002AC00) ----------------------------------------------------
char sub_14002AC00()
{
  sub_1400114BA();
  sub_1400112FD();
  return 1;
}
// 1400112FD: using guessed type __int64 sub_1400112FD(void);
// 1400114BA: using guessed type __int64 sub_1400114BA(void);

//----- (000000014002AC20) ----------------------------------------------------
int __fastcall sub_14002AC20(
        __int64 a1,
        int a2,
        __int64 a3,
        void (__fastcall *a4)(__int64, _QWORD, __int64),
        unsigned int ExceptionNum,
        struct _EXCEPTION_POINTERS *ExceptionPtr)
{
  if ( !(unsigned int)sub_1400112B2() && a2 == 1 )
    a4(a1, 0i64, a3);
  return j__seh_filter_dll(ExceptionNum, ExceptionPtr);
}
// 1400112B2: using guessed type __int64 sub_1400112B2(void);

//----- (000000014002ACA0) ----------------------------------------------------
void sub_14002ACA0()
{
  if ( (unsigned int)sub_1400112B2() )
  {
    j__execute_onexit_table(&Table);
  }
  else if ( !(unsigned int)sub_1400110FF() )
  {
    j__cexit();
  }
}
// 1400110FF: using guessed type __int64 sub_1400110FF(void);
// 1400112B2: using guessed type __int64 sub_1400112B2(void);

//----- (000000014002ACE0) ----------------------------------------------------
__int64 sub_14002ACE0()
{
  sub_140011343(0i64);
  return sub_14001152D();
}
// 140011343: using guessed type __int64 __fastcall sub_140011343(_QWORD);
// 14001152D: using guessed type __int64 sub_14001152D(void);
// 14002ACE0: using guessed type __int64 __fastcall sub_14002ACE0();

//----- (000000014002AD00) ----------------------------------------------------
char __fastcall sub_14002AD00(int a1)
{
  if ( !a1 )
    byte_140037B08 = 1;
  sub_1400115FF();
  if ( !(unsigned __int8)sub_1400110F5() )
    return 0;
  if ( (unsigned __int8)sub_1400115AA() )
    return 1;
  sub_140011186();
  return 0;
}
// 1400110F5: using guessed type __int64 sub_1400110F5(void);
// 1400115AA: using guessed type __int64 sub_1400115AA(void);
// 1400115FF: using guessed type __int64 sub_1400115FF(void);
// 140037B08: using guessed type char byte_140037B08;

//----- (000000014002AD60) ----------------------------------------------------
char __fastcall sub_14002AD60(unsigned int a1)
{
  __int64 v2[3]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v3[3]; // [rsp+40h] [rbp-38h] BYREF

  if ( byte_140037B09 )
    return 1;
  if ( a1 >= 2 )
    sub_14001160E(5i64);
  if ( !(unsigned int)sub_1400112B2() || a1 )
  {
    memset(v2, 255, sizeof(v2));
    qmemcpy(&Table, v2, sizeof(Table));
    memset(v3, 255, sizeof(v3));
    qmemcpy(&stru_140037B28, v3, sizeof(stru_140037B28));
  }
  else
  {
    if ( j__initialize_onexit_table(&Table) )
      return 0;
    if ( j__initialize_onexit_table(&stru_140037B28) )
      return 0;
  }
  byte_140037B09 = 1;
  return 1;
}
// 1400112B2: using guessed type __int64 sub_1400112B2(void);
// 14001160E: using guessed type __int64 __fastcall sub_14001160E(_QWORD);
// 140037B09: using guessed type char byte_140037B09;

//----- (000000014002AEB0) ----------------------------------------------------
bool __fastcall sub_14002AEB0(__int64 a1)
{
  __int64 v2; // [rsp+30h] [rbp-28h]

  if ( !sub_14002AA10(0x140000000i64) )
    return 0;
  v2 = sub_14002A910(0x140000000i64, a1 - 0x140000000i64);
  return v2 && *(_DWORD *)(v2 + 36) >= 0;
}

//----- (000000014002AF60) ----------------------------------------------------
__int64 __fastcall sub_14002AF60(unsigned __int8 a1)
{
  __int64 result; // rax

  result = sub_1400112B2();
  if ( (_DWORD)result )
  {
    result = a1;
    if ( !a1 )
      return _InterlockedExchange64(&qword_140037B00, 0i64);
  }
  return result;
}
// 1400112B2: using guessed type __int64 sub_1400112B2(void);
// 140037B00: using guessed type signed __int64 qword_140037B00;

//----- (000000014002AFA0) ----------------------------------------------------
char __fastcall sub_14002AFA0(unsigned __int8 a1, char a2)
{
  if ( byte_140037B08 && a2 )
    return 1;
  sub_1400114C4(a1);
  sub_140011186();
  return 1;
}
// 140037B08: using guessed type char byte_140037B08;

//----- (000000014002AFF0) ----------------------------------------------------
void (__cdecl *__fastcall sub_14002AFF0(void (__cdecl *a1)()))()
{
  if ( Table._first == (_PVFV *)-1i64 )
  {
    if ( j__crt_atexit(a1) )
      return 0i64;
    else
      return a1;
  }
  else if ( j__register_onexit_function(&Table, (_onexit_t)a1) )
  {
    return 0i64;
  }
  else
  {
    return a1;
  }
}

//----- (000000014002B090) ----------------------------------------------------
int __fastcall sub_14002B090(void (__cdecl *a1)())
{
  if ( stru_140037B28._first == (_PVFV *)-1i64 )
    return j__crt_at_quick_exit(a1);
  else
    return j__register_onexit_function(&stru_140037B28, (_onexit_t)a1);
}

//----- (000000014002B0F0) ----------------------------------------------------
__int64 __fastcall sub_14002B0F0(void (__cdecl *a1)())
{
  if ( sub_140011159(a1) )
    return 0;
  else
    return (unsigned int)-1;
}

//----- (000000014002B130) ----------------------------------------------------
unsigned __int64 sub_14002B130()
{
  unsigned __int64 v1; // [rsp+20h] [rbp-28h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+28h] [rbp-20h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+30h] [rbp-18h] BYREF

  memset(&SystemTimeAsFileTime, 0, sizeof(SystemTimeAsFileTime));
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v1 = (unsigned __int64)SystemTimeAsFileTime;
  v1 ^= GetCurrentThreadId();
  v1 ^= GetCurrentProcessId();
  QueryPerformanceCounter(&PerformanceCount);
  return ((unsigned __int64)&v1 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32) ^ v1) & 0xFFFFFFFFFFFFi64;
}

//----- (000000014002B220) ----------------------------------------------------
uintptr_t sub_14002B220()
{
  uintptr_t result; // rax
  unsigned __int64 v1; // [rsp+20h] [rbp-18h]

  if ( _security_cookie == 0x2B992DDFA232i64 )
  {
    v1 = sub_14002B130();
    if ( v1 == 0x2B992DDFA232i64 )
      v1 = 0x2B992DDFA233i64;
    _security_cookie = v1;
    result = ~v1;
    qword_140037010 = ~v1;
  }
  else
  {
    result = ~_security_cookie;
    qword_140037010 = ~_security_cookie;
  }
  return result;
}
// 140037010: using guessed type __int64 qword_140037010;

//----- (000000014002B2C0) ----------------------------------------------------
__int64 sub_14002B2C0()
{
  return 0i64;
}
// 14002B2C0: using guessed type __int64 __fastcall sub_14002B2C0();

//----- (000000014002B2D0) ----------------------------------------------------
__int64 sub_14002B2D0()
{
  return 1i64;
}
// 14002B2D0: using guessed type __int64 __fastcall sub_14002B2D0();

//----- (000000014002B2E0) ----------------------------------------------------
__int64 sub_14002B2E0()
{
  return 0i64;
}
// 14002B2E0: using guessed type __int64 __fastcall sub_14002B2E0();

//----- (000000014002B2F0) ----------------------------------------------------
__int64 sub_14002B2F0()
{
  return 0x4000i64;
}
// 14002B2F0: using guessed type __int64 __fastcall sub_14002B2F0();

//----- (000000014002B300) ----------------------------------------------------
__int64 sub_14002B300()
{
  return 0i64;
}
// 14002B300: using guessed type __int64 __fastcall sub_14002B300();

//----- (000000014002B310) ----------------------------------------------------
__int64 sub_14002B310()
{
  return 0i64;
}
// 14002B310: using guessed type __int64 __fastcall sub_14002B310();

//----- (000000014002B320) ----------------------------------------------------
void sub_14002B320()
{
  InitializeSListHead(&ListHead);
}

//----- (000000014002B340) ----------------------------------------------------
__int64 sub_14002B340()
{
  return j___std_type_info_destroy_list(&ListHead);
}
// 1400115F5: using guessed type __int64 __fastcall j___std_type_info_destroy_list(_QWORD);
// 14002B340: using guessed type __int64 __fastcall sub_14002B340();

//----- (000000014002B360) ----------------------------------------------------
char sub_14002B360()
{
  return 1;
}

//----- (000000014002B390) ----------------------------------------------------
void *sub_14002B390()
{
  return &unk_140037B68;
}

//----- (000000014002B3A0) ----------------------------------------------------
__int64 sub_14002B3A0()
{
  __int64 result; // rax
  _QWORD *v1; // [rsp+20h] [rbp-18h]
  _QWORD *v2; // [rsp+28h] [rbp-10h]

  v1 = sub_14001103C();
  *v1 |= 0x24ui64;
  v2 = sub_14001108C();
  result = *v2 | 2i64;
  *v2 = result;
  return result;
}
// 14002B3A0: using guessed type __int64 __fastcall sub_14002B3A0();

//----- (000000014002B400) ----------------------------------------------------
_BOOL8 sub_14002B400()
{
  return dword_140037064 == 0;
}
// 140037064: using guessed type int dword_140037064;

//----- (000000014002B430) ----------------------------------------------------
void *sub_14002B430()
{
  return &unk_140037BB0;
}

//----- (000000014002B440) ----------------------------------------------------
void *sub_14002B440()
{
  return &unk_140037B98;
}

//----- (000000014002B450) ----------------------------------------------------
void sub_14002B450()
{
  dword_140037B74 = 0;
}
// 140037B74: using guessed type int dword_140037B74;

//----- (000000014002B470) ----------------------------------------------------
void __fastcall sub_14002B470(unsigned int a1)
{
  bool v1; // [rsp+41h] [rbp-5B7h]
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *FunctionEntry; // [rsp+48h] [rbp-5B0h]
  DWORD64 ControlPc; // [rsp+50h] [rbp-5A8h]
  unsigned __int64 ImageBase; // [rsp+58h] [rbp-5A0h] BYREF
  struct _EXCEPTION_POINTERS ExceptionInfo; // [rsp+60h] [rbp-598h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+70h] [rbp-588h] BYREF
  PVOID HandlerData; // [rsp+78h] [rbp-580h] BYREF
  _QWORD v8[20]; // [rsp+80h] [rbp-578h] BYREF
  struct _CONTEXT ContextRecord; // [rsp+120h] [rbp-4D8h] BYREF
  DWORD64 retaddr; // [rsp+5F8h] [rbp+0h]
  unsigned int v11; // [rsp+600h] [rbp+8h] BYREF

  v11 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(v11);
  sub_1400115BE();
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  RtlCaptureContext(&ContextRecord);
  ControlPc = ContextRecord.Rip;
  FunctionEntry = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
  if ( FunctionEntry )
    RtlVirtualUnwind(0, ImageBase, ControlPc, FunctionEntry, &ContextRecord, &HandlerData, &EstablisherFrame, 0i64);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v11;
  memset(v8, 0, 0x98ui64);
  v8[0] = 0x140000015i64;
  v8[2] = retaddr;
  v1 = IsDebuggerPresent();
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)v8;
  ExceptionInfo.ContextRecord = &ContextRecord;
  SetUnhandledExceptionFilter(0i64);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v1 )
    sub_1400115BE();
}

//----- (000000014002B670) ----------------------------------------------------
__int64 sub_14002B670()
{
  struct _STARTUPINFOW StartupInfo; // [rsp+30h] [rbp-78h] BYREF

  memset(&StartupInfo, 0, sizeof(StartupInfo));
  GetStartupInfoW(&StartupInfo);
  if ( (StartupInfo.dwFlags & 1) != 0 )
    return StartupInfo.wShowWindow;
  else
    return 10;
}
// 14002B670: using guessed type __int64 __fastcall sub_14002B670();

//----- (000000014002B6E0) ----------------------------------------------------
__int64 sub_14002B6E0()
{
  return sub_140011023();
}
// 140011023: using guessed type __int64 sub_140011023(void);
// 14002B6E0: using guessed type __int64 __fastcall sub_14002B6E0();

//----- (000000014002B700) ----------------------------------------------------
__int64 sub_14002B700()
{
  return 0i64;
}
// 14002B700: using guessed type __int64 __fastcall sub_14002B700();

//----- (000000014002B710) ----------------------------------------------------
bool sub_14002B710()
{
  HMODULE ModuleHandleW; // [rsp+20h] [rbp-18h]
  char *v2; // [rsp+28h] [rbp-10h]

  ModuleHandleW = GetModuleHandleW(0i64);
  if ( !ModuleHandleW )
    return 0;
  if ( *(_WORD *)ModuleHandleW != 23117 )
    return 0;
  v2 = (char *)ModuleHandleW + *((int *)ModuleHandleW + 15);
  if ( *(_DWORD *)v2 != 17744 )
    return 0;
  if ( *((_WORD *)v2 + 12) != 523 )
    return 0;
  if ( *((_DWORD *)v2 + 33) > 0xEu )
    return *((_DWORD *)v2 + 62) != 0;
  return 0;
}

//----- (000000014002B7E0) ----------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_14002B7E0()
{
  return SetUnhandledExceptionFilter(TopLevelExceptionFilter);
}

//----- (000000014002B800) ----------------------------------------------------
__int64 sub_14002B800()
{
  return 0i64;
}
// 14002B800: using guessed type __int64 __fastcall sub_14002B800();

//----- (000000014002B810) ----------------------------------------------------
__int64 __fastcall TopLevelExceptionFilter_0(_QWORD *a1)
{
  _DWORD *v2; // [rsp+20h] [rbp-18h]
  __int64 v3; // [rsp+28h] [rbp-10h]

  v2 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 == -529697949
    && v2[6] == 4
    && (v2[8] == 429065504 || v2[8] == 429065505 || v2[8] == 429065506 || v2[8] == 26820608) )
  {
    *(_QWORD *)j___current_exception() = v2;
    v3 = a1[1];
    *(_QWORD *)j___current_exception_context() = v3;
    j_terminate();
  }
  return 0i64;
}
// 140011046: using guessed type __int64 j_terminate(void);
// 14001113B: using guessed type __int64 j___current_exception(void);
// 1400114B0: using guessed type __int64 j___current_exception_context(void);

//----- (000000014002B8D0) ----------------------------------------------------
void sub_14002B8D0()
{
  void (**v0)(void); // rbx

  v0 = (void (**)(void))&unk_140034710;
  if ( &unk_140034710 < (_UNKNOWN *)qword_140034928 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < qword_140034928 );
  }
}
// 140034928: using guessed type void (*qword_140034928[35])(void);

//----- (000000014002B930) ----------------------------------------------------
void sub_14002B930()
{
  void (**v0)(void); // rbx

  v0 = (void (**)(void))&unk_140034A40;
  if ( &unk_140034A40 < (_UNKNOWN *)qword_140034C58 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < qword_140034C58 );
  }
}
// 140034C58: using guessed type void (*qword_140034C58[34])(void);

//----- (000000014002B990) ----------------------------------------------------
void sub_14002B990()
{
  ;
}

//----- (000000014002B9A0) ----------------------------------------------------
__int64 __fastcall sub_14002B9A0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014002B9D0) ----------------------------------------------------
__int64 __fastcall sub_14002B9D0(__int64 a1)
{
  return sub_1400110B9(a1);
}

//----- (000000014002B9F0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002B9F0(__int64 a1)
{
  _BOOL8 result; // rax

  result = sub_14002BB50(a1);
  if ( result )
    __debugbreak();
  return result;
}

//----- (000000014002BA20) ----------------------------------------------------
_BOOL8 __fastcall sub_14002BA20(__int64 a1)
{
  _BOOL8 result; // rax

  result = sub_14002BB50(a1);
  if ( result )
    __fastfail(0x41u);
  return result;
}

//----- (000000014002BA60) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14002BA60(__int64 a1))(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax

  result = (__int64 (__fastcall *)(_QWORD))sub_14002BB50(a1);
  if ( (_DWORD)result )
    return sub_14002BA90(a1);
  return result;
}

//----- (000000014002BA90) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14002BA90(__int64 a1))(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax

  result = _castguard_check_failure_os_handled_fptr;
  if ( _castguard_check_failure_os_handled_fptr )
    return (__int64 (__fastcall *)(_QWORD))_castguard_check_failure_os_handled_fptr(a1);
  return result;
}
// 14003F050: using guessed type __int64 (__fastcall *_castguard_check_failure_os_handled_fptr)(_QWORD);

//----- (000000014002BAD0) ----------------------------------------------------
__int64 __fastcall sub_14002BAD0(__int64 a1)
{
  __int64 result; // rax

  result = sub_14002BB50(a1);
  if ( (_DWORD)result )
    return sub_14002BB00(a1);
  return result;
}

//----- (000000014002BB00) ----------------------------------------------------
__int64 __fastcall sub_14002BB00(__int64 a1)
{
  __int64 result; // rax

  result = qword_140037B78;
  if ( qword_140037B78 )
    return ((__int64 (__fastcall *)(__int64))qword_140037B78)(a1);
  return result;
}
// 140037B78: using guessed type __int64 qword_140037B78;

//----- (000000014002BB50) ----------------------------------------------------
_BOOL8 __fastcall sub_14002BB50(__int64 a1)
{
  return a1 - ((__int64)&unk_140033E80 + 128) <= (unsigned __int64)(&unk_140034080
                                                                  - (_UNKNOWN *)((char *)&unk_140033E80 + 128));
}

//----- (000000014002BBE0) ----------------------------------------------------
__int64 __fastcall sub_14002BBE0(__int64 a1)
{
  return _InterlockedExchange64(&qword_140037B78, a1);
}
// 140037B78: using guessed type __int64 qword_140037B78;

//----- (000000014002BC10) ----------------------------------------------------
_BOOL8 __fastcall sub_14002BC10(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  _BOOL8 result; // rax

  result = sub_14002BDA0(a1, a2, a3);
  if ( result )
  {
    result = sub_14002BB50(a1);
    if ( result )
      __debugbreak();
  }
  return result;
}

//----- (000000014002BC60) ----------------------------------------------------
_BOOL8 __fastcall sub_14002BC60(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  _BOOL8 result; // rax

  result = sub_14002BDA0(a1, a2, a3);
  if ( result )
  {
    result = sub_14002BB50(a1);
    if ( result )
      __fastfail(0x41u);
  }
  return result;
}

//----- (000000014002BCE0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14002BCE0(__int64 a1, __int64 a2, unsigned __int64 a3))(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax

  result = (__int64 (__fastcall *)(_QWORD))sub_14002BDA0(a1, a2, a3);
  if ( (_DWORD)result )
  {
    result = (__int64 (__fastcall *)(_QWORD))sub_14002BB50(a1);
    if ( (_DWORD)result )
      return sub_14002BA90(a1);
  }
  return result;
}

//----- (000000014002BD40) ----------------------------------------------------
__int64 __fastcall sub_14002BD40(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  result = sub_14002BDA0(a1, a2, a3);
  if ( (_DWORD)result )
  {
    result = sub_14002BB50(a1);
    if ( (_DWORD)result )
      return sub_14002BB00(a1);
  }
  return result;
}
// 14002BB00: using guessed type __int64 __fastcall sub_14002BB00(_QWORD);
// 14002BB50: using guessed type __int64 __fastcall sub_14002BB50(_QWORD);
// 14002BDA0: using guessed type __int64 __fastcall sub_14002BDA0(_QWORD, _QWORD, _QWORD);

//----- (000000014002BDA0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002BDA0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  return a1 - ((__int64)&unk_140033E80 + a2 + 128) > a3;
}

//----- (000000014002BE30) ----------------------------------------------------
_BOOL8 sub_14002BE30()
{
  return sub_140011316((__int64)&_guard_check_icall_fptr) != (_QWORD)sub_140011055;
}
// 14003F000: using guessed type void (*_guard_check_icall_fptr)();

//----- (000000014002BE90) ----------------------------------------------------
__int64 sub_14002BE90()
{
  __int64 result; // rax
  __int64 ModuleHandleW; // rax
  wchar_t v2[264]; // [rsp+20h] [rbp-438h] BYREF
  wchar_t v3[264]; // [rsp+230h] [rbp-228h] BYREF

  if ( byte_140037B91 )
    return 0i64;
  byte_140037B91 = 1;
  result = sub_14002C050();
  if ( !result )
  {
    ModuleHandleW = j___vcrt_GetModuleHandleW(L"VCRUNTIME140D.dll");
    if ( !ModuleHandleW
      || !(unsigned int)j___vcrt_GetModuleFileNameW(ModuleHandleW, v3, 260i64)
      || !sub_14002C3B0(v3, v2, 0x104ui64)
      || (result = j___vcrt_LoadLibraryExW(v2, 0i64, 2304i64)) == 0
      && (GetLastError() != 87 || (result = j___vcrt_LoadLibraryExW(v2, 0i64, 8i64)) == 0) )
    {
      result = j___vcrt_LoadLibraryExW(L"MSPDB140", 0i64, 2560i64);
      if ( !result )
      {
        if ( GetLastError() == 87
          && (unsigned int)j___vcrt_GetModuleFileNameW(0i64, v3, 260i64)
          && sub_14002C3B0(v3, v2, 0x104ui64) )
        {
          return j___vcrt_LoadLibraryExW(v2, 0i64, 8i64);
        }
        return 0i64;
      }
    }
  }
  return result;
}
// 14001100A: using guessed type __int64 __fastcall j___vcrt_LoadLibraryExW(_QWORD, _QWORD, _QWORD);
// 1400111F9: using guessed type __int64 __fastcall j___vcrt_GetModuleHandleW(_QWORD);
// 140011762: using guessed type __int64 __fastcall j___vcrt_GetModuleFileNameW(_QWORD, _QWORD, _QWORD);
// 14002BE90: using guessed type __int64 __fastcall sub_14002BE90();
// 14002C050: using guessed type __int64 sub_14002C050(void);
// 1400338B0: using guessed type wchar_t aVcruntime140dD[18];
// 140033A78: using guessed type wchar_t aMspdb140[9];
// 140037B91: using guessed type char byte_140037B91;
// 14002BE90: using guessed type wchar_t var_228[264];
// 14002BE90: using guessed type wchar_t var_438[264];

//----- (000000014002C050) ----------------------------------------------------
__int64 sub_14002C050()
{
  HMODULE Library; // rdi
  LSTATUS (__stdcall *RegOpenKeyExW)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY); // rbx
  LSTATUS (__stdcall *RegQueryValueExW)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // rsi
  LSTATUS (__stdcall *RegCloseKey)(HKEY); // r14
  int v5; // ebx
  unsigned int v6; // r9d
  __int64 v7; // rdx
  __int64 v8; // rbx
  unsigned int v9; // [rsp+40h] [rbp-C0h] BYREF
  int v10; // [rsp+44h] [rbp-BCh] BYREF
  __int64 v11; // [rsp+48h] [rbp-B8h] BYREF
  int v12[132]; // [rsp+50h] [rbp-B0h] BYREF

  Library = (HMODULE)j___vcrt_LoadLibraryExW(L"api-ms-win-core-registry-l1-1-0.dll", 0i64, 2048i64);
  if ( !Library )
  {
    Library = (HMODULE)j___vcrt_LoadLibraryExW(L"advapi32.dll", 0i64, 2048i64);
    if ( !Library )
    {
      if ( GetLastError() != 87 )
        return 0i64;
      Library = (HMODULE)j___vcrt_LoadLibraryExW(L"advapi32.dll", 0i64, 0i64);
      if ( !Library )
        return 0i64;
    }
  }
  RegOpenKeyExW = (LSTATUS (__stdcall *)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY))GetProcAddress(Library, "RegOpenKeyExW");
  if ( !RegOpenKeyExW )
    return 0i64;
  RegQueryValueExW = (LSTATUS (__stdcall *)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD))GetProcAddress(
                                                                                                Library,
                                                                                                "RegQueryValueExW");
  if ( !RegQueryValueExW )
    return 0i64;
  RegCloseKey = (LSTATUS (__stdcall *)(HKEY))GetProcAddress(Library, "RegCloseKey");
  if ( !RegCloseKey )
    return 0i64;
  if ( ((unsigned int (__fastcall *)(__int64, const wchar_t *, _QWORD, __int64, __int64 *))RegOpenKeyExW)(
         -2147483646i64,
         L"SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\14.0\\Setup\\VC",
         0i64,
         1i64,
         &v11) )
  {
    FreeLibrary(Library);
    return 0i64;
  }
  v9 = 520;
  v5 = ((__int64 (__fastcall *)(__int64, const wchar_t *, _QWORD, int *, int *, unsigned int *))RegQueryValueExW)(
         v11,
         L"ProductDir",
         0i64,
         &v10,
         v12,
         &v9);
  ((void (__fastcall *)(__int64))RegCloseKey)(v11);
  FreeLibrary(Library);
  if ( v5 )
    return 0i64;
  if ( v10 != 1 )
    return 0i64;
  if ( (v9 & 1) != 0 )
    return 0i64;
  v6 = v9 >> 1;
  if ( v9 >> 1 < 2 )
    return 0i64;
  v7 = (v9 >> 1) - 1;
  if ( *((_WORD *)v12 + v7) )
    return 0i64;
  if ( *((_WORD *)&v12[-1] + (v9 >> 1)) != 92 )
  {
    *((_WORD *)v12 + v7) = 92;
    LODWORD(v7) = v6;
  }
  if ( (unsigned int)~(_DWORD)v7 < 0x18 || (unsigned __int64)(unsigned int)v7 + 23 > 0x104 )
    return 0i64;
  *(int *)((char *)v12 + 2 * (unsigned int)v7) = 6881378;
  *(int *)((char *)&v12[1] + 2 * (unsigned int)v7) = 6029422;
  *(int *)((char *)&v12[2] + 2 * (unsigned int)v7) = 7143521;
  *(int *)((char *)&v12[3] + 2 * (unsigned int)v7) = 3539044;
  *(int *)((char *)&v12[4] + 2 * (unsigned int)v7) = 6029364;
  *(int *)((char *)&v12[5] + 2 * (unsigned int)v7) = 5439565;
  *(int *)((char *)&v12[6] + 2 * (unsigned int)v7) = 4456528;
  *(int *)((char *)&v12[7] + 2 * (unsigned int)v7) = 3211330;
  *(int *)((char *)&v12[8] + 2 * (unsigned int)v7) = 3145780;
  *(int *)((char *)&v12[9] + 2 * (unsigned int)v7) = 4456494;
  *(int *)((char *)&v12[10] + 2 * (unsigned int)v7) = 4980812;
  *((_WORD *)&v12[11] + (unsigned int)v7) = 0;
  v8 = j___vcrt_LoadLibraryExW(v12, 0i64, 2304i64);
  if ( !v8 && GetLastError() == 87 )
    return j___vcrt_LoadLibraryExW(v12, 0i64, 8i64);
  return v8;
}
// 14001100A: using guessed type __int64 __fastcall j___vcrt_LoadLibraryExW(_QWORD, _QWORD, _QWORD);
// 14002C050: using guessed type __int64 __fastcall sub_14002C050();
// 1400338F0: using guessed type wchar_t aApiMsWinCoreRe[36];
// 140033948: using guessed type wchar_t aAdvapi32Dll[13];
// 1400339A0: using guessed type wchar_t aSoftwareWow643[58];
// 140033A30: using guessed type wchar_t aProductdir[11];

//----- (000000014002C3B0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002C3B0(const wchar_t *a1, wchar_t *a2, size_t a3)
{
  wchar_t Drive[8]; // [rsp+50h] [rbp-628h] BYREF
  wchar_t Ext[256]; // [rsp+60h] [rbp-618h] BYREF
  wchar_t Destination[256]; // [rsp+260h] [rbp-418h] BYREF
  wchar_t Dir[256]; // [rsp+460h] [rbp-218h] BYREF

  return !j__wsplitpath_s(a1, Drive, 3ui64, Dir, 0x100ui64, Destination, 0x100ui64, Ext, 0x100ui64)
      && !j_wcscpy_s(Destination, 9ui64, L"MSPDB140")
      && !j_wcscpy_s(Ext, 4ui64, L"DLL")
      && j__wmakepath_s(a2, a3, Drive, Dir, Destination, Ext) == 0;
}

//----- (000000014002C500) ----------------------------------------------------
__int64 __fastcall sub_14002C500(__int64 a1, _WORD *a2, int a3, int *a4, __int64 a5, unsigned int a6)
{
  unsigned int v6; // r14d
  int v7; // esi
  __int64 AllocationBase; // rcx
  __int64 v11; // rax
  char *v12; // rax
  unsigned int v13; // esi
  unsigned int v14; // r8d
  char *v15; // rdx
  unsigned int v16; // edi
  unsigned int i; // ebx
  unsigned int v18; // eax
  unsigned int v19; // ebx
  HMODULE v20; // rax
  FARPROC PDBOpenValidate5; // rax
  unsigned int *v22; // rsi
  __int64 v23; // rbx
  HANDLE ProcessHeap; // rax
  unsigned int *v25; // rax
  unsigned int v26; // edi
  unsigned int j; // ecx
  __int64 v28; // rdx
  unsigned int v29; // eax
  __int64 v30; // rcx
  HANDLE v31; // rax
  __int64 v33; // [rsp+50h] [rbp-49h] BYREF
  int v34; // [rsp+58h] [rbp-41h] BYREF
  unsigned int v35; // [rsp+5Ch] [rbp-3Dh] BYREF
  __int64 v36; // [rsp+60h] [rbp-39h] BYREF
  __int64 v37; // [rsp+68h] [rbp-31h] BYREF
  __int64 v38; // [rsp+70h] [rbp-29h] BYREF
  char v39[8]; // [rsp+78h] [rbp-21h] BYREF
  struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+80h] [rbp-19h] BYREF
  unsigned __int16 v41; // [rsp+F0h] [rbp+57h] BYREF
  unsigned int v42; // [rsp+F8h] [rbp+5Fh] BYREF
  int v43; // [rsp+100h] [rbp+67h] BYREF
  unsigned int v44; // [rsp+108h] [rbp+6Fh] BYREF

  v43 = a3;
  v6 = 0;
  v7 = a1 - 1;
  *a4 = 0;
  *a2 = 0;
  if ( !VirtualQuery((LPCVOID)(a1 - 1), &Buffer, 0x30ui64) )
    return 0i64;
  if ( !(unsigned int)j___vcrt_GetModuleFileNameW(Buffer.AllocationBase, a5, a6) )
    return 0i64;
  AllocationBase = (__int64)Buffer.AllocationBase;
  if ( *(_WORD *)Buffer.AllocationBase != 23117 )
    return 0i64;
  v11 = *((int *)Buffer.AllocationBase + 15);
  if ( (int)v11 <= 0 )
    return 0i64;
  v12 = (char *)Buffer.AllocationBase + v11;
  if ( *(_DWORD *)v12 != 17744 )
    return 0i64;
  v13 = v7 - LODWORD(Buffer.AllocationBase);
  v14 = *((unsigned __int16 *)v12 + 3);
  v15 = &v12[*((unsigned __int16 *)v12 + 10)];
  v16 = 0;
  for ( i = 0; i < v14; ++i )
  {
    AllocationBase = 5i64 * i;
    v18 = *(_DWORD *)&v15[40 * i + 36];
    if ( v13 >= v18 )
    {
      v16 = v13 - v18;
      if ( v13 < *(_DWORD *)&v15[40 * i + 32] )
        break;
    }
  }
  if ( i == v14 )
    return 0i64;
  v19 = i + 1;
  if ( byte_140037B92 )
  {
    v20 = (HMODULE)qword_140037B88;
  }
  else
  {
    if ( qword_140037B88 )
      return 0i64;
    v20 = (HMODULE)sub_14002BE90(AllocationBase, v15);
    qword_140037B88 = (__int64)v20;
    if ( !v20 )
      return 0i64;
    byte_140037B92 = 1;
  }
  PDBOpenValidate5 = GetProcAddress(v20, "PDBOpenValidate5");
  if ( !PDBOpenValidate5
    || !((unsigned int (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD, char *, _QWORD, _QWORD, __int64 *))PDBOpenValidate5)(
          a5,
          0i64,
          0i64,
          0i64,
          v39,
          0i64,
          0i64,
          &v37) )
  {
    return 0i64;
  }
  v22 = 0i64;
  v33 = 0i64;
  if ( (**(unsigned int (__fastcall ***)(__int64))v37)(v37) == 20091201
    && (*(unsigned int (__fastcall **)(__int64, _QWORD, const char *, __int64 *))(*(_QWORD *)v37 + 56i64))(
         v37,
         0i64,
         "r",
         &v38) )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD, __int64 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v38 + 64i64))(
           v38,
           (unsigned __int16)v19,
           v16,
           &v36,
           0i64,
           0i64,
           0i64) )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v36 + 208i64))(v36, &v33) && v33 )
      {
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v33 + 16i64))(v33) )
        {
          while ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, unsigned int *, unsigned __int16 *, int *, unsigned int *, _QWORD))(*(_QWORD *)v33 + 24i64))(
                    v33,
                    0i64,
                    &v44,
                    &v41,
                    &v34,
                    &v42,
                    0i64) )
          {
            if ( v41 == v19 && v44 <= v16 && v16 < v34 + v44 )
            {
              if ( !v42 )
                break;
              v23 = v42;
              ProcessHeap = GetProcessHeap();
              v25 = (unsigned int *)HeapAlloc(ProcessHeap, 0, 8 * v23);
              v22 = v25;
              if ( !v25 )
                break;
              if ( (*(unsigned __int8 (__fastcall **)(__int64, unsigned int *, _QWORD, _QWORD, _QWORD, unsigned int *, unsigned int *))(*(_QWORD *)v33 + 24i64))(
                     v33,
                     &v35,
                     0i64,
                     0i64,
                     0i64,
                     &v42,
                     v25) )
              {
                v26 = v16 - v44;
                if ( v26 >= *v22 )
                {
                  for ( j = 1; j < v42; ++j )
                  {
                    if ( v26 < v22[2 * j] )
                      break;
                  }
                  v28 = v35;
                  v29 = v22[2 * j - 1];
                  v30 = v36;
                  *a4 = v29 & 0xFFFFFF;
                  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, _WORD *, int *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v30 + 224i64))(
                         v30,
                         v28,
                         a2,
                         &v43,
                         0i64,
                         0i64,
                         0i64) )
                  {
                    v6 = 1;
                  }
                }
              }
              goto LABEL_39;
            }
            if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v33 + 16i64))(v33) )
              goto LABEL_39;
          }
        }
        else
        {
LABEL_39:
          v31 = GetProcessHeap();
          HeapFree(v31, 0, v22);
        }
        (**(void (__fastcall ***)(__int64))v33)(v33);
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v36 + 128i64))(v36);
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v38 + 112i64))(v38);
  }
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v37 + 88i64))(v37);
  return v6;
}
// 140011762: using guessed type __int64 __fastcall j___vcrt_GetModuleFileNameW(_QWORD, _QWORD, _QWORD);
// 14002BE90: using guessed type __int64 __fastcall sub_14002BE90(_QWORD, _QWORD);
// 140037B88: using guessed type __int64 qword_140037B88;
// 140037B92: using guessed type char byte_140037B92;
// 14002C500: using guessed type char var_68[8];

//----- (000000014002C9C0) ----------------------------------------------------
_BOOL8 sub_14002C9C0()
{
  return dword_140037070 != 0;
}
// 140037070: using guessed type int dword_140037070;

//----- (000000014002CBE0) ----------------------------------------------------
char sub_14002CBE0()
{
  return 1;
}

//----- (000000014002CBF0) ----------------------------------------------------
char sub_14002CBF0()
{
  return 1;
}

//----- (000000014002CC00) ----------------------------------------------------
char sub_14002CC00()
{
  return 1;
}

//----- (000000014002CC10) ----------------------------------------------------
char sub_14002CC10()
{
  return 1;
}

//----- (000000014002CC20) ----------------------------------------------------
char sub_14002CC20()
{
  return 1;
}

//----- (000000014002CC30) ----------------------------------------------------
__int64 sub_14002CC30()
{
  return 0i64;
}
// 14002CC30: using guessed type __int64 __fastcall sub_14002CC30();

//----- (000000014002F590) ----------------------------------------------------
__int64 __fastcall sub_14002F590(__int64 a1, __int64 a2)
{
  return sub_140011429(a2 + 136);
}
// 140011429: using guessed type __int64 __fastcall sub_140011429(_QWORD);

//----- (000000014002F5C0) ----------------------------------------------------
void *__fastcall sub_14002F5C0(__int64 a1, __int64 a2, __int64 a3)
{
  LOBYTE(a3) = 1;
  std::ios::setstate(*(int *)(**(_QWORD **)(a2 + 576) + 4i64) + *(_QWORD *)(a2 + 576), 4i64, a3);
  return &loc_1400123E8;
}
// 14003C1A8: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);

//----- (000000014002F630) ----------------------------------------------------
__int64 __fastcall sub_14002F630(__int64 a1, __int64 a2)
{
  return sub_14001169F(a2 + 104);
}
// 14001169F: using guessed type __int64 __fastcall sub_14001169F(_QWORD);

//----- (000000014002F660) ----------------------------------------------------
void *__fastcall sub_14002F660(__int64 a1, __int64 a2, __int64 a3)
{
  LOBYTE(a3) = 1;
  std::ios::setstate(*(int *)(**(_QWORD **)(a2 + 512) + 4i64) + *(_QWORD *)(a2 + 512), 4i64, a3);
  return &loc_140013805;
}
// 14003C1A8: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);

//----- (000000014002F6D0) ----------------------------------------------------
__int64 __fastcall sub_14002F6D0(__int64 a1, __int64 a2)
{
  return sub_140011127(*(_QWORD *)(a2 + 256));
}

//----- (000000014002F700) ----------------------------------------------------
__int64 __fastcall sub_14002F700(__int64 a1, __int64 a2)
{
  return sub_14001130C(*(_QWORD *)(a2 + 288));
}

//----- (000000014002F730) ----------------------------------------------------
__int64 __fastcall sub_14002F730(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_DWORD *)(a2 + 516) & 1;
  if ( (_DWORD)result )
  {
    *(_DWORD *)(a2 + 516) &= ~1u;
    return sub_140011177(*(__int64 **)(a2 + 592));
  }
  return result;
}

//----- (000000014002F780) ----------------------------------------------------
__int64 __fastcall sub_14002F780(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_DWORD *)(a2 + 612) & 1;
  if ( (_DWORD)result )
  {
    *(_DWORD *)(a2 + 612) &= ~1u;
    return sub_140011177(*(__int64 **)(a2 + 672));
  }
  return result;
}

//----- (000000014002F7D0) ----------------------------------------------------
__int64 __fastcall sub_14002F7D0(__int64 a1, __int64 a2)
{
  return sub_140011177((__int64 *)(a2 + 40));
}

//----- (000000014002F800) ----------------------------------------------------
__int64 __fastcall sub_14002F800(__int64 a1, __int64 a2)
{
  return sub_140011177((__int64 *)(a2 + 104));
}

//----- (000000014002F830) ----------------------------------------------------
__int64 __fastcall sub_14002F830(__int64 a1, __int64 a2)
{
  return sub_140011177((__int64 *)(a2 + 376));
}

//----- (000000014002F860) ----------------------------------------------------
int __fastcall sub_14002F860(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a2 + 64) = a1;
  *(_DWORD *)(a2 + 36) = ***(_DWORD ***)(a2 + 64);
  return j__seh_filter_exe(*(_DWORD *)(a2 + 36), *(struct _EXCEPTION_POINTERS **)(a2 + 64));
}

//----- (000000014002F8A0) ----------------------------------------------------
_BOOL8 __fastcall sub_14002F8A0(_DWORD **a1)
{
  return **a1 == 1080890248;
}

//----- (000000014002F8D0) ----------------------------------------------------
__int64 __fastcall sub_14002F8D0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a2 + 72) = a1;
  *(_DWORD *)(a2 + 36) = ***(_DWORD ***)(a2 + 72);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a2 + 36) == -1073741819;
  return *(unsigned int *)(a2 + 32);
}

// nfuncs=813 queued=479 decompiled=479 lumina nreq=0 worse=0 better=0
// ALL OK, 479 function(s) have been successfully decompiled
